(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('@angular/platform-browser')) :
    typeof define === 'function' && define.amd ? define('@jaspero/ng-helpers', ['exports', '@angular/common', '@angular/core', 'rxjs', 'rxjs/operators', '@angular/platform-browser'], factory) :
    (global = global || self, factory((global.jaspero = global.jaspero || {}, global.jaspero['ng-helpers'] = {}), global.ng.common, global.ng.core, global.rxjs, global.rxjs.operators, global.ng.platformBrowser));
}(this, (function (exports, common, core, rxjs, operators, platformBrowser) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Courtesy of
     * https://blog.angularindepth.com/creatively-decouple-ngonchanges-fab95395cc6e
     */
    /**
     * @record
     * @template T
     */
    function SimpleChange() { }
    if (false) {
        /** @type {?} */
        SimpleChange.prototype.firstChange;
        /** @type {?} */
        SimpleChange.prototype.previousValue;
        /** @type {?} */
        SimpleChange.prototype.currentValue;
        /** @type {?} */
        SimpleChange.prototype.isFirstChange;
    }
    /**
     * @template T
     * @param {?} callback
     * @return {?}
     */
    function OnChange(callback) {
        /** @type {?} */
        var cachedValueKey = Symbol();
        /** @type {?} */
        var isFirstChangeKey = Symbol();
        return function (target, key) {
            Object.defineProperty(target, key, {
                set: function (value) {
                    var _this = this;
                    /**
                     * Change status of "isFirstChange"
                     */
                    this[isFirstChangeKey] = this[isFirstChangeKey] === undefined;
                    /**
                     *  No operation if new value is same as old value
                     */
                    if (!this[isFirstChangeKey] && this[cachedValueKey] === value) {
                        return;
                    }
                    /** @type {?} */
                    var oldValue = this[cachedValueKey];
                    this[cachedValueKey] = value;
                    /** @type {?} */
                    var simpleChange = {
                        firstChange: this[isFirstChangeKey],
                        previousValue: oldValue,
                        currentValue: this[cachedValueKey],
                        isFirstChange: function () { return _this[isFirstChangeKey]; },
                    };
                    callback.call(this, this[cachedValueKey], simpleChange);
                },
                get: function () {
                    return this[cachedValueKey];
                }
            });
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Emits an event when a click action occurs that does not target the element
     *
     * \@example
     * <div (jpClickOutside)="doSomething()"></div>
     */
    var ClickOutsideDirective = /** @class */ (function () {
        /**
         * @param {?} _el
         * @param {?} _ngZone
         */
        function ClickOutsideDirective(_el, _ngZone) {
            this._el = _el;
            this._ngZone = _ngZone;
            /**
             * Any valid html event
             */
            this.clickOutsideEventType = 'click';
            /**
             * if true jpClickOutside doesn't emit
             */
            this.clickOutsideBlock = false;
            /**
             * Emits when triggered event doesn't contain this e
             */
            this.jpClickOutside = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        ClickOutsideDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            this._ngZone.runOutsideAngular(function () {
                _this.subscription = rxjs.fromEvent(window, _this.clickOutsideEventType)
                    .pipe(operators.filter(function (event) { return !_this.clickOutsideBlock &&
                    !_this._el.nativeElement.contains(event.target); }))
                    .subscribe(function (event) {
                    _this._ngZone.run(function () {
                        _this.jpClickOutside.emit(event);
                    });
                });
            });
        };
        /**
         * @return {?}
         */
        ClickOutsideDirective.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        return ClickOutsideDirective;
    }());
    ClickOutsideDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[jpClickOutside]'
                },] }
    ];
    /** @nocollapse */
    ClickOutsideDirective.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.NgZone }
    ]; };
    ClickOutsideDirective.propDecorators = {
        clickOutsideEventType: [{ type: core.Input }],
        clickOutsideBlock: [{ type: core.Input }],
        jpClickOutside: [{ type: core.Output }]
    };
    if (false) {
        /**
         * Any valid html event
         * @type {?}
         */
        ClickOutsideDirective.prototype.clickOutsideEventType;
        /**
         * if true jpClickOutside doesn't emit
         * @type {?}
         */
        ClickOutsideDirective.prototype.clickOutsideBlock;
        /**
         * Emits when triggered event doesn't contain this e
         * @type {?}
         */
        ClickOutsideDirective.prototype.jpClickOutside;
        /** @type {?} */
        ClickOutsideDirective.prototype.subscription;
        /**
         * @type {?}
         * @private
         */
        ClickOutsideDirective.prototype._el;
        /**
         * @type {?}
         * @private
         */
        ClickOutsideDirective.prototype._ngZone;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ClickOutsideModule = /** @class */ (function () {
        function ClickOutsideModule() {
        }
        return ClickOutsideModule;
    }());
    ClickOutsideModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule
                    ],
                    declarations: [
                        ClickOutsideDirective
                    ],
                    exports: [
                        ClickOutsideDirective
                    ]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Used for preventing propagation on event calls event.stopPropagation())
     *
     * \@example
     * <div (jpStopPropagation)="doSomething()"></div>
     */
    var StopPropagationDirective = /** @class */ (function () {
        /**
         * @param {?} _renderer
         * @param {?} _el
         */
        function StopPropagationDirective(_renderer, _el) {
            this._renderer = _renderer;
            this._el = _el;
            /**
             * Any valid html event
             */
            this.stopPropagationEventType = 'click';
            /**
             * Should preventDefault also be called
             */
            this.preventDefault = false;
            /**
             * Outputs the input event
             */
            this.jpStopPropagation = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        StopPropagationDirective.prototype.ngOnInit = function () {
            var _this = this;
            this._renderer.listen(this._el.nativeElement, this.stopPropagationEventType, function (event) {
                if (_this.preventDefault) {
                    event.preventDefault();
                }
                if (_this.condition !== undefined) {
                    if (typeof _this.condition === 'boolean') {
                        if (_this.condition) {
                            _this.sp(event);
                        }
                    }
                    else if (_this.condition(event)) {
                        _this.sp(event);
                    }
                }
                else {
                    _this.sp(event);
                }
            });
        };
        /**
         * @private
         * @param {?} event
         * @return {?}
         */
        StopPropagationDirective.prototype.sp = function (event) {
            event.stopPropagation();
            this.jpStopPropagation.emit(event);
        };
        return StopPropagationDirective;
    }());
    StopPropagationDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[jpStopPropagation]'
                },] }
    ];
    /** @nocollapse */
    StopPropagationDirective.ctorParameters = function () { return [
        { type: core.Renderer2 },
        { type: core.ElementRef }
    ]; };
    StopPropagationDirective.propDecorators = {
        stopPropagationEventType: [{ type: core.Input }],
        preventDefault: [{ type: core.Input }],
        condition: [{ type: core.Input }],
        jpStopPropagation: [{ type: core.Output }]
    };
    if (false) {
        /**
         * Any valid html event
         * @type {?}
         */
        StopPropagationDirective.prototype.stopPropagationEventType;
        /**
         * Should preventDefault also be called
         * @type {?}
         */
        StopPropagationDirective.prototype.preventDefault;
        /** @type {?} */
        StopPropagationDirective.prototype.condition;
        /**
         * Outputs the input event
         * @type {?}
         */
        StopPropagationDirective.prototype.jpStopPropagation;
        /**
         * @type {?}
         * @private
         */
        StopPropagationDirective.prototype._renderer;
        /**
         * @type {?}
         * @private
         */
        StopPropagationDirective.prototype._el;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var StopPropagationModule = /** @class */ (function () {
        function StopPropagationModule() {
        }
        return StopPropagationModule;
    }());
    StopPropagationModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule
                    ],
                    declarations: [
                        StopPropagationDirective
                    ],
                    exports: [
                        StopPropagationDirective
                    ]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FormTouchOnHoverDirective = /** @class */ (function () {
        function FormTouchOnHoverDirective() {
            this.jpFormTouched = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        FormTouchOnHoverDirective.prototype.enter = function () {
            if (Array.isArray(this.jpFormTouchOnHover)) {
                this.jpFormTouchOnHover.forEach(function (form) { return form.markAllAsTouched(); });
            }
            else {
                this.jpFormTouchOnHover.markAllAsTouched();
            }
            this.jpFormTouched.emit();
        };
        return FormTouchOnHoverDirective;
    }());
    FormTouchOnHoverDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[jpFormTouchOnHover]'
                },] }
    ];
    FormTouchOnHoverDirective.propDecorators = {
        jpFormTouchOnHover: [{ type: core.Input }],
        jpFormTouched: [{ type: core.Output }],
        enter: [{ type: core.HostListener, args: ['mouseenter',] }]
    };
    if (false) {
        /** @type {?} */
        FormTouchOnHoverDirective.prototype.jpFormTouchOnHover;
        /** @type {?} */
        FormTouchOnHoverDirective.prototype.jpFormTouched;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FormTouchOnHoverModule = /** @class */ (function () {
        function FormTouchOnHoverModule() {
        }
        return FormTouchOnHoverModule;
    }());
    FormTouchOnHoverModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule
                    ],
                    declarations: [
                        FormTouchOnHoverDirective
                    ],
                    exports: [
                        FormTouchOnHoverDirective
                    ]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var DEBOUNCE_TIME = new core.InjectionToken('DEBOUNCE_TIME');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DebounceChangeDirective = /** @class */ (function () {
        /**
         * @param {?} _el
         * @param {?} _ngZone
         * @param {?} _defaultDebounceTime
         */
        function DebounceChangeDirective(_el, _ngZone, _defaultDebounceTime) {
            this._el = _el;
            this._ngZone = _ngZone;
            this._defaultDebounceTime = _defaultDebounceTime;
            /**
             * Any valid html event
             */
            this.debounceChangeEventType = 'keyup';
            /**
             * If true and the event has a 'target.value'
             * we listen for it and only emit if the value changed
             */
            this.emitOnlyOnChange = false;
            /**
             * Emits original event after debounce
             */
            this.jpDebounceChange = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        DebounceChangeDirective.prototype.ngAfterViewInit = function () {
            var _this = this;
            this._ngZone.runOutsideAngular(function () {
                /** @type {?} */
                var prev = _this._el.nativeElement.value;
                _this.subscription = rxjs.fromEvent(_this._el.nativeElement, _this.debounceChangeEventType)
                    .pipe(operators.debounceTime(_this.debounceTime || _this._defaultDebounceTime), operators.filter(function (event) {
                    return event.target &&
                        event.target.value !== undefined &&
                        _this.emitOnlyOnChange ?
                        event.target.value !== prev :
                        true;
                }))
                    .subscribe(function (event) {
                    _this._ngZone.run(function () {
                        if (event.target) {
                            prev = event.target.value;
                        }
                        _this.jpDebounceChange.emit(event.target.value);
                    });
                });
            });
        };
        /**
         * @return {?}
         */
        DebounceChangeDirective.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        return DebounceChangeDirective;
    }());
    DebounceChangeDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[jpDebounceChange]'
                },] }
    ];
    /** @nocollapse */
    DebounceChangeDirective.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.NgZone },
        { type: Number, decorators: [{ type: core.Inject, args: [DEBOUNCE_TIME,] }] }
    ]; };
    DebounceChangeDirective.propDecorators = {
        debounceTime: [{ type: core.Input }],
        debounceChangeEventType: [{ type: core.Input }],
        emitOnlyOnChange: [{ type: core.Input }],
        jpDebounceChange: [{ type: core.Output }]
    };
    if (false) {
        /**
         * time to forward to the debounceTime pipe
         * @type {?}
         */
        DebounceChangeDirective.prototype.debounceTime;
        /**
         * Any valid html event
         * @type {?}
         */
        DebounceChangeDirective.prototype.debounceChangeEventType;
        /**
         * If true and the event has a 'target.value'
         * we listen for it and only emit if the value changed
         * @type {?}
         */
        DebounceChangeDirective.prototype.emitOnlyOnChange;
        /**
         * Emits original event after debounce
         * @type {?}
         */
        DebounceChangeDirective.prototype.jpDebounceChange;
        /** @type {?} */
        DebounceChangeDirective.prototype.subscription;
        /**
         * @type {?}
         * @private
         */
        DebounceChangeDirective.prototype._el;
        /**
         * @type {?}
         * @private
         */
        DebounceChangeDirective.prototype._ngZone;
        /**
         * @type {?}
         * @private
         */
        DebounceChangeDirective.prototype._defaultDebounceTime;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DebounceChangeModule = /** @class */ (function () {
        function DebounceChangeModule() {
        }
        /**
         * @param {?} value
         * @return {?}
         */
        DebounceChangeModule.defaultDebounceTime = function (value) {
            return {
                ngModule: DebounceChangeModule,
                providers: [
                    {
                        provide: DEBOUNCE_TIME,
                        useValue: value
                    }
                ]
            };
        };
        return DebounceChangeModule;
    }());
    DebounceChangeModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule
                    ],
                    declarations: [
                        DebounceChangeDirective
                    ],
                    exports: [
                        DebounceChangeDirective
                    ],
                    providers: [
                        {
                            provide: DEBOUNCE_TIME,
                            useValue: 500
                        }
                    ]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     */
    var TrackByFieldDirective = /** @class */ (function () {
        /**
         * @param {?} ngFor
         * @param {?} defaultKey
         */
        function TrackByFieldDirective(ngFor, defaultKey) {
            var _this = this;
            this.ngFor = ngFor;
            this.defaultKey = defaultKey;
            this.ngFor.ngForTrackBy = function (index, item) { return item[_this.ngForJpTrackByField || _this.defaultKey]; };
        }
        return TrackByFieldDirective;
    }());
    TrackByFieldDirective.decorators = [
        { type: core.Directive, args: [{
                    // tslint:disable-next-line
                    selector: '[ngForJpTrackByField]',
                },] }
    ];
    /** @nocollapse */
    TrackByFieldDirective.ctorParameters = function () { return [
        { type: common.NgForOf, decorators: [{ type: core.Host }] },
        { type: undefined, decorators: [{ type: core.Inject, args: ['defaultKey',] }] }
    ]; };
    TrackByFieldDirective.propDecorators = {
        ngForJpTrackByField: [{ type: core.Input }]
    };
    if (false) {
        /** @type {?} */
        TrackByFieldDirective.prototype.ngForJpTrackByField;
        /**
         * @type {?}
         * @private
         */
        TrackByFieldDirective.prototype.ngFor;
        /**
         * @type {?}
         * @private
         */
        TrackByFieldDirective.prototype.defaultKey;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TrackByFieldModule = /** @class */ (function () {
        function TrackByFieldModule() {
        }
        /**
         * @param {?=} value
         * @return {?}
         */
        TrackByFieldModule.defaultKey = function (value) {
            if (value === void 0) { value = 'id'; }
            return {
                ngModule: TrackByFieldModule,
                providers: [
                    {
                        provide: 'defaultKey',
                        useValue: value
                    }
                ]
            };
        };
        return TrackByFieldModule;
    }());
    TrackByFieldModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule
                    ],
                    declarations: [
                        TrackByFieldDirective
                    ],
                    exports: [
                        TrackByFieldDirective
                    ],
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var LOAD_CLICK_CLASS = new core.InjectionToken('LOAD_CLICK_CLASS');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Directive will add loading class to the host element on click event
     * Usage: [jpLoadClick]="save()"
     * Function save() should return observable
     */
    var LoadClickDirective = /** @class */ (function () {
        /**
         * @param {?} _el
         * @param {?} _renderer
         * @param {?} _defaultLoadClickClass
         */
        function LoadClickDirective(_el, _renderer, _defaultLoadClickClass) {
            this._el = _el;
            this._renderer = _renderer;
            this._defaultLoadClickClass = _defaultLoadClickClass;
            this.loadClickEventType = 'click';
            this.loadClickStopPropagation = false;
            this.loadClickPreventDefault = false;
            this.disableAttribute = true;
        }
        /**
         * @return {?}
         */
        LoadClickDirective.prototype.ngOnInit = function () {
            var _this = this;
            this._renderer.listen(this._el.nativeElement, this.loadClickEventType, function (event) {
                /** @type {?} */
                var defaultClass = _this.loadClickClass || _this._defaultLoadClickClass;
                if (_this.loadClickStopPropagation) {
                    event.stopPropagation();
                }
                if (_this.loadClickPreventDefault) {
                    event.preventDefault();
                }
                _this._renderer.addClass(_this._el.nativeElement, defaultClass);
                if (_this.disableAttribute) {
                    _this._renderer.setAttribute(_this._el.nativeElement, 'disabled', '');
                }
                _this.subscription = _this.jpLoadClick()
                    .pipe(operators.finalize(function () {
                    _this._renderer.removeClass(_this._el.nativeElement, defaultClass);
                    if (_this.disableAttribute) {
                        _this._renderer.removeAttribute(_this._el.nativeElement, 'disabled');
                    }
                }))
                    .subscribe();
            });
        };
        /**
         * @return {?}
         */
        LoadClickDirective.prototype.ngOnDestroy = function () {
            if (this.subscription) {
                this.subscription.unsubscribe();
            }
        };
        return LoadClickDirective;
    }());
    LoadClickDirective.decorators = [
        { type: core.Directive, args: [{ selector: '[jpLoadClick]' },] }
    ];
    /** @nocollapse */
    LoadClickDirective.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 },
        { type: String, decorators: [{ type: core.Inject, args: [LOAD_CLICK_CLASS,] }] }
    ]; };
    LoadClickDirective.propDecorators = {
        jpLoadClick: [{ type: core.Input }],
        loadClickEventType: [{ type: core.Input }],
        loadClickStopPropagation: [{ type: core.Input }],
        loadClickPreventDefault: [{ type: core.Input }],
        loadClickClass: [{ type: core.Input }],
        disableAttribute: [{ type: core.Input }]
    };
    if (false) {
        /** @type {?} */
        LoadClickDirective.prototype.jpLoadClick;
        /** @type {?} */
        LoadClickDirective.prototype.loadClickEventType;
        /** @type {?} */
        LoadClickDirective.prototype.loadClickStopPropagation;
        /** @type {?} */
        LoadClickDirective.prototype.loadClickPreventDefault;
        /** @type {?} */
        LoadClickDirective.prototype.loadClickClass;
        /** @type {?} */
        LoadClickDirective.prototype.disableAttribute;
        /** @type {?} */
        LoadClickDirective.prototype.subscription;
        /**
         * @type {?}
         * @private
         */
        LoadClickDirective.prototype._el;
        /**
         * @type {?}
         * @private
         */
        LoadClickDirective.prototype._renderer;
        /**
         * @type {?}
         * @private
         */
        LoadClickDirective.prototype._defaultLoadClickClass;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var LoadClickModule = /** @class */ (function () {
        function LoadClickModule() {
        }
        /**
         * @param {?} value
         * @return {?}
         */
        LoadClickModule.defaultLoadingClass = function (value) {
            return {
                ngModule: LoadClickModule,
                providers: [
                    {
                        provide: LOAD_CLICK_CLASS,
                        useValue: value
                    }
                ]
            };
        };
        return LoadClickModule;
    }());
    LoadClickModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule
                    ],
                    declarations: [
                        LoadClickDirective
                    ],
                    exports: [
                        LoadClickDirective
                    ],
                    providers: [
                        {
                            provide: LOAD_CLICK_CLASS,
                            useValue: 'loading'
                        }
                    ]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Returns an array of {key: number, value: string} objects.
     * Most useful in *ngFor iterations
     *
     * \@example
     * <div *ngFor="let item of someEnum | enum></div>
     *
     */
    var EnumPipe = /** @class */ (function () {
        function EnumPipe() {
        }
        /**
         * @param {?} value
         * @return {?}
         */
        EnumPipe.prototype.transform = function (value) {
            /** @type {?} */
            var keys = [];
            for (var enumMember in value) {
                if (value[enumMember]) {
                    /** @type {?} */
                    var val = parseInt(enumMember, 10);
                    if (!isNaN(val)) {
                        keys.push({ key: val, value: value[enumMember] });
                    }
                }
            }
            return keys;
        };
        return EnumPipe;
    }());
    EnumPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'jpEnum'
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var EnumModule = /** @class */ (function () {
        function EnumModule() {
        }
        return EnumModule;
    }());
    EnumModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule
                    ],
                    declarations: [
                        EnumPipe
                    ],
                    exports: [
                        EnumPipe
                    ]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Applies the appropriate DomSanitizer method
     * to inputted value.
     *
     * \@example
     * <div [innerHtml]="someHtmlValue | sanitize"></div>
     */
    var SanitizePipe = /** @class */ (function () {
        /**
         * @param {?} _sanitizer
         */
        function SanitizePipe(_sanitizer) {
            this._sanitizer = _sanitizer;
        }
        /**
         * @param {?} value
         * @param {?=} type
         * @return {?}
         */
        SanitizePipe.prototype.transform = function (value, type) {
            if (type === void 0) { type = 'html'; }
            /** @type {?} */
            var sanitizeMap = {
                html: 'bypassSecurityTrustHtml',
                style: 'bypassSecurityTrustStyle',
                script: 'bypassSecurityTrustScript',
                url: 'bypassSecurityTrustUrl',
                resourceUrl: 'bypassSecurityTrustResourceUrl'
            };
            return this._sanitizer[sanitizeMap[type]](value);
        };
        return SanitizePipe;
    }());
    SanitizePipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'jpSanitize'
                },] }
    ];
    /** @nocollapse */
    SanitizePipe.ctorParameters = function () { return [
        { type: platformBrowser.DomSanitizer }
    ]; };
    if (false) {
        /**
         * @type {?}
         * @private
         */
        SanitizePipe.prototype._sanitizer;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SanitizeModule = /** @class */ (function () {
        function SanitizeModule() {
        }
        return SanitizeModule;
    }());
    SanitizeModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule
                    ],
                    declarations: [
                        SanitizePipe
                    ],
                    exports: [
                        SanitizePipe
                    ]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var TimePassedType = {
        Millisecond: 0,
        Second: 1,
        Minute: 2,
        Hour: 3,
        Day: 4,
        Month: 5,
        Year: 6,
    };
    TimePassedType[TimePassedType.Millisecond] = 'Millisecond';
    TimePassedType[TimePassedType.Second] = 'Second';
    TimePassedType[TimePassedType.Minute] = 'Minute';
    TimePassedType[TimePassedType.Hour] = 'Hour';
    TimePassedType[TimePassedType.Day] = 'Day';
    TimePassedType[TimePassedType.Month] = 'Month';
    TimePassedType[TimePassedType.Year] = 'Year';
    var TimePassedPipe = /** @class */ (function () {
        function TimePassedPipe() {
        }
        /**
         * @param {?} dateOne
         * @param {?=} dateTwo
         * @param {?=} type
         * @return {?}
         */
        TimePassedPipe.timeDiff = function (dateOne, dateTwo, type) {
            var _a;
            if (dateTwo === void 0) { dateTwo = new Date(); }
            if (type === void 0) { type = TimePassedType.Day; }
            /** @type {?} */
            var oneDay = 24 * 60 * 60 * 1000;
            /** @type {?} */
            var minute = 60 * 1000;
            /** @type {?} */
            var hour = 60 * minute;
            /** @type {?} */
            var day = hour * 24;
            /** @type {?} */
            var durationMap = (_a = {},
                _a[TimePassedType.Millisecond] = 1,
                _a[TimePassedType.Second] = 1000,
                _a[TimePassedType.Minute] = minute,
                _a[TimePassedType.Hour] = hour,
                _a[TimePassedType.Day] = day,
                _a[TimePassedType.Month] = day * 30,
                _a[TimePassedType.Year] = day * 365,
                _a);
            return Math.round(Math.abs((dateOne.getTime() - dateTwo.getTime()) / durationMap[type]));
        };
        /**
         * @param {?} dateOne
         * @param {?=} dateTwo
         * @param {?=} type
         * @return {?}
         */
        TimePassedPipe.prototype.transform = function (dateOne, dateTwo, type) {
            if (!dateTwo) {
                dateTwo = new Date();
            }
            return TimePassedPipe.timeDiff(dateOne, dateTwo, type !== undefined ? type : TimePassedType.Minute);
        };
        return TimePassedPipe;
    }());
    TimePassedPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'jpTimePassed'
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TimePassedModule = /** @class */ (function () {
        function TimePassedModule() {
        }
        return TimePassedModule;
    }());
    TimePassedModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [common.CommonModule],
                    declarations: [TimePassedPipe],
                    exports: [TimePassedPipe]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var EnumKeyFormatPipe = /** @class */ (function () {
        function EnumKeyFormatPipe() {
        }
        /**
         * @param {?} value
         * @return {?}
         */
        EnumKeyFormatPipe.defaultFormat = function (value) {
            return value
                .split(new RegExp('(?=[A-Z])'))
                .join(' ');
        };
        /**
         * @param {?} value
         * @param {?} enumValue
         * @param {?=} formatFunction
         * @return {?}
         */
        EnumKeyFormatPipe.prototype.transform = function (value, enumValue, formatFunction) {
            if (formatFunction === void 0) { formatFunction = EnumKeyFormatPipe.defaultFormat; }
            return enumValue[value] ?
                formatFunction(enumValue[value]) :
                value;
        };
        return EnumKeyFormatPipe;
    }());
    EnumKeyFormatPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'jpEnumKeyFormat'
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var EnumKeyFormatModule = /** @class */ (function () {
        function EnumKeyFormatModule() {
        }
        return EnumKeyFormatModule;
    }());
    EnumKeyFormatModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule
                    ],
                    declarations: [
                        EnumKeyFormatPipe
                    ],
                    exports: [
                        EnumKeyFormatPipe
                    ]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.ClickOutsideDirective = ClickOutsideDirective;
    exports.ClickOutsideModule = ClickOutsideModule;
    exports.DEBOUNCE_TIME = DEBOUNCE_TIME;
    exports.DebounceChangeDirective = DebounceChangeDirective;
    exports.DebounceChangeModule = DebounceChangeModule;
    exports.EnumKeyFormatModule = EnumKeyFormatModule;
    exports.EnumKeyFormatPipe = EnumKeyFormatPipe;
    exports.EnumModule = EnumModule;
    exports.EnumPipe = EnumPipe;
    exports.FormTouchOnHoverDirective = FormTouchOnHoverDirective;
    exports.FormTouchOnHoverModule = FormTouchOnHoverModule;
    exports.LOAD_CLICK_CLASS = LOAD_CLICK_CLASS;
    exports.LoadClickDirective = LoadClickDirective;
    exports.LoadClickModule = LoadClickModule;
    exports.OnChange = OnChange;
    exports.SanitizeModule = SanitizeModule;
    exports.SanitizePipe = SanitizePipe;
    exports.StopPropagationDirective = StopPropagationDirective;
    exports.StopPropagationModule = StopPropagationModule;
    exports.TimePassedModule = TimePassedModule;
    exports.TimePassedPipe = TimePassedPipe;
    exports.TimePassedType = TimePassedType;
    exports.TrackByFieldDirective = TrackByFieldDirective;
    exports.TrackByFieldModule = TrackByFieldModule;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=jaspero-ng-helpers.umd.js.map
