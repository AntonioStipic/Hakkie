import { CommonModule, NgForOf } from '@angular/common';
import { EventEmitter, Directive, ElementRef, NgZone, Input, Output, NgModule, Renderer2, HostListener, InjectionToken, Inject, Host, Pipe } from '@angular/core';
import { fromEvent } from 'rxjs';
import { filter, debounceTime, finalize } from 'rxjs/operators';
import { DomSanitizer } from '@angular/platform-browser';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Courtesy of
 * https://blog.angularindepth.com/creatively-decouple-ngonchanges-fab95395cc6e
 */
/**
 * @record
 * @template T
 */
function SimpleChange() { }
if (false) {
    /** @type {?} */
    SimpleChange.prototype.firstChange;
    /** @type {?} */
    SimpleChange.prototype.previousValue;
    /** @type {?} */
    SimpleChange.prototype.currentValue;
    /** @type {?} */
    SimpleChange.prototype.isFirstChange;
}
/**
 * @template T
 * @param {?} callback
 * @return {?}
 */
function OnChange(callback) {
    /** @type {?} */
    const cachedValueKey = Symbol();
    /** @type {?} */
    const isFirstChangeKey = Symbol();
    return (target, key) => {
        Object.defineProperty(target, key, {
            set: function (value) {
                /**
                 * Change status of "isFirstChange"
                 */
                this[isFirstChangeKey] = this[isFirstChangeKey] === undefined;
                /**
                 *  No operation if new value is same as old value
                 */
                if (!this[isFirstChangeKey] && this[cachedValueKey] === value) {
                    return;
                }
                /** @type {?} */
                const oldValue = this[cachedValueKey];
                this[cachedValueKey] = value;
                /** @type {?} */
                const simpleChange = {
                    firstChange: this[isFirstChangeKey],
                    previousValue: oldValue,
                    currentValue: this[cachedValueKey],
                    isFirstChange: () => this[isFirstChangeKey],
                };
                callback.call(this, this[cachedValueKey], simpleChange);
            },
            get: function () {
                return this[cachedValueKey];
            }
        });
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Emits an event when a click action occurs that does not target the element
 *
 * \@example
 * <div (jpClickOutside)="doSomething()"></div>
 */
class ClickOutsideDirective {
    /**
     * @param {?} _el
     * @param {?} _ngZone
     */
    constructor(_el, _ngZone) {
        this._el = _el;
        this._ngZone = _ngZone;
        /**
         * Any valid html event
         */
        this.clickOutsideEventType = 'click';
        /**
         * if true jpClickOutside doesn't emit
         */
        this.clickOutsideBlock = false;
        /**
         * Emits when triggered event doesn't contain this e
         */
        this.jpClickOutside = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._ngZone.runOutsideAngular(() => {
            this.subscription = fromEvent(window, this.clickOutsideEventType)
                .pipe(filter(event => !this.clickOutsideBlock &&
                !this._el.nativeElement.contains(event.target)))
                .subscribe(event => {
                this._ngZone.run(() => {
                    this.jpClickOutside.emit(event);
                });
            });
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
ClickOutsideDirective.decorators = [
    { type: Directive, args: [{
                selector: '[jpClickOutside]'
            },] }
];
/** @nocollapse */
ClickOutsideDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
ClickOutsideDirective.propDecorators = {
    clickOutsideEventType: [{ type: Input }],
    clickOutsideBlock: [{ type: Input }],
    jpClickOutside: [{ type: Output }]
};
if (false) {
    /**
     * Any valid html event
     * @type {?}
     */
    ClickOutsideDirective.prototype.clickOutsideEventType;
    /**
     * if true jpClickOutside doesn't emit
     * @type {?}
     */
    ClickOutsideDirective.prototype.clickOutsideBlock;
    /**
     * Emits when triggered event doesn't contain this e
     * @type {?}
     */
    ClickOutsideDirective.prototype.jpClickOutside;
    /** @type {?} */
    ClickOutsideDirective.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    ClickOutsideDirective.prototype._el;
    /**
     * @type {?}
     * @private
     */
    ClickOutsideDirective.prototype._ngZone;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ClickOutsideModule {
}
ClickOutsideModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    ClickOutsideDirective
                ],
                exports: [
                    ClickOutsideDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Used for preventing propagation on event calls event.stopPropagation())
 *
 * \@example
 * <div (jpStopPropagation)="doSomething()"></div>
 */
class StopPropagationDirective {
    /**
     * @param {?} _renderer
     * @param {?} _el
     */
    constructor(_renderer, _el) {
        this._renderer = _renderer;
        this._el = _el;
        /**
         * Any valid html event
         */
        this.stopPropagationEventType = 'click';
        /**
         * Should preventDefault also be called
         */
        this.preventDefault = false;
        /**
         * Outputs the input event
         */
        this.jpStopPropagation = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._renderer.listen(this._el.nativeElement, this.stopPropagationEventType, event => {
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.condition !== undefined) {
                if (typeof this.condition === 'boolean') {
                    if (this.condition) {
                        this.sp(event);
                    }
                }
                else if (this.condition(event)) {
                    this.sp(event);
                }
            }
            else {
                this.sp(event);
            }
        });
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    sp(event) {
        event.stopPropagation();
        this.jpStopPropagation.emit(event);
    }
}
StopPropagationDirective.decorators = [
    { type: Directive, args: [{
                selector: '[jpStopPropagation]'
            },] }
];
/** @nocollapse */
StopPropagationDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
StopPropagationDirective.propDecorators = {
    stopPropagationEventType: [{ type: Input }],
    preventDefault: [{ type: Input }],
    condition: [{ type: Input }],
    jpStopPropagation: [{ type: Output }]
};
if (false) {
    /**
     * Any valid html event
     * @type {?}
     */
    StopPropagationDirective.prototype.stopPropagationEventType;
    /**
     * Should preventDefault also be called
     * @type {?}
     */
    StopPropagationDirective.prototype.preventDefault;
    /** @type {?} */
    StopPropagationDirective.prototype.condition;
    /**
     * Outputs the input event
     * @type {?}
     */
    StopPropagationDirective.prototype.jpStopPropagation;
    /**
     * @type {?}
     * @private
     */
    StopPropagationDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    StopPropagationDirective.prototype._el;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StopPropagationModule {
}
StopPropagationModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    StopPropagationDirective
                ],
                exports: [
                    StopPropagationDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormTouchOnHoverDirective {
    constructor() {
        this.jpFormTouched = new EventEmitter();
    }
    /**
     * @return {?}
     */
    enter() {
        if (Array.isArray(this.jpFormTouchOnHover)) {
            this.jpFormTouchOnHover.forEach(form => form.markAllAsTouched());
        }
        else {
            this.jpFormTouchOnHover.markAllAsTouched();
        }
        this.jpFormTouched.emit();
    }
}
FormTouchOnHoverDirective.decorators = [
    { type: Directive, args: [{
                selector: '[jpFormTouchOnHover]'
            },] }
];
FormTouchOnHoverDirective.propDecorators = {
    jpFormTouchOnHover: [{ type: Input }],
    jpFormTouched: [{ type: Output }],
    enter: [{ type: HostListener, args: ['mouseenter',] }]
};
if (false) {
    /** @type {?} */
    FormTouchOnHoverDirective.prototype.jpFormTouchOnHover;
    /** @type {?} */
    FormTouchOnHoverDirective.prototype.jpFormTouched;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormTouchOnHoverModule {
}
FormTouchOnHoverModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    FormTouchOnHoverDirective
                ],
                exports: [
                    FormTouchOnHoverDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEBOUNCE_TIME = new InjectionToken('DEBOUNCE_TIME');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DebounceChangeDirective {
    /**
     * @param {?} _el
     * @param {?} _ngZone
     * @param {?} _defaultDebounceTime
     */
    constructor(_el, _ngZone, _defaultDebounceTime) {
        this._el = _el;
        this._ngZone = _ngZone;
        this._defaultDebounceTime = _defaultDebounceTime;
        /**
         * Any valid html event
         */
        this.debounceChangeEventType = 'keyup';
        /**
         * If true and the event has a 'target.value'
         * we listen for it and only emit if the value changed
         */
        this.emitOnlyOnChange = false;
        /**
         * Emits original event after debounce
         */
        this.jpDebounceChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._ngZone.runOutsideAngular(() => {
            /** @type {?} */
            let prev = this._el.nativeElement.value;
            this.subscription = fromEvent(this._el.nativeElement, this.debounceChangeEventType)
                .pipe(debounceTime(this.debounceTime || this._defaultDebounceTime), filter(event => {
                return event.target &&
                    event.target.value !== undefined &&
                    this.emitOnlyOnChange ?
                    event.target.value !== prev :
                    true;
            }))
                .subscribe(event => {
                this._ngZone.run(() => {
                    if (event.target) {
                        prev = event.target.value;
                    }
                    this.jpDebounceChange.emit(event.target.value);
                });
            });
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
DebounceChangeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[jpDebounceChange]'
            },] }
];
/** @nocollapse */
DebounceChangeDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: Number, decorators: [{ type: Inject, args: [DEBOUNCE_TIME,] }] }
];
DebounceChangeDirective.propDecorators = {
    debounceTime: [{ type: Input }],
    debounceChangeEventType: [{ type: Input }],
    emitOnlyOnChange: [{ type: Input }],
    jpDebounceChange: [{ type: Output }]
};
if (false) {
    /**
     * time to forward to the debounceTime pipe
     * @type {?}
     */
    DebounceChangeDirective.prototype.debounceTime;
    /**
     * Any valid html event
     * @type {?}
     */
    DebounceChangeDirective.prototype.debounceChangeEventType;
    /**
     * If true and the event has a 'target.value'
     * we listen for it and only emit if the value changed
     * @type {?}
     */
    DebounceChangeDirective.prototype.emitOnlyOnChange;
    /**
     * Emits original event after debounce
     * @type {?}
     */
    DebounceChangeDirective.prototype.jpDebounceChange;
    /** @type {?} */
    DebounceChangeDirective.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    DebounceChangeDirective.prototype._el;
    /**
     * @type {?}
     * @private
     */
    DebounceChangeDirective.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    DebounceChangeDirective.prototype._defaultDebounceTime;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DebounceChangeModule {
    /**
     * @param {?} value
     * @return {?}
     */
    static defaultDebounceTime(value) {
        return {
            ngModule: DebounceChangeModule,
            providers: [
                {
                    provide: DEBOUNCE_TIME,
                    useValue: value
                }
            ]
        };
    }
}
DebounceChangeModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    DebounceChangeDirective
                ],
                exports: [
                    DebounceChangeDirective
                ],
                providers: [
                    {
                        provide: DEBOUNCE_TIME,
                        useValue: 500
                    }
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class TrackByFieldDirective {
    /**
     * @param {?} ngFor
     * @param {?} defaultKey
     */
    constructor(ngFor, defaultKey) {
        this.ngFor = ngFor;
        this.defaultKey = defaultKey;
        this.ngFor.ngForTrackBy = (index, item) => item[this.ngForJpTrackByField || this.defaultKey];
    }
}
TrackByFieldDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line
                selector: '[ngForJpTrackByField]',
            },] }
];
/** @nocollapse */
TrackByFieldDirective.ctorParameters = () => [
    { type: NgForOf, decorators: [{ type: Host }] },
    { type: undefined, decorators: [{ type: Inject, args: ['defaultKey',] }] }
];
TrackByFieldDirective.propDecorators = {
    ngForJpTrackByField: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    TrackByFieldDirective.prototype.ngForJpTrackByField;
    /**
     * @type {?}
     * @private
     */
    TrackByFieldDirective.prototype.ngFor;
    /**
     * @type {?}
     * @private
     */
    TrackByFieldDirective.prototype.defaultKey;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TrackByFieldModule {
    /**
     * @param {?=} value
     * @return {?}
     */
    static defaultKey(value = 'id') {
        return {
            ngModule: TrackByFieldModule,
            providers: [
                {
                    provide: 'defaultKey',
                    useValue: value
                }
            ]
        };
    }
}
TrackByFieldModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    TrackByFieldDirective
                ],
                exports: [
                    TrackByFieldDirective
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_CLICK_CLASS = new InjectionToken('LOAD_CLICK_CLASS');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive will add loading class to the host element on click event
 * Usage: [jpLoadClick]="save()"
 * Function save() should return observable
 */
class LoadClickDirective {
    /**
     * @param {?} _el
     * @param {?} _renderer
     * @param {?} _defaultLoadClickClass
     */
    constructor(_el, _renderer, _defaultLoadClickClass) {
        this._el = _el;
        this._renderer = _renderer;
        this._defaultLoadClickClass = _defaultLoadClickClass;
        this.loadClickEventType = 'click';
        this.loadClickStopPropagation = false;
        this.loadClickPreventDefault = false;
        this.disableAttribute = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._renderer.listen(this._el.nativeElement, this.loadClickEventType, event => {
            /** @type {?} */
            const defaultClass = this.loadClickClass || this._defaultLoadClickClass;
            if (this.loadClickStopPropagation) {
                event.stopPropagation();
            }
            if (this.loadClickPreventDefault) {
                event.preventDefault();
            }
            this._renderer.addClass(this._el.nativeElement, defaultClass);
            if (this.disableAttribute) {
                this._renderer.setAttribute(this._el.nativeElement, 'disabled', '');
            }
            this.subscription = this.jpLoadClick()
                .pipe(finalize(() => {
                this._renderer.removeClass(this._el.nativeElement, defaultClass);
                if (this.disableAttribute) {
                    this._renderer.removeAttribute(this._el.nativeElement, 'disabled');
                }
            }))
                .subscribe();
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
LoadClickDirective.decorators = [
    { type: Directive, args: [{ selector: '[jpLoadClick]' },] }
];
/** @nocollapse */
LoadClickDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: String, decorators: [{ type: Inject, args: [LOAD_CLICK_CLASS,] }] }
];
LoadClickDirective.propDecorators = {
    jpLoadClick: [{ type: Input }],
    loadClickEventType: [{ type: Input }],
    loadClickStopPropagation: [{ type: Input }],
    loadClickPreventDefault: [{ type: Input }],
    loadClickClass: [{ type: Input }],
    disableAttribute: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    LoadClickDirective.prototype.jpLoadClick;
    /** @type {?} */
    LoadClickDirective.prototype.loadClickEventType;
    /** @type {?} */
    LoadClickDirective.prototype.loadClickStopPropagation;
    /** @type {?} */
    LoadClickDirective.prototype.loadClickPreventDefault;
    /** @type {?} */
    LoadClickDirective.prototype.loadClickClass;
    /** @type {?} */
    LoadClickDirective.prototype.disableAttribute;
    /** @type {?} */
    LoadClickDirective.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    LoadClickDirective.prototype._el;
    /**
     * @type {?}
     * @private
     */
    LoadClickDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    LoadClickDirective.prototype._defaultLoadClickClass;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LoadClickModule {
    /**
     * @param {?} value
     * @return {?}
     */
    static defaultLoadingClass(value) {
        return {
            ngModule: LoadClickModule,
            providers: [
                {
                    provide: LOAD_CLICK_CLASS,
                    useValue: value
                }
            ]
        };
    }
}
LoadClickModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    LoadClickDirective
                ],
                exports: [
                    LoadClickDirective
                ],
                providers: [
                    {
                        provide: LOAD_CLICK_CLASS,
                        useValue: 'loading'
                    }
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns an array of {key: number, value: string} objects.
 * Most useful in *ngFor iterations
 *
 * \@example
 * <div *ngFor="let item of someEnum | enum></div>
 *
 */
class EnumPipe {
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        /** @type {?} */
        const keys = [];
        for (const enumMember in value) {
            if (value[enumMember]) {
                /** @type {?} */
                const val = parseInt(enumMember, 10);
                if (!isNaN(val)) {
                    keys.push({ key: val, value: value[enumMember] });
                }
            }
        }
        return keys;
    }
}
EnumPipe.decorators = [
    { type: Pipe, args: [{
                name: 'jpEnum'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EnumModule {
}
EnumModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    EnumPipe
                ],
                exports: [
                    EnumPipe
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Applies the appropriate DomSanitizer method
 * to inputted value.
 *
 * \@example
 * <div [innerHtml]="someHtmlValue | sanitize"></div>
 */
class SanitizePipe {
    /**
     * @param {?} _sanitizer
     */
    constructor(_sanitizer) {
        this._sanitizer = _sanitizer;
    }
    /**
     * @param {?} value
     * @param {?=} type
     * @return {?}
     */
    transform(value, type = 'html') {
        /** @type {?} */
        const sanitizeMap = {
            html: 'bypassSecurityTrustHtml',
            style: 'bypassSecurityTrustStyle',
            script: 'bypassSecurityTrustScript',
            url: 'bypassSecurityTrustUrl',
            resourceUrl: 'bypassSecurityTrustResourceUrl'
        };
        return this._sanitizer[sanitizeMap[type]](value);
    }
}
SanitizePipe.decorators = [
    { type: Pipe, args: [{
                name: 'jpSanitize'
            },] }
];
/** @nocollapse */
SanitizePipe.ctorParameters = () => [
    { type: DomSanitizer }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    SanitizePipe.prototype._sanitizer;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SanitizeModule {
}
SanitizeModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    SanitizePipe
                ],
                exports: [
                    SanitizePipe
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const TimePassedType = {
    Millisecond: 0,
    Second: 1,
    Minute: 2,
    Hour: 3,
    Day: 4,
    Month: 5,
    Year: 6,
};
TimePassedType[TimePassedType.Millisecond] = 'Millisecond';
TimePassedType[TimePassedType.Second] = 'Second';
TimePassedType[TimePassedType.Minute] = 'Minute';
TimePassedType[TimePassedType.Hour] = 'Hour';
TimePassedType[TimePassedType.Day] = 'Day';
TimePassedType[TimePassedType.Month] = 'Month';
TimePassedType[TimePassedType.Year] = 'Year';
class TimePassedPipe {
    /**
     * @param {?} dateOne
     * @param {?=} dateTwo
     * @param {?=} type
     * @return {?}
     */
    static timeDiff(dateOne, dateTwo = new Date(), type = TimePassedType.Day) {
        /** @type {?} */
        const oneDay = 24 * 60 * 60 * 1000;
        /** @type {?} */
        const minute = 60 * 1000;
        /** @type {?} */
        const hour = 60 * minute;
        /** @type {?} */
        const day = hour * 24;
        /** @type {?} */
        const durationMap = {
            [TimePassedType.Millisecond]: 1,
            [TimePassedType.Second]: 1000,
            [TimePassedType.Minute]: minute,
            [TimePassedType.Hour]: hour,
            [TimePassedType.Day]: day,
            [TimePassedType.Month]: day * 30,
            [TimePassedType.Year]: day * 365
        };
        return Math.round(Math.abs((dateOne.getTime() - dateTwo.getTime()) / durationMap[type]));
    }
    /**
     * @param {?} dateOne
     * @param {?=} dateTwo
     * @param {?=} type
     * @return {?}
     */
    transform(dateOne, dateTwo, type) {
        if (!dateTwo) {
            dateTwo = new Date();
        }
        return TimePassedPipe.timeDiff(dateOne, dateTwo, type !== undefined ? type : TimePassedType.Minute);
    }
}
TimePassedPipe.decorators = [
    { type: Pipe, args: [{
                name: 'jpTimePassed'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TimePassedModule {
}
TimePassedModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [TimePassedPipe],
                exports: [TimePassedPipe]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EnumKeyFormatPipe {
    /**
     * @param {?} value
     * @return {?}
     */
    static defaultFormat(value) {
        return value
            .split(new RegExp('(?=[A-Z])'))
            .join(' ');
    }
    /**
     * @param {?} value
     * @param {?} enumValue
     * @param {?=} formatFunction
     * @return {?}
     */
    transform(value, enumValue, formatFunction = EnumKeyFormatPipe.defaultFormat) {
        return enumValue[value] ?
            formatFunction(enumValue[value]) :
            value;
    }
}
EnumKeyFormatPipe.decorators = [
    { type: Pipe, args: [{
                name: 'jpEnumKeyFormat'
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EnumKeyFormatModule {
}
EnumKeyFormatModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    EnumKeyFormatPipe
                ],
                exports: [
                    EnumKeyFormatPipe
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ClickOutsideDirective, ClickOutsideModule, DEBOUNCE_TIME, DebounceChangeDirective, DebounceChangeModule, EnumKeyFormatModule, EnumKeyFormatPipe, EnumModule, EnumPipe, FormTouchOnHoverDirective, FormTouchOnHoverModule, LOAD_CLICK_CLASS, LoadClickDirective, LoadClickModule, OnChange, SanitizeModule, SanitizePipe, StopPropagationDirective, StopPropagationModule, TimePassedModule, TimePassedPipe, TimePassedType, TrackByFieldDirective, TrackByFieldModule };
//# sourceMappingURL=jaspero-ng-helpers.js.map
