import { CommonModule, NgForOf } from '@angular/common';
import { EventEmitter, Directive, ElementRef, NgZone, Input, Output, NgModule, Renderer2, HostListener, InjectionToken, Inject, Host, Pipe } from '@angular/core';
import { fromEvent } from 'rxjs';
import { filter, debounceTime, finalize } from 'rxjs/operators';
import { DomSanitizer } from '@angular/platform-browser';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Courtesy of
 * https://blog.angularindepth.com/creatively-decouple-ngonchanges-fab95395cc6e
 */
/**
 * @record
 * @template T
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/platform-browser';
function SimpleChange() { }
if (false) {
    /** @type {?} */
    SimpleChange.prototype.firstChange;
    /** @type {?} */
    SimpleChange.prototype.previousValue;
    /** @type {?} */
    SimpleChange.prototype.currentValue;
    /** @type {?} */
    SimpleChange.prototype.isFirstChange;
}
/**
 * @template T
 * @param {?} callback
 * @return {?}
 */
function OnChange(callback) {
    /** @type {?} */
    const cachedValueKey = Symbol();
    /** @type {?} */
    const isFirstChangeKey = Symbol();
    return (target, key) => {
        Object.defineProperty(target, key, {
            set: function (value) {
                /**
                 * Change status of "isFirstChange"
                 */
                this[isFirstChangeKey] = this[isFirstChangeKey] === undefined;
                /**
                 *  No operation if new value is same as old value
                 */
                if (!this[isFirstChangeKey] && this[cachedValueKey] === value) {
                    return;
                }
                /** @type {?} */
                const oldValue = this[cachedValueKey];
                this[cachedValueKey] = value;
                /** @type {?} */
                const simpleChange = {
                    firstChange: this[isFirstChangeKey],
                    previousValue: oldValue,
                    currentValue: this[cachedValueKey],
                    isFirstChange: () => this[isFirstChangeKey],
                };
                callback.call(this, this[cachedValueKey], simpleChange);
            },
            get: function () {
                return this[cachedValueKey];
            }
        });
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Emits an event when a click action occurs that does not target the element
 *
 * \@example
 * <div (jpClickOutside)="doSomething()"></div>
 */
class ClickOutsideDirective {
    /**
     * @param {?} _el
     * @param {?} _ngZone
     */
    constructor(_el, _ngZone) {
        this._el = _el;
        this._ngZone = _ngZone;
        /**
         * Any valid html event
         */
        this.clickOutsideEventType = 'click';
        /**
         * if true jpClickOutside doesn't emit
         */
        this.clickOutsideBlock = false;
        /**
         * Emits when triggered event doesn't contain this e
         */
        this.jpClickOutside = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._ngZone.runOutsideAngular(() => {
            this.subscription = fromEvent(window, this.clickOutsideEventType)
                .pipe(filter(event => !this.clickOutsideBlock &&
                !this._el.nativeElement.contains(event.target)))
                .subscribe(event => {
                this._ngZone.run(() => {
                    this.jpClickOutside.emit(event);
                });
            });
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
ClickOutsideDirective.ɵfac = function ClickOutsideDirective_Factory(t) { return new (t || ClickOutsideDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
ClickOutsideDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClickOutsideDirective, selectors: [["", "jpClickOutside", ""]], inputs: { clickOutsideEventType: "clickOutsideEventType", clickOutsideBlock: "clickOutsideBlock" }, outputs: { jpClickOutside: "jpClickOutside" } });
/** @nocollapse */
ClickOutsideDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
ClickOutsideDirective.propDecorators = {
    clickOutsideEventType: [{ type: Input }],
    clickOutsideBlock: [{ type: Input }],
    jpClickOutside: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClickOutsideDirective, [{
        type: Directive,
        args: [{
                selector: '[jpClickOutside]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }]; }, { clickOutsideEventType: [{
            type: Input
        }], clickOutsideBlock: [{
            type: Input
        }], jpClickOutside: [{
            type: Output
        }] }); })();
if (false) {
    /**
     * Any valid html event
     * @type {?}
     */
    ClickOutsideDirective.prototype.clickOutsideEventType;
    /**
     * if true jpClickOutside doesn't emit
     * @type {?}
     */
    ClickOutsideDirective.prototype.clickOutsideBlock;
    /**
     * Emits when triggered event doesn't contain this e
     * @type {?}
     */
    ClickOutsideDirective.prototype.jpClickOutside;
    /** @type {?} */
    ClickOutsideDirective.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    ClickOutsideDirective.prototype._el;
    /**
     * @type {?}
     * @private
     */
    ClickOutsideDirective.prototype._ngZone;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ClickOutsideModule {
}
ClickOutsideModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ClickOutsideModule });
ClickOutsideModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ClickOutsideModule_Factory(t) { return new (t || ClickOutsideModule)(); }, imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ClickOutsideModule, { declarations: function () { return [ClickOutsideDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [ClickOutsideDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ClickOutsideModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    ClickOutsideDirective
                ],
                exports: [
                    ClickOutsideDirective
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Used for preventing propagation on event calls event.stopPropagation())
 *
 * \@example
 * <div (jpStopPropagation)="doSomething()"></div>
 */
class StopPropagationDirective {
    /**
     * @param {?} _renderer
     * @param {?} _el
     */
    constructor(_renderer, _el) {
        this._renderer = _renderer;
        this._el = _el;
        /**
         * Any valid html event
         */
        this.stopPropagationEventType = 'click';
        /**
         * Should preventDefault also be called
         */
        this.preventDefault = false;
        /**
         * Outputs the input event
         */
        this.jpStopPropagation = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._renderer.listen(this._el.nativeElement, this.stopPropagationEventType, event => {
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.condition !== undefined) {
                if (typeof this.condition === 'boolean') {
                    if (this.condition) {
                        this.sp(event);
                    }
                }
                else if (this.condition(event)) {
                    this.sp(event);
                }
            }
            else {
                this.sp(event);
            }
        });
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    sp(event) {
        event.stopPropagation();
        this.jpStopPropagation.emit(event);
    }
}
StopPropagationDirective.ɵfac = function StopPropagationDirective_Factory(t) { return new (t || StopPropagationDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
StopPropagationDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: StopPropagationDirective, selectors: [["", "jpStopPropagation", ""]], inputs: { stopPropagationEventType: "stopPropagationEventType", preventDefault: "preventDefault", condition: "condition" }, outputs: { jpStopPropagation: "jpStopPropagation" } });
/** @nocollapse */
StopPropagationDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
StopPropagationDirective.propDecorators = {
    stopPropagationEventType: [{ type: Input }],
    preventDefault: [{ type: Input }],
    condition: [{ type: Input }],
    jpStopPropagation: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StopPropagationDirective, [{
        type: Directive,
        args: [{
                selector: '[jpStopPropagation]'
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { stopPropagationEventType: [{
            type: Input
        }], preventDefault: [{
            type: Input
        }], jpStopPropagation: [{
            type: Output
        }], condition: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * Any valid html event
     * @type {?}
     */
    StopPropagationDirective.prototype.stopPropagationEventType;
    /**
     * Should preventDefault also be called
     * @type {?}
     */
    StopPropagationDirective.prototype.preventDefault;
    /** @type {?} */
    StopPropagationDirective.prototype.condition;
    /**
     * Outputs the input event
     * @type {?}
     */
    StopPropagationDirective.prototype.jpStopPropagation;
    /**
     * @type {?}
     * @private
     */
    StopPropagationDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    StopPropagationDirective.prototype._el;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StopPropagationModule {
}
StopPropagationModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: StopPropagationModule });
StopPropagationModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function StopPropagationModule_Factory(t) { return new (t || StopPropagationModule)(); }, imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(StopPropagationModule, { declarations: function () { return [StopPropagationDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [StopPropagationDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StopPropagationModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    StopPropagationDirective
                ],
                exports: [
                    StopPropagationDirective
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormTouchOnHoverDirective {
    constructor() {
        this.jpFormTouched = new EventEmitter();
    }
    /**
     * @return {?}
     */
    enter() {
        if (Array.isArray(this.jpFormTouchOnHover)) {
            this.jpFormTouchOnHover.forEach(form => form.markAllAsTouched());
        }
        else {
            this.jpFormTouchOnHover.markAllAsTouched();
        }
        this.jpFormTouched.emit();
    }
}
FormTouchOnHoverDirective.ɵfac = function FormTouchOnHoverDirective_Factory(t) { return new (t || FormTouchOnHoverDirective)(); };
FormTouchOnHoverDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FormTouchOnHoverDirective, selectors: [["", "jpFormTouchOnHover", ""]], hostBindings: function FormTouchOnHoverDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("mouseenter", function FormTouchOnHoverDirective_mouseenter_HostBindingHandler() { return ctx.enter(); });
    } }, inputs: { jpFormTouchOnHover: "jpFormTouchOnHover" }, outputs: { jpFormTouched: "jpFormTouched" } });
FormTouchOnHoverDirective.propDecorators = {
    jpFormTouchOnHover: [{ type: Input }],
    jpFormTouched: [{ type: Output }],
    enter: [{ type: HostListener, args: ['mouseenter',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FormTouchOnHoverDirective, [{
        type: Directive,
        args: [{
                selector: '[jpFormTouchOnHover]'
            }]
    }], function () { return []; }, { jpFormTouched: [{
            type: Output
        }], enter: [{
            type: HostListener,
            args: ['mouseenter']
        }], jpFormTouchOnHover: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    FormTouchOnHoverDirective.prototype.jpFormTouchOnHover;
    /** @type {?} */
    FormTouchOnHoverDirective.prototype.jpFormTouched;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FormTouchOnHoverModule {
}
FormTouchOnHoverModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: FormTouchOnHoverModule });
FormTouchOnHoverModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function FormTouchOnHoverModule_Factory(t) { return new (t || FormTouchOnHoverModule)(); }, imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(FormTouchOnHoverModule, { declarations: function () { return [FormTouchOnHoverDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [FormTouchOnHoverDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FormTouchOnHoverModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    FormTouchOnHoverDirective
                ],
                exports: [
                    FormTouchOnHoverDirective
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DEBOUNCE_TIME = new InjectionToken('DEBOUNCE_TIME');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DebounceChangeDirective {
    /**
     * @param {?} _el
     * @param {?} _ngZone
     * @param {?} _defaultDebounceTime
     */
    constructor(_el, _ngZone, _defaultDebounceTime) {
        this._el = _el;
        this._ngZone = _ngZone;
        this._defaultDebounceTime = _defaultDebounceTime;
        /**
         * Any valid html event
         */
        this.debounceChangeEventType = 'keyup';
        /**
         * If true and the event has a 'target.value'
         * we listen for it and only emit if the value changed
         */
        this.emitOnlyOnChange = false;
        /**
         * Emits original event after debounce
         */
        this.jpDebounceChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._ngZone.runOutsideAngular(() => {
            /** @type {?} */
            let prev = this._el.nativeElement.value;
            this.subscription = fromEvent(this._el.nativeElement, this.debounceChangeEventType)
                .pipe(debounceTime(this.debounceTime || this._defaultDebounceTime), filter(event => {
                return event.target &&
                    event.target.value !== undefined &&
                    this.emitOnlyOnChange ?
                    event.target.value !== prev :
                    true;
            }))
                .subscribe(event => {
                this._ngZone.run(() => {
                    if (event.target) {
                        prev = event.target.value;
                    }
                    this.jpDebounceChange.emit(event.target.value);
                });
            });
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
DebounceChangeDirective.ɵfac = function DebounceChangeDirective_Factory(t) { return new (t || DebounceChangeDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(DEBOUNCE_TIME)); };
DebounceChangeDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DebounceChangeDirective, selectors: [["", "jpDebounceChange", ""]], inputs: { debounceChangeEventType: "debounceChangeEventType", emitOnlyOnChange: "emitOnlyOnChange", debounceTime: "debounceTime" }, outputs: { jpDebounceChange: "jpDebounceChange" } });
/** @nocollapse */
DebounceChangeDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: Number, decorators: [{ type: Inject, args: [DEBOUNCE_TIME,] }] }
];
DebounceChangeDirective.propDecorators = {
    debounceTime: [{ type: Input }],
    debounceChangeEventType: [{ type: Input }],
    emitOnlyOnChange: [{ type: Input }],
    jpDebounceChange: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DebounceChangeDirective, [{
        type: Directive,
        args: [{
                selector: '[jpDebounceChange]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: Number, decorators: [{
                type: Inject,
                args: [DEBOUNCE_TIME]
            }] }]; }, { debounceChangeEventType: [{
            type: Input
        }], emitOnlyOnChange: [{
            type: Input
        }], jpDebounceChange: [{
            type: Output
        }], debounceTime: [{
            type: Input
        }] }); })();
if (false) {
    /**
     * time to forward to the debounceTime pipe
     * @type {?}
     */
    DebounceChangeDirective.prototype.debounceTime;
    /**
     * Any valid html event
     * @type {?}
     */
    DebounceChangeDirective.prototype.debounceChangeEventType;
    /**
     * If true and the event has a 'target.value'
     * we listen for it and only emit if the value changed
     * @type {?}
     */
    DebounceChangeDirective.prototype.emitOnlyOnChange;
    /**
     * Emits original event after debounce
     * @type {?}
     */
    DebounceChangeDirective.prototype.jpDebounceChange;
    /** @type {?} */
    DebounceChangeDirective.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    DebounceChangeDirective.prototype._el;
    /**
     * @type {?}
     * @private
     */
    DebounceChangeDirective.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    DebounceChangeDirective.prototype._defaultDebounceTime;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DebounceChangeModule {
    /**
     * @param {?} value
     * @return {?}
     */
    static defaultDebounceTime(value) {
        return {
            ngModule: DebounceChangeModule,
            providers: [
                {
                    provide: DEBOUNCE_TIME,
                    useValue: value
                }
            ]
        };
    }
}
DebounceChangeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: DebounceChangeModule });
DebounceChangeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function DebounceChangeModule_Factory(t) { return new (t || DebounceChangeModule)(); }, providers: [
        {
            provide: DEBOUNCE_TIME,
            useValue: 500
        }
    ], imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(DebounceChangeModule, { declarations: function () { return [DebounceChangeDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [DebounceChangeDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DebounceChangeModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    DebounceChangeDirective
                ],
                exports: [
                    DebounceChangeDirective
                ],
                providers: [
                    {
                        provide: DEBOUNCE_TIME,
                        useValue: 500
                    }
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
class TrackByFieldDirective {
    /**
     * @param {?} ngFor
     * @param {?} defaultKey
     */
    constructor(ngFor, defaultKey) {
        this.ngFor = ngFor;
        this.defaultKey = defaultKey;
        this.ngFor.ngForTrackBy = (index, item) => item[this.ngForJpTrackByField || this.defaultKey];
    }
}
TrackByFieldDirective.ɵfac = function TrackByFieldDirective_Factory(t) { return new (t || TrackByFieldDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgForOf, 1), ɵngcc0.ɵɵdirectiveInject('defaultKey')); };
TrackByFieldDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TrackByFieldDirective, selectors: [["", "ngForJpTrackByField", ""]], inputs: { ngForJpTrackByField: "ngForJpTrackByField" } });
/** @nocollapse */
TrackByFieldDirective.ctorParameters = () => [
    { type: NgForOf, decorators: [{ type: Host }] },
    { type: undefined, decorators: [{ type: Inject, args: ['defaultKey',] }] }
];
TrackByFieldDirective.propDecorators = {
    ngForJpTrackByField: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TrackByFieldDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line
                selector: '[ngForJpTrackByField]'
            }]
    }], function () { return [{ type: ɵngcc1.NgForOf, decorators: [{
                type: Host
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: ['defaultKey']
            }] }]; }, { ngForJpTrackByField: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    TrackByFieldDirective.prototype.ngForJpTrackByField;
    /**
     * @type {?}
     * @private
     */
    TrackByFieldDirective.prototype.ngFor;
    /**
     * @type {?}
     * @private
     */
    TrackByFieldDirective.prototype.defaultKey;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TrackByFieldModule {
    /**
     * @param {?=} value
     * @return {?}
     */
    static defaultKey(value = 'id') {
        return {
            ngModule: TrackByFieldModule,
            providers: [
                {
                    provide: 'defaultKey',
                    useValue: value
                }
            ]
        };
    }
}
TrackByFieldModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TrackByFieldModule });
TrackByFieldModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TrackByFieldModule_Factory(t) { return new (t || TrackByFieldModule)(); }, imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TrackByFieldModule, { declarations: function () { return [TrackByFieldDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [TrackByFieldDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TrackByFieldModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    TrackByFieldDirective
                ],
                exports: [
                    TrackByFieldDirective
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOAD_CLICK_CLASS = new InjectionToken('LOAD_CLICK_CLASS');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive will add loading class to the host element on click event
 * Usage: [jpLoadClick]="save()"
 * Function save() should return observable
 */
class LoadClickDirective {
    /**
     * @param {?} _el
     * @param {?} _renderer
     * @param {?} _defaultLoadClickClass
     */
    constructor(_el, _renderer, _defaultLoadClickClass) {
        this._el = _el;
        this._renderer = _renderer;
        this._defaultLoadClickClass = _defaultLoadClickClass;
        this.loadClickEventType = 'click';
        this.loadClickStopPropagation = false;
        this.loadClickPreventDefault = false;
        this.disableAttribute = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._renderer.listen(this._el.nativeElement, this.loadClickEventType, event => {
            /** @type {?} */
            const defaultClass = this.loadClickClass || this._defaultLoadClickClass;
            if (this.loadClickStopPropagation) {
                event.stopPropagation();
            }
            if (this.loadClickPreventDefault) {
                event.preventDefault();
            }
            this._renderer.addClass(this._el.nativeElement, defaultClass);
            if (this.disableAttribute) {
                this._renderer.setAttribute(this._el.nativeElement, 'disabled', '');
            }
            this.subscription = this.jpLoadClick()
                .pipe(finalize(() => {
                this._renderer.removeClass(this._el.nativeElement, defaultClass);
                if (this.disableAttribute) {
                    this._renderer.removeAttribute(this._el.nativeElement, 'disabled');
                }
            }))
                .subscribe();
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
}
LoadClickDirective.ɵfac = function LoadClickDirective_Factory(t) { return new (t || LoadClickDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(LOAD_CLICK_CLASS)); };
LoadClickDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LoadClickDirective, selectors: [["", "jpLoadClick", ""]], inputs: { loadClickEventType: "loadClickEventType", loadClickStopPropagation: "loadClickStopPropagation", loadClickPreventDefault: "loadClickPreventDefault", disableAttribute: "disableAttribute", jpLoadClick: "jpLoadClick", loadClickClass: "loadClickClass" } });
/** @nocollapse */
LoadClickDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: String, decorators: [{ type: Inject, args: [LOAD_CLICK_CLASS,] }] }
];
LoadClickDirective.propDecorators = {
    jpLoadClick: [{ type: Input }],
    loadClickEventType: [{ type: Input }],
    loadClickStopPropagation: [{ type: Input }],
    loadClickPreventDefault: [{ type: Input }],
    loadClickClass: [{ type: Input }],
    disableAttribute: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LoadClickDirective, [{
        type: Directive,
        args: [{ selector: '[jpLoadClick]' }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: String, decorators: [{
                type: Inject,
                args: [LOAD_CLICK_CLASS]
            }] }]; }, { loadClickEventType: [{
            type: Input
        }], loadClickStopPropagation: [{
            type: Input
        }], loadClickPreventDefault: [{
            type: Input
        }], disableAttribute: [{
            type: Input
        }], jpLoadClick: [{
            type: Input
        }], loadClickClass: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    LoadClickDirective.prototype.jpLoadClick;
    /** @type {?} */
    LoadClickDirective.prototype.loadClickEventType;
    /** @type {?} */
    LoadClickDirective.prototype.loadClickStopPropagation;
    /** @type {?} */
    LoadClickDirective.prototype.loadClickPreventDefault;
    /** @type {?} */
    LoadClickDirective.prototype.loadClickClass;
    /** @type {?} */
    LoadClickDirective.prototype.disableAttribute;
    /** @type {?} */
    LoadClickDirective.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    LoadClickDirective.prototype._el;
    /**
     * @type {?}
     * @private
     */
    LoadClickDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    LoadClickDirective.prototype._defaultLoadClickClass;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LoadClickModule {
    /**
     * @param {?} value
     * @return {?}
     */
    static defaultLoadingClass(value) {
        return {
            ngModule: LoadClickModule,
            providers: [
                {
                    provide: LOAD_CLICK_CLASS,
                    useValue: value
                }
            ]
        };
    }
}
LoadClickModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LoadClickModule });
LoadClickModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function LoadClickModule_Factory(t) { return new (t || LoadClickModule)(); }, providers: [
        {
            provide: LOAD_CLICK_CLASS,
            useValue: 'loading'
        }
    ], imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LoadClickModule, { declarations: function () { return [LoadClickDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [LoadClickDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LoadClickModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    LoadClickDirective
                ],
                exports: [
                    LoadClickDirective
                ],
                providers: [
                    {
                        provide: LOAD_CLICK_CLASS,
                        useValue: 'loading'
                    }
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns an array of {key: number, value: string} objects.
 * Most useful in *ngFor iterations
 *
 * \@example
 * <div *ngFor="let item of someEnum | enum></div>
 *
 */
class EnumPipe {
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        /** @type {?} */
        const keys = [];
        for (const enumMember in value) {
            if (value[enumMember]) {
                /** @type {?} */
                const val = parseInt(enumMember, 10);
                if (!isNaN(val)) {
                    keys.push({ key: val, value: value[enumMember] });
                }
            }
        }
        return keys;
    }
}
EnumPipe.ɵfac = function EnumPipe_Factory(t) { return new (t || EnumPipe)(); };
EnumPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "jpEnum", type: EnumPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EnumPipe, [{
        type: Pipe,
        args: [{
                name: 'jpEnum'
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EnumModule {
}
EnumModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: EnumModule });
EnumModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function EnumModule_Factory(t) { return new (t || EnumModule)(); }, imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(EnumModule, { declarations: function () { return [EnumPipe]; }, imports: function () { return [CommonModule]; }, exports: function () { return [EnumPipe]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EnumModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    EnumPipe
                ],
                exports: [
                    EnumPipe
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Applies the appropriate DomSanitizer method
 * to inputted value.
 *
 * \@example
 * <div [innerHtml]="someHtmlValue | sanitize"></div>
 */
class SanitizePipe {
    /**
     * @param {?} _sanitizer
     */
    constructor(_sanitizer) {
        this._sanitizer = _sanitizer;
    }
    /**
     * @param {?} value
     * @param {?=} type
     * @return {?}
     */
    transform(value, type = 'html') {
        /** @type {?} */
        const sanitizeMap = {
            html: 'bypassSecurityTrustHtml',
            style: 'bypassSecurityTrustStyle',
            script: 'bypassSecurityTrustScript',
            url: 'bypassSecurityTrustUrl',
            resourceUrl: 'bypassSecurityTrustResourceUrl'
        };
        return this._sanitizer[sanitizeMap[type]](value);
    }
}
SanitizePipe.ɵfac = function SanitizePipe_Factory(t) { return new (t || SanitizePipe)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.DomSanitizer)); };
SanitizePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "jpSanitize", type: SanitizePipe, pure: true });
/** @nocollapse */
SanitizePipe.ctorParameters = () => [
    { type: DomSanitizer }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SanitizePipe, [{
        type: Pipe,
        args: [{
                name: 'jpSanitize'
            }]
    }], function () { return [{ type: ɵngcc2.DomSanitizer }]; }, null); })();
if (false) {
    /**
     * @type {?}
     * @private
     */
    SanitizePipe.prototype._sanitizer;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SanitizeModule {
}
SanitizeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SanitizeModule });
SanitizeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function SanitizeModule_Factory(t) { return new (t || SanitizeModule)(); }, imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SanitizeModule, { declarations: function () { return [SanitizePipe]; }, imports: function () { return [CommonModule]; }, exports: function () { return [SanitizePipe]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SanitizeModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    SanitizePipe
                ],
                exports: [
                    SanitizePipe
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const TimePassedType = {
    Millisecond: 0,
    Second: 1,
    Minute: 2,
    Hour: 3,
    Day: 4,
    Month: 5,
    Year: 6,
};
TimePassedType[TimePassedType.Millisecond] = 'Millisecond';
TimePassedType[TimePassedType.Second] = 'Second';
TimePassedType[TimePassedType.Minute] = 'Minute';
TimePassedType[TimePassedType.Hour] = 'Hour';
TimePassedType[TimePassedType.Day] = 'Day';
TimePassedType[TimePassedType.Month] = 'Month';
TimePassedType[TimePassedType.Year] = 'Year';
class TimePassedPipe {
    /**
     * @param {?} dateOne
     * @param {?=} dateTwo
     * @param {?=} type
     * @return {?}
     */
    static timeDiff(dateOne, dateTwo = new Date(), type = TimePassedType.Day) {
        /** @type {?} */
        const oneDay = 24 * 60 * 60 * 1000;
        /** @type {?} */
        const minute = 60 * 1000;
        /** @type {?} */
        const hour = 60 * minute;
        /** @type {?} */
        const day = hour * 24;
        /** @type {?} */
        const durationMap = {
            [TimePassedType.Millisecond]: 1,
            [TimePassedType.Second]: 1000,
            [TimePassedType.Minute]: minute,
            [TimePassedType.Hour]: hour,
            [TimePassedType.Day]: day,
            [TimePassedType.Month]: day * 30,
            [TimePassedType.Year]: day * 365
        };
        return Math.round(Math.abs((dateOne.getTime() - dateTwo.getTime()) / durationMap[type]));
    }
    /**
     * @param {?} dateOne
     * @param {?=} dateTwo
     * @param {?=} type
     * @return {?}
     */
    transform(dateOne, dateTwo, type) {
        if (!dateTwo) {
            dateTwo = new Date();
        }
        return TimePassedPipe.timeDiff(dateOne, dateTwo, type !== undefined ? type : TimePassedType.Minute);
    }
}
TimePassedPipe.ɵfac = function TimePassedPipe_Factory(t) { return new (t || TimePassedPipe)(); };
TimePassedPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "jpTimePassed", type: TimePassedPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TimePassedPipe, [{
        type: Pipe,
        args: [{
                name: 'jpTimePassed'
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TimePassedModule {
}
TimePassedModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: TimePassedModule });
TimePassedModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function TimePassedModule_Factory(t) { return new (t || TimePassedModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(TimePassedModule, { declarations: function () { return [TimePassedPipe]; }, imports: function () { return [CommonModule]; }, exports: function () { return [TimePassedPipe]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TimePassedModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [TimePassedPipe],
                exports: [TimePassedPipe]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EnumKeyFormatPipe {
    /**
     * @param {?} value
     * @return {?}
     */
    static defaultFormat(value) {
        return value
            .split(new RegExp('(?=[A-Z])'))
            .join(' ');
    }
    /**
     * @param {?} value
     * @param {?} enumValue
     * @param {?=} formatFunction
     * @return {?}
     */
    transform(value, enumValue, formatFunction = EnumKeyFormatPipe.defaultFormat) {
        return enumValue[value] ?
            formatFunction(enumValue[value]) :
            value;
    }
}
EnumKeyFormatPipe.ɵfac = function EnumKeyFormatPipe_Factory(t) { return new (t || EnumKeyFormatPipe)(); };
EnumKeyFormatPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "jpEnumKeyFormat", type: EnumKeyFormatPipe, pure: true });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EnumKeyFormatPipe, [{
        type: Pipe,
        args: [{
                name: 'jpEnumKeyFormat'
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class EnumKeyFormatModule {
}
EnumKeyFormatModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: EnumKeyFormatModule });
EnumKeyFormatModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function EnumKeyFormatModule_Factory(t) { return new (t || EnumKeyFormatModule)(); }, imports: [[
            CommonModule
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(EnumKeyFormatModule, { declarations: function () { return [EnumKeyFormatPipe]; }, imports: function () { return [CommonModule]; }, exports: function () { return [EnumKeyFormatPipe]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EnumKeyFormatModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    EnumKeyFormatPipe
                ],
                exports: [
                    EnumKeyFormatPipe
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ClickOutsideDirective, ClickOutsideModule, DEBOUNCE_TIME, DebounceChangeDirective, DebounceChangeModule, EnumKeyFormatModule, EnumKeyFormatPipe, EnumModule, EnumPipe, FormTouchOnHoverDirective, FormTouchOnHoverModule, LOAD_CLICK_CLASS, LoadClickDirective, LoadClickModule, OnChange, SanitizeModule, SanitizePipe, StopPropagationDirective, StopPropagationModule, TimePassedModule, TimePassedPipe, TimePassedType, TrackByFieldDirective, TrackByFieldModule };

//# sourceMappingURL=jaspero-ng-helpers.js.map