(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('@angular/material/snack-bar'), require('@ngneat/transloco'), require('rxjs/operators'), require('@angular/cdk/portal'), require('@angular/cdk/drag-drop'), require('json-pointer'), require('@angular/forms'), require('@angular/common'), require('@angular/cdk/overlay'), require('@angular/common/http'), require('@angular/material/dialog'), require('@angular/platform-browser'), require('tinymce/plugins/code'), require('tinymce/plugins/print'), require('tinymce/plugins/wordcount'), require('tinymce/plugins/link'), require('tinymce/plugins/image'), require('tinymce/plugins/imagetools'), require('tinymce/plugins/fullscreen'), require('tinymce/plugins/lists'), require('tinymce/plugins/autolink'), require('tinymce/plugins/advlist'), require('tinymce/plugins/table'), require('@angular/material/autocomplete'), require('@angular/material/button'), require('@angular/material/card'), require('@angular/material/checkbox'), require('@angular/material/chips'), require('@angular/material/core'), require('@angular/material/datepicker'), require('@angular/material/divider'), require('@angular/material/expansion'), require('@angular/material/form-field'), require('@angular/material/icon'), require('@angular/material/input'), require('@angular/material/progress-spinner'), require('@angular/material/radio'), require('@angular/material/select'), require('@angular/material/slide-toggle'), require('@angular/material/slider'), require('@angular/material/tabs'), require('@angular/material/tooltip'), require('@jaspero/ng-helpers')) :
    typeof define === 'function' && define.amd ? define('@jaspero/form-builder', ['exports', '@angular/core', 'rxjs', '@angular/material/snack-bar', '@ngneat/transloco', 'rxjs/operators', '@angular/cdk/portal', '@angular/cdk/drag-drop', 'json-pointer', '@angular/forms', '@angular/common', '@angular/cdk/overlay', '@angular/common/http', '@angular/material/dialog', '@angular/platform-browser', 'tinymce/plugins/code', 'tinymce/plugins/print', 'tinymce/plugins/wordcount', 'tinymce/plugins/link', 'tinymce/plugins/image', 'tinymce/plugins/imagetools', 'tinymce/plugins/fullscreen', 'tinymce/plugins/lists', 'tinymce/plugins/autolink', 'tinymce/plugins/advlist', 'tinymce/plugins/table', '@angular/material/autocomplete', '@angular/material/button', '@angular/material/card', '@angular/material/checkbox', '@angular/material/chips', '@angular/material/core', '@angular/material/datepicker', '@angular/material/divider', '@angular/material/expansion', '@angular/material/form-field', '@angular/material/icon', '@angular/material/input', '@angular/material/progress-spinner', '@angular/material/radio', '@angular/material/select', '@angular/material/slide-toggle', '@angular/material/slider', '@angular/material/tabs', '@angular/material/tooltip', '@jaspero/ng-helpers'], factory) :
    (global = global || self, factory((global.jaspero = global.jaspero || {}, global.jaspero['form-builder'] = {}), global.ng.core, global.rxjs, global.ng.material.snackBar, global.transloco, global.rxjs.operators, global.ng.cdk.portal, global.ng.cdk.dragDrop, global.jsonPointer, global.ng.forms, global.ng.common, global.ng.cdk.overlay, global.ng.common.http, global.ng.material.dialog, global.ng.platformBrowser, null, null, null, null, null, null, null, null, null, null, null, global.ng.material.autocomplete, global.ng.material.button, global.ng.material.card, global.ng.material.checkbox, global.ng.material.chips, global.ng.material.core, global.ng.material.datepicker, global.ng.material.divider, global.ng.material.expansion, global.ng.material.formField, global.ng.material.icon, global.ng.material.input, global.ng.material.progressSpinner, global.ng.material.radio, global.ng.material.select, global.ng.material.slideToggle, global.ng.material.slider, global.ng.material.tabs, global.ng.material.tooltip, global.ngHelpers));
}(this, (function (exports, core, rxjs, snackBar, transloco, operators, portal, dragDrop, jsonPointer, forms, common, overlay, http, dialog, platformBrowser, code, print, wordcount, link, image, imagetools, fullscreen, lists, autolink, advlist, table, autocomplete, button, card, checkbox, chips, core$1, datepicker, divider, expansion, formField, icon, input, progressSpinner, radio, select, slideToggle, slider, tabs, tooltip, ngHelpers) { 'use strict';

    (function (SegmentType) {
        SegmentType["Empty"] = "empty";
        SegmentType["Card"] = "card";
        SegmentType["Accordion"] = "accordion";
        SegmentType["Tabs"] = "tabs";
        SegmentType["Stepper"] = "stepper";
    })(exports.SegmentType || (exports.SegmentType = {}));

    (function (State) {
        State["Create"] = "create";
        State["Edit"] = "edit";
    })(exports.State || (exports.State = {}));

    var FormBuilderService = /** @class */ (function () {
        function FormBuilderService(transloco, snackBar) {
            this.transloco = transloco;
            this.snackBar = snackBar;
            /**
             * Array of components that need to
             * run save() methods on single instance
             */
            this.saveComponents = [];
        }
        FormBuilderService.prototype.notify = function (options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            var finalOptions = Object.assign({ success: 'GENERAL.OPERATION_COMPLETED', error: 'GENERAL.OPERATION_FAILED' }, options);
            return function (source$) {
                return source$.pipe(operators.tap(function () {
                    if (finalOptions.success) {
                        _this.snackBar.open(_this.transloco.translate(finalOptions.success), _this.transloco.translate('GENERAL.DISMISS'), {
                            duration: 5000
                        });
                    }
                }), operators.catchError(function (err) {
                    if (finalOptions.error) {
                        _this.snackBar.open(_this.transloco.translate(finalOptions.error), _this.transloco.translate('GENERAL.DISMISS'), {
                            panelClass: 'snack-bar-error',
                            duration: 5000
                        });
                    }
                    console.error(err);
                    return rxjs.throwError(err);
                }));
            };
        };
        return FormBuilderService;
    }());
    FormBuilderService.decorators = [
        { type: core.Injectable }
    ];
    FormBuilderService.ctorParameters = function () { return [
        { type: transloco.TranslocoService },
        { type: snackBar.MatSnackBar }
    ]; };

    var CUSTOM_FIELDS = new core.InjectionToken('CUSTOM_FIELDS');

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, exports) {
        for (var p in m)
            if (p !== "default" && !exports.hasOwnProperty(p))
                __createBinding(exports, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (Object.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var SEGMENT_DATA = new core.InjectionToken('SEGMENT_DATA');
    function createSegmentInjector(injector, dataToPass) {
        var injectorTokens = new WeakMap();
        injectorTokens.set(SEGMENT_DATA, dataToPass);
        return new portal.PortalInjector(injector, injectorTokens);
    }

    var SegmentComponent = /** @class */ (function () {
        function SegmentComponent(sData, injector) {
            this.sData = sData;
            this.injector = injector;
            this.nestedArraySegments = [];
            this.arrayFields = [];
        }
        SegmentComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.segment = this.sData.segment;
            this.classes = this.sData.segment.classes.join(' ');
            this.pointers = this.sData.parser.pointers;
            this.id = this.sData.segment.id || '';
            /**
             * Each segment compiles all nested segments
             */
            this.nestedSegments = filterAndCompileSegments(this.sData.segment.nestedSegments || [], this.sData.parser, this.sData.definitions, this.injector, this.segment.entryValue);
            var array = this.segment.array;
            /**
             * Add array items if necessary
             */
            if (array && this.segment.entryValue) {
                var values = void 0;
                try {
                    values = jsonPointer.get(this.segment.entryValue, array);
                }
                catch (e) { }
                if (values) {
                    values.forEach(function () { return _this.addArrayItem(false); });
                    this.pointers[array].control.patchValue(values);
                    for (var i = 0; i < values.length; i++) {
                        // @ts-ignore
                        this.sData.parser.loadHooks(this.pointers[array].arrayPointers[i]);
                    }
                }
            }
        };
        SegmentComponent.prototype.addArrayItem = function (loadHook) {
            var _this = this;
            if (loadHook === void 0) { loadHook = true; }
            var array = this.segment.array;
            var pointers = this.sData.parser.addArrayItem((this.sData.parent || '') + array, loadHook, this.sData.parent ? {
                pointer: this.sData.parent,
                index: 0
            } : undefined);
            var fields;
            if (this.segment.fields && this.segment.fields.length) {
                fields = this.segment.fields.map(function (key) {
                    key = (_this.sData.parent || '') + key;
                    return _this.sData.parser.field(key, pointers[key], _this.sData.definitions, true, array);
                });
            }
            else {
                fields = [this.sData.parser.field(array, Object.assign(Object.assign({}, this.pointers[array]), { control: pointers }), this.sData.definitions)];
            }
            this.arrayFields.unshift(fields);
            this.nestedArraySegments.unshift(this.nestedSegments = filterAndCompileSegments(this.sData.segment.nestedSegments || [], this.sData.parser, this.sData.definitions, this.injector, this.segment.entryValue, this.segment.array));
        };
        SegmentComponent.prototype.moveArray = function (up, fromIndex) {
            var toIndex;
            if (up) {
                toIndex = fromIndex === 0 ? this.arrayFields.length - 1 : fromIndex - 1;
            }
            else {
                toIndex = fromIndex === (this.arrayFields.length - 1) ? 0 : fromIndex + 1;
            }
            dragDrop.moveItemInArray(this.arrayFields, fromIndex, toIndex);
            dragDrop.moveItemInArray(this.nestedArraySegments, fromIndex, toIndex);
            this.sData.parser.moveArrayItem((this.sData.parent || '') + this.segment.array, fromIndex, toIndex, this.sData.parent ? {
                pointer: this.sData.parent,
                index: 0
            } : undefined);
        };
        SegmentComponent.prototype.removeArrayItem = function (index) {
            this.sData.parser.removeArrayItem((this.sData.parent || '') + this.segment.array, index, this.sData.parent ? {
                pointer: this.sData.parent,
                index: 0
            } : undefined);
            this.nestedArraySegments.splice(index, 1);
            this.arrayFields.splice(index, 1);
        };
        return SegmentComponent;
    }());
    SegmentComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-segment',
                    template: ''
                },] }
    ];
    SegmentComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [SEGMENT_DATA,] }] },
        { type: core.Injector }
    ]; };
    SegmentComponent.propDecorators = {
        classes: [{ type: core.HostBinding, args: ['class',] }],
        id: [{ type: core.HostBinding, args: ['id',] }]
    };

    var AccordionComponent = /** @class */ (function (_super) {
        __extends(AccordionComponent, _super);
        function AccordionComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AccordionComponent.prototype.ngOnInit = function () {
            var _this = this;
            _super.prototype.ngOnInit.call(this);
            this.accordions = (this.sData.segment.configuration || []).map(function (accord) { return ({
                title: accord.title,
                fields: (accord.fields || []).map(function (key) { return _this.sData.parser.field(key, _this.pointers[key], _this.sData.definitions); }),
                nestedSegments: filterAndCompileSegments(accord.nestedSegments || [], _this.sData.parser, _this.sData.definitions, _this.injector, _this.segment.entryValue)
            }); });
        };
        return AccordionComponent;
    }(SegmentComponent));
    AccordionComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-accordion',
                    template: "<ng-container *ngIf=\"segment.title || segment.subTitle\">\n  <h4 *ngIf=\"segment.title\">{{segment.title}}</h4>\n  <h5 *ngIf=\"segment.subTitle\">{{segment.subTitle}}</h5>\n  <div class=\"p-y-m\">\n    <mat-divider></mat-divider>\n  </div>\n</ng-container>\n\n<p *ngIf=\"segment.description\">{{segment.description}}</p>\n\n<mat-accordion>\n  <mat-expansion-panel *ngFor=\"let accord of accordions\" [expanded]=\"accord.expanded || false\">\n    <mat-expansion-panel-header>\n      <mat-panel-title *ngIf=\"accord.title\">{{accord.title}}</mat-panel-title>\n      <mat-panel-description *ngIf=\"accord.description\">\n        {{accord.description}}\n      </mat-panel-description>\n    </mat-expansion-panel-header>\n\n    <ng-container *ngFor=\"let field of accord.fields | showField:sData.parser\">\n      <ng-template [cdkPortalOutlet]=\"field.portal\"></ng-template>\n    </ng-container>\n\n    <ng-container *ngFor=\"let nested of accord.nestedSegments\">\n      <ng-template [cdkPortalOutlet]=\"nested.component\"></ng-template>\n    </ng-container>\n  </mat-expansion-panel>\n</mat-accordion>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [""]
                },] }
    ];

    var CardComponent = /** @class */ (function (_super) {
        __extends(CardComponent, _super);
        function CardComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(CardComponent.prototype, "fields", {
            get: function () {
                return this.segment.fields;
            },
            enumerable: false,
            configurable: true
        });
        return CardComponent;
    }(SegmentComponent));
    CardComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-card',
                    template: "<mat-card>\n  <mat-card-header *ngIf=\"segment.title || segment.subTitle || segment.array\">\n    <div>\n      <h1 *ngIf=\"segment.title\">{{segment.title}}</h1>\n      <h2 class=\"fs-small\" *ngIf=\"segment.subTitle\">{{segment.subTitle}}</h2>\n    </div>\n    <div class=\"flex-1\"></div>\n    <button *ngIf=\"segment.array\" mat-icon-button (click)=\"addArrayItem()\" [matTooltip]=\"'GENERAL.ADD' | transloco\">\n      <mat-icon>add</mat-icon>\n    </button>\n  </mat-card-header>\n\n  <mat-card-content>\n    <div class=\"fb-fields\">\n      <p class=\"mat-form-field-wrapper\" *ngIf=\"segment.description\">{{segment.description}}</p>\n\n      <ng-container *ngIf=\"segment.array; else regular\">\n        <ng-container *ngFor=\"let fields of arrayFields; index as index; last as last\">\n          <ng-container *ngFor=\"let field of fields | showField:sData.parser\">\n            <ng-template [cdkPortalOutlet]=\"field.portal\"></ng-template>\n          </ng-container>\n\n          <div class=\"fb-field-12\" *ngFor=\"let nested of (nestedArraySegments[index] || [])\">\n            <ng-template [cdkPortalOutlet]=\"nested.component\"></ng-template>\n          </div>\n\n          <div class=\"ta-right fb-field-12\">\n            <button mat-icon-button (click)=\"moveArray(true, index)\">\n              <mat-icon>arrow_upward</mat-icon>\n            </button>\n            &nbsp;\n            <button mat-icon-button (click)=\"moveArray(false, index)\">\n              <mat-icon>arrow_downward</mat-icon>\n            </button>\n            &nbsp;\n            <button mat-icon-button color=\"warn\" (click)=\"removeArrayItem(index)\">\n              <mat-icon>delete_forever</mat-icon>\n            </button>\n          </div>\n          <hr *ngIf=\"!last\" class=\"fb-field-12 m-y-m nested-divider\">\n        </ng-container>\n      </ng-container>\n\n      <ng-template #regular>\n        <ng-container *ngFor=\"let field of fields | showField:sData.parser\">\n          <ng-template [cdkPortalOutlet]=\"field.portal\"></ng-template>\n        </ng-container>\n\n        <ng-container *ngFor=\"let nested of nestedSegments\">\n          <ng-template [cdkPortalOutlet]=\"nested.component\"></ng-template>\n        </ng-container>\n      </ng-template>\n    </div>\n  </mat-card-content>\n</mat-card>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [".nested-divider{margin-left:-16px;margin-right:-16px}"]
                },] }
    ];

    var EmptyComponent = /** @class */ (function (_super) {
        __extends(EmptyComponent, _super);
        function EmptyComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(EmptyComponent.prototype, "fields", {
            get: function () {
                return this.segment.fields;
            },
            enumerable: false,
            configurable: true
        });
        return EmptyComponent;
    }(SegmentComponent));
    EmptyComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-empty',
                    template: "<ng-container *ngIf=\"segment.title || segment.subTitle\">\n  <div class=\"flex jc-between\">\n    <div>\n      <h4 *ngIf=\"segment.title\">{{segment.title}}</h4>\n      <h5 *ngIf=\"segment.subTitle\">{{segment.subTitle}}</h5>\n    </div>\n    <button *ngIf=\"segment.array\" mat-icon-button (click)=\"addArrayItem()\" [matTooltip]=\"'GENERAL.ADD' | transloco\">\n      <mat-icon>add</mat-icon>\n    </button>\n  </div>\n  <div class=\"p-y-m\">\n    <mat-divider></mat-divider>\n  </div>\n</ng-container>\n\n<div class=\"fb-fields panel\">\n  <p *ngIf=\"segment.description\">{{segment.description}}</p>\n\n  <ng-container *ngIf=\"segment.array; else regular\">\n    <ng-container *ngFor=\"let fields of arrayFields; index as index; last as last\">\n      <ng-container *ngFor=\"let field of fields | showField:sData.parser\">\n        <ng-template [cdkPortalOutlet]=\"field.portal\"></ng-template>\n      </ng-container>\n\n      <div class=\"fb-field-12\" *ngFor=\"let nested of (nestedArraySegments[index] || [])\">\n        <ng-template [cdkPortalOutlet]=\"nested.component\"></ng-template>\n      </div>\n\n      <div class=\"ta-right fb-field-12\">\n        <button mat-icon-button (click)=\"moveArray(true, index)\">\n          <mat-icon>arrow_upward</mat-icon>\n        </button>\n        &nbsp;\n        <button mat-icon-button (click)=\"moveArray(false, index)\">\n          <mat-icon>arrow_downward</mat-icon>\n        </button>\n        &nbsp;\n        <button mat-icon-button color=\"warn\" (click)=\"removeArrayItem(index)\">\n          <mat-icon>delete_forever</mat-icon>\n        </button>\n      </div>\n      <hr *ngIf=\"!last\" class=\"fb-field-12 m-y-m nested-divider\">\n    </ng-container>\n  </ng-container>\n\n  <ng-template #regular>\n    <ng-container *ngFor=\"let field of fields | showField:sData.parser\">\n      <ng-template [cdkPortalOutlet]=\"field.portal\"></ng-template>\n    </ng-container>\n\n    <ng-container *ngFor=\"let nested of nestedSegments\">\n      <ng-template [cdkPortalOutlet]=\"nested.component\"></ng-template>\n    </ng-container>\n  </ng-template>\n</div>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [".nested-divider{margin-left:-16px;margin-right:-16px}"]
                },] }
    ];

    var StepperComponent = /** @class */ (function (_super) {
        __extends(StepperComponent, _super);
        function StepperComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return StepperComponent;
    }(SegmentComponent));
    StepperComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-stepper',
                    template: "<p>\n  stepper works!\n</p>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [""]
                },] }
    ];

    function safeEval(method) {
        var final;
        try {
            // tslint:disable-next-line:no-eval
            final = eval(method);
        }
        catch (e) { }
        return final;
    }

    var TabsComponent = /** @class */ (function (_super) {
        __extends(TabsComponent, _super);
        function TabsComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(TabsComponent.prototype, "configuration", {
            get: function () {
                return this.segment.configuration;
            },
            enumerable: false,
            configurable: true
        });
        TabsComponent.prototype.ngOnInit = function () {
            var _this = this;
            _super.prototype.ngOnInit.call(this);
            if (this.configuration.selectedTabChange) {
                this.selectedTabChange = safeEval(this.configuration.selectedTabChange);
            }
            this.tabs = this.configuration.tabs.map(function (tab) { return (Object.assign(Object.assign({}, tab), { fields: (tab.fields || []).map(function (key) { return _this.sData.parser.field(key, _this.pointers[key], _this.sData.definitions); }), nestedSegments: filterAndCompileSegments(tab.nestedSegments || [], _this.sData.parser, _this.sData.definitions, _this.injector, _this.segment.entryValue) })); });
        };
        TabsComponent.prototype.tabChange = function (event) {
            if (this.selectedTabChange) {
                this.selectedTabChange(event, this.sData);
            }
        };
        return TabsComponent;
    }(SegmentComponent));
    TabsComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-tabs',
                    template: "<ng-container *ngIf=\"segment.title || segment.subTitle\">\n  <h4 *ngIf=\"segment.title\">{{segment.title}}</h4>\n  <h5 *ngIf=\"segment.subTitle\">{{segment.subTitle}}</h5>\n  <div class=\"p-y-m\">\n    <mat-divider></mat-divider>\n  </div>\n</ng-container>\n\n<p *ngIf=\"segment.description\">{{segment.description}}</p>\n\n<mat-tab-group\n  [selectedIndex]=\"configuration.selectedIndex\"\n  [dynamicHeight]=\"configuration.dynamicHeight\"\n  [disableRipple]=\"configuration.disableRipple\"\n  [attr.mat-align-tabs]=\"configuration.alignment\"\n  (selectedTabChange)=\"tabChange($event)\">\n\n  <mat-tab\n    *ngFor=\"let tab of tabs\"\n    [label]=\"tab.title\"\n    [disabled]=\"tab.disabled\">\n\n    <div class=\"p-a-s\">\n      <ng-container *ngFor=\"let field of tab.fields | showField:sData.parser\">\n        <ng-template [cdkPortalOutlet]=\"field.portal\"></ng-template>\n      </ng-container>\n    </div>\n\n    <ng-container *ngFor=\"let nested of tab.nestedSegments\">\n      <ng-template [cdkPortalOutlet]=\"nested.component\"></ng-template>\n    </ng-container>\n  </mat-tab>\n</mat-tab-group>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [""]
                },] }
    ];

    var _a;
    var SEGMENT_TYPE_COMPONENT_MAP = (_a = {},
        _a[exports.SegmentType.Empty] = EmptyComponent,
        _a[exports.SegmentType.Card] = CardComponent,
        _a[exports.SegmentType.Accordion] = AccordionComponent,
        _a[exports.SegmentType.Tabs] = TabsComponent,
        _a[exports.SegmentType.Stepper] = StepperComponent,
        _a);

    var ConditionType;
    (function (ConditionType) {
        ConditionType["Function"] = "function";
        ConditionType["Statement"] = "statement";
    })(ConditionType || (ConditionType = {}));
    var ConditionAction;
    (function (ConditionAction) {
        ConditionAction["Show"] = "show";
        ConditionAction["Hide"] = "hide";
    })(ConditionAction || (ConditionAction = {}));
    var ConditionEvaluate;
    (function (ConditionEvaluate) {
        ConditionEvaluate["OnLoad"] = "onLoad";
        ConditionEvaluate["OnChange"] = "onChange";
    })(ConditionEvaluate || (ConditionEvaluate = {}));

    function compileSegment(segment, parser, definitions, injector, entryValue, parent) {
        var e_1, _a;
        if (parent === void 0) { parent = ''; }
        var classes = [];
        var fields = [];
        if (segment.columnsDesktop) {
            classes.push("col-" + segment.columnsDesktop);
        }
        if (segment.columnsTablet) {
            classes.push("col-m-" + segment.columnsTablet);
        }
        if (segment.columnsMobile) {
            classes.push("col-s-" + segment.columnsMobile);
        }
        /**
         * If there aren't any column definitions
         * default to full width
         */
        if (!classes.length) {
            classes.push('col-12');
        }
        if (segment.classes) {
            classes.push.apply(classes, __spread(segment.classes));
        }
        if (segment.fields) {
            /**
             * If it's an array fields aren' parsed
             */
            if (segment.array) {
                // @ts-ignore
                fields = (segment.fields || []).map(function (fi) { return segment.array + fi; });
            }
            else {
                fields = (segment.fields || [])
                    // @ts-ignore
                    .reduce(function (acc, key) {
                    var definition = parser.getFromDefinitions(key, definitions);
                    if (!definition ||
                        !definition.roles ||
                        (typeof definition.roles === 'string' ?
                            definition.roles === parser.role :
                            definition.roles.includes(parser.role))) {
                        acc.push(parser.field(key, parser.pointers[key], definitions));
                    }
                    return acc;
                }, []);
            }
        }
        var compiledSegment = Object.assign(Object.assign({}, segment), { classes: classes,
            fields: fields,
            entryValue: entryValue });
        /**
         * TODO:
         * Statement support
         */
        if (segment.conditions) {
            compiledSegment.conditions = [];
            var valToPass = entryValue || {};
            try {
                for (var _b = __values(segment.conditions), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var cur = _c.value;
                    var condition = void 0;
                    var type = cur.type || ConditionType.Function;
                    var action = cur.action || ConditionAction.Show;
                    var evaluateOn = cur.evaluateOn || ConditionEvaluate.OnLoad;
                    var evaluateStates = cur.evaluateStates || [0, 1, 2];
                    if (cur.condition) {
                        condition = safeEval(cur.condition);
                    }
                    if (condition) {
                        /**
                         * Evaluate on load conditions
                         */
                        if (evaluateOn === ConditionEvaluate.OnLoad) {
                            /**
                             * Check if items should be excluded right away
                             */
                            if ((action === ConditionAction.Show && !condition(valToPass)) ||
                                (action === ConditionAction.Hide && condition(valToPass))) {
                                return null;
                            }
                        }
                        compiledSegment.conditions.push(Object.assign({ condition: condition,
                            type: type,
                            action: action,
                            evaluateStates: evaluateStates,
                            evaluateOn: evaluateOn }, cur.data && {
                            data: cur.data
                        }));
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return Object.assign({ component: new portal.ComponentPortal(SEGMENT_TYPE_COMPONENT_MAP[segment.type || exports.SegmentType.Card], null, createSegmentInjector(injector, Object.assign({ segment: compiledSegment, parser: parser,
                definitions: definitions }, parent && { parent: parent }))) }, compiledSegment);
    }

    function filterAndCompileSegments(segments, parser, definitions, injector, value, parent) {
        return segments.reduce(function (acc, cur) {
            if (!cur.authorization || cur.authorization.includes(parser.role)) {
                var compiled = compileSegment(cur, parser, definitions, injector, value, parent);
                if (compiled) {
                    acc.push(
                    // @ts-ignore
                    compiled);
                }
            }
            return acc;
        }, []);
    }

    (function (ComponentType) {
        ComponentType["Input"] = "input";
        ComponentType["Select"] = "select";
        ComponentType["File"] = "file";
        ComponentType["Image"] = "image";
        ComponentType["Gallery"] = "gallery";
        ComponentType["Toggle"] = "toggle";
        ComponentType["Checkbox"] = "checkbox";
        ComponentType["Date"] = "date";
        ComponentType["Range"] = "range";
        ComponentType["Radio"] = "radio";
        ComponentType["Slider"] = "slider";
        ComponentType["Autocomplete"] = "autocomplete";
        ComponentType["Wysiwyg"] = "wysiwyg";
        ComponentType["Chips"] = "chips";
        ComponentType["Draggable"] = "draggable";
        ComponentType["Textarea"] = "textarea";
    })(exports.ComponentType || (exports.ComponentType = {}));

    var DbService = /** @class */ (function () {
        function DbService() {
        }
        DbService.prototype.getDocuments = function (moduleId, pageSize, sort, cursor, filters) {
            return rxjs.of([]);
        };
        DbService.prototype.getDocumentsSimple = function (moduleId, orderBy, filter) {
            return rxjs.of([]);
        };
        DbService.prototype.getStateChanges = function (moduleId, pageSize, sort, cursor, filters) {
            return rxjs.of([]);
        };
        DbService.prototype.getDocument = function (moduleId, documentId, stream) {
            if (stream === void 0) { stream = false; }
            return rxjs.of();
        };
        DbService.prototype.setDocument = function (moduleId, documentId, data, options) {
            return rxjs.of();
        };
        DbService.prototype.removeDocument = function (moduleId, documentId) {
            return rxjs.of();
        };
        DbService.prototype.createUserAccount = function (email, password) {
            return rxjs.of();
        };
        DbService.prototype.removeUserAccount = function (id) {
            return rxjs.of();
        };
        return DbService;
    }());

    var COMPONENT_DATA = new core.InjectionToken('COMPONENT_DATA');
    function createComponentInjector(injector, dataToPass) {
        var injectorTokens = new WeakMap();
        injectorTokens.set(COMPONENT_DATA, dataToPass);
        return new portal.PortalInjector(injector, injectorTokens);
    }

    // @dynamic
    var FieldComponent = /** @class */ (function () {
        function FieldComponent(cData) {
            this.cData = cData;
            var classes = [
                "fb-field-" + (this.cData.columnsDesktop || 12)
            ];
            if (this.cData.columnsTablet) {
                classes.push("m-fb-field-" + this.cData.columnsTablet);
            }
            if (this.cData.columnsMobile) {
                classes.push("s-fb-field-" + this.cData.columnsMobile);
            }
            if (this.cData.class) {
                classes.push(this.cData.class);
            }
            this.class = classes.join(' ');
        }
        return FieldComponent;
    }());
    FieldComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-field',
                    template: ''
                },] }
    ];
    FieldComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [COMPONENT_DATA,] }] }
    ]; };
    FieldComponent.propDecorators = {
        class: [{ type: core.HostBinding, args: ['class',] }]
    };

    function getHsd(key, data) {
        if (data[key]) {
            var item_1;
            switch (data[key].type) {
                case 'dynamic':
                    item_1 = safeEval(data[key].value);
                    if (item_1) {
                        return data.form.valueChanges
                            .pipe(operators.map(function (value) { return item_1(data.control.value, value); }));
                    }
                    break;
                case 'static':
                    item_1 = safeEval(data[key].value);
                    if (item_1) {
                        return rxjs.of(item_1(data.control.value, data.form.getRawValue()));
                    }
                    break;
                case 'html':
                default:
                    return rxjs.of(data[key].value);
            }
        }
        return rxjs.of('');
    }

    var AutocompleteComponent = /** @class */ (function (_super) {
        __extends(AutocompleteComponent, _super);
        function AutocompleteComponent(cData, dbService) {
            var _this = _super.call(this, cData) || this;
            _this.cData = cData;
            _this.dbService = dbService;
            _this.loading$ = new rxjs.BehaviorSubject(true);
            return _this;
        }
        AutocompleteComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.prefix$ = getHsd('prefix', this.cData);
            this.suffix$ = getHsd('suffix', this.cData);
            var dataSet$;
            if (this.cData.populate) {
                var populate_1 = this.cData.populate;
                dataSet$ = this.dbService
                    .getDocumentsSimple(this.cData.populate.collection, this.cData.populate.orderBy, this.cData.populate.filter)
                    .pipe(operators.map(function (docs) { return docs.map(function (doc) { return ({
                    value: doc[populate_1.valueKey || 'id'],
                    name: doc[populate_1.nameKey]
                }); }); }), operators.tap(function () { return _this.loading$.next(false); }));
            }
            else {
                dataSet$ = rxjs.of(this.cData.dataSet);
            }
            this.filteredSet$ = dataSet$.pipe(operators.switchMap(function (dataSet) { return _this.cData.control.valueChanges.pipe(operators.startWith(_this.cData.control.value), operators.map(function (value) {
                if (!value) {
                    return dataSet;
                }
                value = value.toLowerCase();
                return dataSet.filter(function (item) { return item.name.toLowerCase().includes(value); });
            })); }));
        };
        return AutocompleteComponent;
    }(FieldComponent));
    AutocompleteComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-autocomplete',
                    template: "<mat-form-field appearance=\"outline\" class=\"w-full\">\n  <mat-label>{{(cData.label || '') | transloco}}</mat-label>\n  <input\n    matInput\n    [placeholder]=\"(cData.placeholder || '') | transloco\"\n    [attr.autocomplete]=\"cData.autocomplete || 'on'\"\n    [formControl]=\"cData.control\"\n    [matAutocomplete]=\"auto\">\n  <mat-autocomplete #auto=\"matAutocomplete\">\n    <mat-option *ngFor=\"let data of filteredSet$ | async\" [value]=\"data.value\">\n      {{data.name}}\n    </mat-option>\n  </mat-autocomplete>\n  <mat-hint *ngIf=\"cData.hint\" [innerHTML]=\"cData.hint | jpSanitize\"></mat-hint>\n  <span *ngIf=\"cData.suffix\" matSuffix [innerHTML]=\"((suffix$ | async) || '') | jpSanitize\"></span>\n  <span *ngIf=\"cData.prefix\" matPrefix [innerHTML]=\"((prefix$ | async) || '') | jpSanitize\"></span>\n</mat-form-field>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [""]
                },] }
    ];
    AutocompleteComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [COMPONENT_DATA,] }] },
        { type: DbService }
    ]; };

    var CheckboxComponent = /** @class */ (function (_super) {
        __extends(CheckboxComponent, _super);
        function CheckboxComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return CheckboxComponent;
    }(FieldComponent));
    CheckboxComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-checkbox',
                    template: "<div class=\"mat-form-field-wrapper\">\n  <mat-checkbox [formControl]=\"cData.control\">\n    <mat-label>{{cData.label | transloco}}</mat-label>\n  </mat-checkbox>\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.hint\">\n    {{cData.hint | transloco}}\n  </p>\n</div>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [""]
                },] }
    ];

    var ChipsComponent = /** @class */ (function (_super) {
        __extends(ChipsComponent, _super);
        function ChipsComponent() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            _this.data = [];
            return _this;
        }
        ChipsComponent.prototype.ngOnInit = function () {
            this.data = this.cData.control.value;
            this.removable = this.cData.hasOwnProperty('removable') ? this.cData.removable : true;
            this.prefix$ = getHsd('prefix', this.cData);
            this.suffix$ = getHsd('suffix', this.cData);
        };
        ChipsComponent.prototype.add = function (event) {
            var value = (event.value || '').trim();
            var input = event.input;
            if (value && (this.cData.unique ? !this.data.includes(value) : true)) {
                this.data.push(value);
                this.cData.control.setValue(this.data);
            }
            if (input) {
                input.value = '';
            }
        };
        ChipsComponent.prototype.remove = function (chip) {
            var index = this.cData.control.value.indexOf(chip);
            if (index >= 0) {
                this.data.splice(index, 1);
                this.cData.control.setValue(this.data);
            }
        };
        return ChipsComponent;
    }(FieldComponent));
    ChipsComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-chips',
                    template: "<mat-form-field class=\"w-full\" appearance=\"outline\">\n  <mat-label>{{(cData.label || '') | transloco}}</mat-label>\n  <mat-chip-list #chipList>\n    <mat-chip\n      *ngFor=\"let chip of data\"\n      [selectable]=\"cData.selectable\"\n      [removable]=\"removable\"\n      (removed)=\"remove(chip)\">\n      {{chip}}\n      <mat-icon *ngIf=\"removable\" matChipRemove>cancel</mat-icon>\n    </mat-chip>\n    <input\n      matInput\n      [attr.autocomplete]=\"cData.autocomplete || 'on'\"\n      [placeholder]=\"(cData.placeholder || '') | transloco\"\n      (matChipInputTokenEnd)=\"add($event)\"\n      [matChipInputFor]=\"chipList\">\n  </mat-chip-list>\n  <span *ngIf=\"cData.suffix\" matSuffix [innerHTML]=\"((suffix$ | async) || '') | jpSanitize\"></span>\n  <span *ngIf=\"cData.prefix\" matPrefix [innerHTML]=\"((prefix$ | async) || '') | jpSanitize\"></span>\n  <mat-hint *ngIf=\"cData.hint\" [innerHTML]=\"cData.hint | jpSanitize\"></mat-hint>\n</mat-form-field>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [""]
                },] }
    ];

    /**
     * Deep clones the given AbstractControl, preserving values, validators, async validators, and disabled status.
     * @param control AbstractControl
     * @returns AbstractControl
     */
    function cloneAbstractControl(control) {
        var newControl;
        if (control instanceof forms.FormGroup) {
            var formGroup_1 = new forms.FormGroup({}, control.validator, control.asyncValidator);
            var controls_1 = control.controls;
            Object.keys(controls_1).forEach(function (key) {
                formGroup_1.addControl(key, cloneAbstractControl(controls_1[key]));
            });
            newControl = formGroup_1;
        }
        else if (control instanceof forms.FormArray) {
            var formArray_1 = new forms.FormArray([], control.validator, control.asyncValidator);
            control.controls.forEach(function (formControl) { return formArray_1.push(cloneAbstractControl(formControl)); });
            newControl = formArray_1;
        }
        else if (control instanceof forms.FormControl) {
            newControl = new forms.FormControl(control.value, control.validator, control.asyncValidator);
        }
        else {
            throw new Error('Error: unexpected control value');
        }
        if (control.disabled) {
            newControl.disable({ emitEvent: false });
        }
        return newControl;
    }

    var DateFieldComponent = /** @class */ (function (_super) {
        __extends(DateFieldComponent, _super);
        function DateFieldComponent(cData, cdr, formBuilderService) {
            var _this = _super.call(this, cData) || this;
            _this.cData = cData;
            _this.cdr = cdr;
            _this.formBuilderService = formBuilderService;
            return _this;
        }
        DateFieldComponent.prototype.ngOnInit = function () {
            this.formBuilderService.saveComponents.push(this);
            this.startDate = this.cData.startAt
                ? new Date(this.cData.startAt)
                : new Date();
            var date = new Date(this.cData.control.value);
            this.entryControl = cloneAbstractControl(this.cData.control);
            this.hoursControl = new forms.FormControl({ value: date.getHours() || 0, disabled: this.cData.control.disabled }, [forms.Validators.min(0), forms.Validators.max(23)]);
            this.minutesControl = new forms.FormControl({ value: date.getMinutes() || 0, disabled: this.cData.control.disabled }, [forms.Validators.min(0), forms.Validators.max(59)]);
            /**
             * Dirty hack for getting numbers to display properly might need revisiting
             */
            if (typeof this.entryControl.value === 'number' ||
                typeof this.entryControl.value === 'string') {
                this.entryControl.setValue(new Date(this.entryControl.value));
            }
        };
        DateFieldComponent.prototype.save = function () {
            var _this = this;
            return rxjs.of({}).pipe(operators.tap(function () {
                var value = _this.entryControl.value;
                if (value) {
                    if (_this.cData.includeTime) {
                        value.setHours(_this.hoursControl.value || 0);
                        value.setMinutes(_this.minutesControl.value || 0);
                    }
                    if (_this.cData.format) {
                        if (_this.cData.format === 'number') {
                            value = value.getTime();
                        }
                        else {
                            var pipe = new common.DatePipe('en');
                            value = pipe.transform(value, _this.cData.format);
                        }
                    }
                }
                _this.cData.control.setValue(value);
            }));
        };
        return DateFieldComponent;
    }(FieldComponent));
    DateFieldComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-date-field',
                    template: "<div class=\"grid\">\n  <div class=\"p-l-0 {{!cData.includeTime ? 'col-12' : 'col-8'}}\">\n    <mat-form-field class=\"w-full\" appearance=\"outline\">\n      <mat-label>\n        {{(cData.label || '') | transloco}}\n      </mat-label>\n      <input\n        matInput\n        [attr.autocomplete]=\"cData.autocomplete || 'off'\"\n        [matDatepicker]=\"picker\"\n        [placeholder]=\"(cData.placeholder || '') | transloco\"\n        [formControl]=\"entryControl\">\n      <mat-datepicker-toggle matSuffix [for]=\"picker\"></mat-datepicker-toggle>\n      <mat-datepicker\n        #picker\n        [touchUi]=\"cData.touchUi || false\"\n        [startView]=\"cData.startView || 'month'\"\n        [startAt]=\"startDate\">\n      </mat-datepicker>\n      <mat-hint *ngIf=\"cData.hint\" [innerHTML]=\"cData.hint | jpSanitize\"></mat-hint>\n    </mat-form-field>\n  </div>\n  <ng-container *ngIf=\"cData.includeTime\">\n    <div class=\"col-2\">\n      <mat-form-field class=\"w-full\" class=\"w-full\" appearance=\"outline\">\n        <mat-label>{{(cData.labelHours || 'HOURS') | transloco}}</mat-label>\n        <input matInput type=\"number\" [placeholder]=\"cData.placeholderHours || 'HH'\" [formControl]=\"hoursControl\">\n      </mat-form-field>\n    </div>\n    <div class=\"col-2 p-r-0\">\n      <mat-form-field class=\"w-full\" appearance=\"outline\">\n        <mat-label>{{(cData.labelMinutes || 'MINUTES') | transloco}}</mat-label>\n        <input matInput type=\"number\" [placeholder]=\"cData.placeholderMinutes || 'MM'\" [formControl]=\"minutesControl\">\n      </mat-form-field>\n    </div>\n  </ng-container>\n</div>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [""]
                },] }
    ];
    DateFieldComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [COMPONENT_DATA,] }] },
        { type: core.ChangeDetectorRef },
        { type: FormBuilderService }
    ]; };

    var DraggableListComponent = /** @class */ (function (_super) {
        __extends(DraggableListComponent, _super);
        function DraggableListComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DraggableListComponent.prototype.ngOnInit = function () {
            var _this = this;
            if (this.cData.control.value.length) {
                this.cData.options.sort(function (optionOne, optionTwo) {
                    var indexOne = _this.cData.control.value.indexOf(optionOne);
                    var indexTwo = _this.cData.control.value.indexOf(optionTwo);
                    return indexTwo - indexOne;
                });
            }
        };
        DraggableListComponent.prototype.drop = function (event) {
            dragDrop.moveItemInArray(this.cData.options, event.previousIndex, event.currentIndex);
            this.cData.control.setValue(this.cData.options.map(function (val) {
                return val.value;
            }));
        };
        return DraggableListComponent;
    }(FieldComponent));
    DraggableListComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-draggable-list',
                    template: "<div class=\"mat-form-field-wrapper\">\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.label\">{{cData.label | transloco}}</p>\n\n  <div\n    class=\"fb-draggable-list\"\n    cdkDropList\n    (cdkDropListDropped)=\"drop($event)\">\n    <div\n      class=\"fb-draggable-list-item\"\n      *ngFor=\"let item of cData.options; index as index\"\n      [cdkDragDisabled]=\"item.disabled\"\n      cdkDrag>\n      {{index + 1}}. {{item.name}}\n    </div>\n  </div>\n</div>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [".fb-draggable-list{border:1px solid var(--panel-tertiary);border-radius:4px;overflow:hidden}.fb-draggable-list-item{align-items:center;background:var(--panel-theme);border-bottom:1px solid var(--panel-tertiary);cursor:move;display:flex;padding:20px 10px}.fb-draggable-list-item:last-child{border:none}.cdk-drag-preview{border-radius:4px;box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}.cdk-drag-placeholder{opacity:0}.cdk-drag-animating,.fb-draggable-list.cdk-drop-list-dragging .fb-draggable-list-item:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}"]
                },] }
    ];

    var StorageService = /** @class */ (function () {
        function StorageService() {
        }
        StorageService.prototype.upload = function (path, data, metadata) { };
        return StorageService;
    }());

    /**
     * Remove all characters that are not alphanumeric.
     *
     * In case of not finding any alphanumeric characters
     * return string `file-{random number}`
     *
     * @param name
     * File name to format
     */
    var formatFileName = function (name) {
        var extension = name.slice(name.lastIndexOf('.'));
        name = name.slice(0, name.lastIndexOf('.'));
        name = (name.match(/[a-zA-Z\d.]/g) || []).join('');
        return !!name.length ? name + extension : "file-" + (Math.floor(Math.random() * Math.pow(10, 5)) + 1) + extension;
    };

    var parseSize = function (size) {
        if (typeof size === 'number') {
            return size;
        }
        var KB = 1024;
        var MB = Math.pow(KB, 2);
        var num = parseFloat(size);
        var unit = size.replace(/[0-9]/g, '').toLowerCase();
        switch (unit) {
            case 'kb': {
                return num * KB;
            }
            case 'mb': {
                return num * MB;
            }
            default: {
                return 0;
            }
        }
    };

    var FileComponent = /** @class */ (function (_super) {
        __extends(FileComponent, _super);
        function FileComponent(cData, storage, cdr, formBuilderService, transloco, snackBar) {
            var _this = _super.call(this, cData) || this;
            _this.cData = cData;
            _this.storage = storage;
            _this.cdr = cdr;
            _this.formBuilderService = formBuilderService;
            _this.transloco = transloco;
            _this.snackBar = snackBar;
            return _this;
        }
        FileComponent.prototype.ngOnInit = function () {
            if (this.cData.control.value) {
                this.name = this.cData.control.value;
            }
            this.emptyLabel = (this.cData.hasOwnProperty('emptyLabel') ? this.cData.emptyLabel : 'FIELDS.FILE.EMPTY');
            this.formBuilderService.saveComponents.push(this);
            this.allowedFileTypes = this.cData.allowedFileTypes || [];
            this.forbiddenFileTypes = this.cData.forbiddenFileTypes || [];
            this.minSizeBytes = this.cData.minSize ? parseSize(this.cData.minSize) : 0;
            this.maxSizeBytes = this.cData.maxSize ? parseSize(this.cData.maxSize) : 0;
        };
        FileComponent.prototype.errorSnack = function (message, dismiss) {
            if (message === void 0) { message = 'GENERAL.ERROR'; }
            if (dismiss === void 0) { dismiss = 'GENERAL.DISMISS'; }
            this.snackBar.open(this.transloco.translate(message), this.transloco.translate(dismiss), {
                panelClass: 'snack-bar-error',
                duration: 5000
            });
        };
        FileComponent.prototype.fileChange = function (ev) {
            var el = ev.target;
            var file = Array.from(el.files)[0];
            Object.defineProperty(file, 'name', {
                writable: true,
                value: formatFileName(file.name)
            });
            if (!this.allowedFileTypes.includes(file.type) && !!this.allowedFileTypes.length) {
                this.errorSnack('FIELDS.FILE.INVALID_FILE_FORMAT');
                return rxjs.throwError('Invalid File Format');
            }
            if (this.forbiddenFileTypes.includes(file.type)) {
                this.errorSnack('FIELDS.FILE.FORBIDDEN_FILE_FORMAT');
                return rxjs.throwError('Forbidden File Format');
            }
            if (file.size < this.minSizeBytes) {
                this.errorSnack('FIELDS.FILE.BELOW_SIZE');
                return rxjs.throwError('File below minimal allowed size');
            }
            if (file.size > this.maxSizeBytes && !!this.maxSizeBytes) {
                this.errorSnack('FIELDS.FILE.EXCEED_SIZE');
                return rxjs.throwError('File exceeding allowed size');
            }
            this.value = file;
            if (this.value) {
                this.name = this.value.name;
            }
            el.value = '';
        };
        FileComponent.prototype.clear = function () {
            this.name = '';
            this.cData.control.setValue('');
        };
        FileComponent.prototype.save = function (moduleId, documentId) {
            var _this = this;
            if (this.value) {
                var name = [
                    moduleId,
                    documentId,
                    this.value.name
                ]
                    .join('-');
                return rxjs.from(this.storage.upload(name, this.value, {
                    contentType: this.value.type,
                    customMetadata: {
                        moduleId: moduleId,
                        documentId: documentId
                    }
                })).pipe(operators.switchMap(function (res) { return res.ref.getDownloadURL(); }), operators.tap(function (url) { return _this.cData.control.setValue(url); }));
            }
            else {
                return rxjs.of({});
            }
        };
        return FileComponent;
    }(FieldComponent));
    FileComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-file',
                    template: "<div class=\"mat-form-field-wrapper\">\n  <fieldset class=\"fb-file\">\n    <input #file type=\"file\" hidden (change)=\"fileChange($event)\">\n\n    <legend class=\"fb-file-legend\">{{(cData.label || '') | transloco}}</legend>\n\n    <div class=\"fb-file-field\">\n      <span class=\"fb-file-field-name\">{{name || (emptyLabel | transloco)}}</span>\n\n      <div class=\"fb-file-field-actions\">\n        <ng-container *ngIf=\"!cData.preventClear && name\">\n          <button mat-button (click)=\"clear()\">{{'REMOVE' | transloco}}</button>|\n        </ng-container>\n        <button mat-button (click)=\"file.click()\">{{'ADD' | transloco}}</button>\n      </div>\n    </div>\n  </fieldset>\n</div>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [".fb-file{border:1px solid var(--panel-tertiary);border-radius:4px;overflow:hidden;transition:.2s}.fb-file:hover{border:1px solid var(--panel-primary);box-shadow:0 0 0 1px var(--panel-primary)}.fb-file:focus-within{border:1px solid var(--primary-theme);box-shadow:0 0 0 1px var(--primary-theme)}.fb-file-legend{background:var(--panel-theme);color:var(--panel-secondary);font-size:.8em;margin-left:-8px;padding:0 4px}.fb-file-field{align-items:center;display:flex}.fb-file-field-name{color:var(--panel-secondary);flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:1px}.fb-file-field-actions{margin-left:auto;white-space:nowrap}"]
                },] }
    ];
    FileComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [COMPONENT_DATA,] }] },
        { type: StorageService },
        { type: core.ChangeDetectorRef },
        { type: FormBuilderService },
        { type: transloco.TranslocoService },
        { type: snackBar.MatSnackBar }
    ]; };
    FileComponent.propDecorators = {
        fileEl: [{ type: core.ViewChild, args: ['file', { static: true },] }]
    };

    function formatGeneratedImages(data) {
        return data.reduce(function (acc, cur, index) {
            acc["generate_" + (index + 1)] = Object.entries(cur).reduce(function (generated, _a) {
                var _b = __read(_a, 2), key = _b[0], value = _b[1];
                generated += "----" + key + ":" + value;
                return generated;
            }, '');
            return acc;
        }, {});
    }

    var STORAGE_URL = new core.InjectionToken('STORAGE_URL');

    /**
     * Switches the location of two items
     * in an array
     */
    function switchItemLocations(items, previousIndex, currentIndex) {
        var itemOne = items[previousIndex];
        var itemTwo = items[currentIndex];
        items[currentIndex] = itemOne;
        items[previousIndex] = itemTwo;
    }

    function readFile(blob) {
        return new rxjs.Observable(function (obs) {
            if (!(blob instanceof Blob)) {
                obs.error(new Error('`blob` must be an instance of File or Blob.'));
                return;
            }
            var reader = new FileReader();
            reader.onerror = function (err) { return obs.error(err); };
            reader.onabort = function (err) { return obs.error(err); };
            reader.onload = function () { return obs.next(reader.result); };
            reader.onloadend = function () { return obs.complete(); };
            return reader.readAsDataURL(blob);
        });
    }

    var GalleryComponent = /** @class */ (function (_super) {
        __extends(GalleryComponent, _super);
        function GalleryComponent(cData, storageUrl, dialog, cdr, http, storage, formBuilderService, viewportRuler, transloco, snackBar) {
            var _this = _super.call(this, cData) || this;
            _this.cData = cData;
            _this.storageUrl = storageUrl;
            _this.dialog = dialog;
            _this.cdr = cdr;
            _this.http = http;
            _this.storage = storage;
            _this.formBuilderService = formBuilderService;
            _this.viewportRuler = viewportRuler;
            _this.transloco = transloco;
            _this.snackBar = snackBar;
            _this.files = [];
            _this.toRemove = [];
            return _this;
        }
        GalleryComponent.prototype.ngOnInit = function () {
            this.formBuilderService.saveComponents.push(this);
            this.allowedImageTypes = this.cData.allowedImageTypes || [];
            this.forbiddenImageTypes = this.cData.forbiddenImageTypes || [];
            this.minSizeBytes = this.cData.minSize ? parseSize(this.cData.minSize) : 0;
            this.maxSizeBytes = this.cData.maxSize ? parseSize(this.cData.maxSize) : 0;
        };
        GalleryComponent.prototype.ngAfterViewInit = function () {
            var phElement = this.placeholder.element.nativeElement;
            var parentElement = phElement.parentElement;
            phElement.style.display = 'none';
            parentElement.removeChild(phElement);
        };
        GalleryComponent.prototype.openUploadDialog = function () {
            this.dialog.open(this.modalTemplate, {
                width: '420px'
            });
        };
        GalleryComponent.prototype.addImage = function (image) {
            var _this = this;
            this.http
                .get(image, {
                withCredentials: false,
                responseType: 'blob'
            })
                .pipe(operators.switchMap(function (blob) {
                var type = blob.type.split('/')[1].toLowerCase();
                if (!_this.allowedImageTypes.includes(type) && !!_this.allowedImageTypes.length) {
                    return rxjs.throwError('Invalid Image Format');
                }
                if (_this.forbiddenImageTypes.includes(type)) {
                    return rxjs.throwError('Forbidden Image Format');
                }
                if (blob.size < _this.minSizeBytes) {
                    return rxjs.throwError('Image below minimal allowed size');
                }
                if (blob.size > _this.maxSizeBytes && !!_this.maxSizeBytes) {
                    return rxjs.throwError('Image exceeding allowed size');
                }
                return rxjs.of(blob);
            }), this.formBuilderService.notify({
                error: 'FIELDS.GALLERY.UPLOAD_ERROR',
                success: null
            }))
                .subscribe(function (res) {
                var urlCreator = window.URL || window.webkitURL;
                var value = _this.cData.control.value;
                value.push({
                    data: urlCreator.createObjectURL(res),
                    live: true
                });
                _this.cData.control.setValue(value);
                _this.cdr.detectChanges();
            });
        };
        GalleryComponent.prototype.openFileUpload = function () {
            this.fileEl.nativeElement.click();
        };
        GalleryComponent.prototype.openSortImages = function () {
            this.dialog.open(this.imagesSort, {
                width: '800px'
            });
        };
        GalleryComponent.prototype.drop = function (event) {
            var value = this.cData.control.value;
            switchItemLocations(value, event.previousIndex, event.currentIndex);
            this.cData.control.setValue(value);
            this.cdr.detectChanges();
        };
        GalleryComponent.prototype.move = function (up, index) {
            if (up === void 0) { up = false; }
            var currentIndex = up ? index - 1 : index + 1;
            var value = this.cData.control.value;
            dragDrop.moveItemInArray(value, index, currentIndex);
            this.cData.control.setValue(value);
            this.cdr.detectChanges();
        };
        GalleryComponent.prototype.errorSnack = function (message, dismiss) {
            if (message === void 0) { message = 'GENERAL.ERROR'; }
            if (dismiss === void 0) { dismiss = 'GENERAL.DISMISS'; }
            this.snackBar.open(this.transloco.translate(message), this.transloco.translate(dismiss), {
                panelClass: 'snack-bar-error',
                duration: 5000
            });
        };
        GalleryComponent.prototype.filesUploaded = function (el) {
            var e_1, _a;
            var _this = this;
            var files = Array.from((el instanceof FileList ? el : el.files));
            try {
                for (var files_1 = __values(files), files_1_1 = files_1.next(); !files_1_1.done; files_1_1 = files_1.next()) {
                    var file = files_1_1.value;
                    Object.defineProperty(file, 'name', {
                        writable: true,
                        value: formatFileName(file.name)
                    });
                    var type = file.type.split('/')[1].toLowerCase();
                    if (!this.allowedImageTypes.includes(type) && !!this.allowedImageTypes.length) {
                        this.errorSnack('FIELDS.GALLERY.INVALID_IMAGE_FORMAT');
                        return rxjs.throwError('Invalid Image Format');
                    }
                    if (this.forbiddenImageTypes.includes(type)) {
                        this.errorSnack('FIELDS.GALLERY.FORBIDDEN_IMAGE_FORMAT');
                        return rxjs.throwError('Forbidden Image Format');
                    }
                    if (file.size < this.minSizeBytes) {
                        this.errorSnack('FIELDS.GALLERY.BELOW_SIZE');
                        return rxjs.throwError('Image below minimal allowed size');
                    }
                    if (file.size > this.maxSizeBytes && !!this.maxSizeBytes) {
                        this.errorSnack('FIELDS.GALLERY.EXCEED_SIZE');
                        return rxjs.throwError('Image exceeding allowed size');
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (files_1_1 && !files_1_1.done && (_a = files_1.return)) _a.call(files_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            rxjs.forkJoin(files.map(function (file) { return readFile(file).pipe(operators.map(function (data) { return ({
                data: data,
                pushToLive: file,
                live: false
            }); })); })).subscribe(function (fls) {
                var value = _this.cData.control.value;
                value.push.apply(value, __spread(fls));
                _this.cData.control.setValue(value);
                if (!(el instanceof FileList)) {
                    el.value = '';
                }
                _this.cdr.detectChanges();
            }, function () {
                if (!(el instanceof FileList)) {
                    el.value = '';
                }
            });
        };
        GalleryComponent.prototype.removeImage = function (index, item) {
            if (item.live && item.data.includes(this.storageUrl)) {
                this.toRemove.push(item.data);
            }
            this.cData.control.value.splice(index, 1);
        };
        GalleryComponent.prototype.sortDrop = function (event) {
            var value = this.cData.control.value;
            dragDrop.moveItemInArray(value, event.previousIndex, event.currentIndex);
            this.cData.control.setValue(value);
        };
        /**
         * Drag and Drop
         */
        GalleryComponent.prototype.dragMoved = function (e) {
            var _this = this;
            var point = this.getPointerPositionOnPage(e.event);
            this.listGroup._items.forEach(function (dropList) {
                if (__isInsideDropListClientRect(dropList, point.x, point.y)) {
                    _this.activeContainer = dropList;
                    return;
                }
            });
        };
        GalleryComponent.prototype.dropListDropped = function () {
            if (!this.target) {
                return;
            }
            var phElement = this.placeholder.element.nativeElement;
            var parent = phElement.parentElement;
            phElement.style.display = 'none';
            var element = this.source.element;
            parent.removeChild(phElement);
            parent.appendChild(phElement);
            parent.insertBefore(element.nativeElement, parent.children[this.sourceIndex]);
            this.target = null;
            this.source = null;
            if (this.sourceIndex !== this.targetIndex) {
                var value = this.cData.control.value;
                dragDrop.moveItemInArray(value, this.sourceIndex, this.targetIndex);
                this.cData.control.setValue(value);
            }
        };
        /** Determines the point of the page that was touched by the user. */
        GalleryComponent.prototype.getPointerPositionOnPage = function (event) {
            // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.
            var point = __isTouchEvent(event) ? (event.touches[0] || event.changedTouches[0]) : event;
            var scrollPosition = this.viewportRuler.getViewportScrollPosition();
            return {
                x: point.pageX - scrollPosition.left,
                y: point.pageY - scrollPosition.top
            };
        };
        /**
         * Executes all uploads/removes to persist
         * the changes on server
         */
        GalleryComponent.prototype.save = function (moduleId, documentId) {
            var _this = this;
            if (!this.toRemove.length &&
                !this.cData.control.value ||
                !this.cData.control.value.find(function (val) { return !val.live; })) {
                return rxjs.of([]);
            }
            return rxjs.forkJoin(__spread(this.toRemove.map(function (file) { return rxjs.from(_this.storage.storage.refFromURL(file).delete()).pipe(
            /**
             * Dont' fail if files didn't delete
             */
            operators.catchError(function () { return rxjs.of([]); })); }), this.cData.control.value.reduce(function (acc, cur) {
                if (cur.live !== undefined && !cur.live) {
                    var name = [
                        moduleId,
                        documentId,
                        cur.pushToLive.name
                    ]
                        .join('-');
                    acc.push(rxjs.from(_this.storage.upload(name, cur.pushToLive, {
                        contentType: cur.pushToLive.type,
                        customMetadata: Object.assign({ moduleId: moduleId,
                            documentId: documentId }, _this.cData.generatedImages &&
                            formatGeneratedImages(_this.cData.generatedImages))
                    })).pipe(operators.switchMap(function (task) { return task.ref.getDownloadURL(); }), operators.tap(function (url) {
                        cur.data = url;
                    })));
                }
                else {
                    acc.push(cur);
                }
                return acc;
            }, []))).pipe(operators.tap(function () { return _this.cData.control.setValue(_this.cData.control.value.map(function (item) { return (item.data ? item.data : item); })); }));
        };
        return GalleryComponent;
    }(FieldComponent));
    GalleryComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-gallery',
                    template: "<p class=\"fs-small fg-secondary\" *ngIf=\"cData.label\">{{(cData.label || '') | transloco}}</p>\n\n<div class=\"fb-gallery\" fbDropzone (dropped)=\"filesUploaded($event)\">\n  <div class=\"ta-center p-y-l\">\n    <button mat-button *ngIf=\"cData.allowUrl\" (click)=\"openUploadDialog()\">{{'FIELDS.GALLERY.ENTER_URL' | transloco}}</button>\n    <button mat-button *ngIf=\"cData.allowServerUpload\" (click)=\"openFileUpload()\">{{'FIELDS.GALLERY.CHOOSE_FILES' | transloco}}</button>\n    <button mat-button *ngIf=\"cData.allowServerUpload\" (click)=\"openSortImages()\">{{'FIELDS.GALLERY.SORT_IMAGES' | transloco}}</button>\n  </div>\n\n  <!--Upload from disk-->\n  <input #file type=\"file\" multiple hidden (change)=\"filesUploaded($event.target)\">\n\n  <!--Uploaded images list-->\n  <ng-container>\n    <div class=\"fb-gallery-list\" cdkDropListGroup>\n\n      <div class=\"fb-gallery-list-placeholder\" cdkDropList (cdkDropListDropped)=\"dropListDropped()\"></div>\n\n      <div\n        cdkDropList\n        class=\"fb-gallery-list-image\"\n        (cdkDropListDropped)=\"dropListDropped()\"\n        *ngFor=\"let val of cData.control.value; index as index\">\n\n        <div cdkDrag (cdkDragMoved)=\"dragMoved($event);\">\n          <img class=\"fb-gallery-list-image-inner\" [src]=\"(val.data || val) | jpSanitize:'resourceUrl'\">\n          <button class=\"fb-gallery-list-image-remove\" type=\"button\" mat-icon-button [matTooltip]=\"'GENERAL.REMOVE' | transloco\" (click)=\"removeImage(index, val)\">\n            <mat-icon>close</mat-icon>\n          </button>\n        </div>\n\n      </div>\n    </div>\n  </ng-container>\n</div>\n\n<!--Uplaod from URL-->\n<ng-template #modal>\n  <mat-dialog-content>\n    <mat-form-field class=\"w-full\" appearance=\"outline\">\n      <mat-label>{{'FIELDS.GALLERY.IMAGE_URL' | transloco}}</mat-label>\n      <input matInput #url>\n    </mat-form-field>\n  </mat-dialog-content>\n\n  <mat-dialog-actions class=\"jc-end\">\n    <button mat-button mat-dialog-close>{{'GENERAL.CANCEL' | transloco}}</button>&nbsp;\n    <button mat-flat-button color=\"primary\" [disabled]=\"!url.value\" (click)=\"addImage(url.value)\" mat-dialog-close>{{'FIELDS.GALLERY.ADD_IMAGE' | transloco}}</button>\n  </mat-dialog-actions>\n</ng-template>\n\n<!--Image sort-->\n<ng-template #imagesSort>\n  <h1 mat-dialog-title>{{'FIELDS.GALLERY.SORT_IMAGES' | transloco}}</h1>\n\n  <mat-dialog-content>\n\n    <div\n      class=\"sort-wrapper\"\n      cdkDropList\n      (cdkDropListDropped)=\"sortDrop($event)\">\n\n      <div class=\"sort-box\" *ngFor=\"let val of cData.control.value; index as index; first as first; last as last;\" cdkDrag>\n        <img class=\"sort-image\" [src]=\"(val.data || val) | jpSanitize:'resourceUrl'\">\n        <div class=\"flex-1\"></div>\n        <div>\n          <button mat-icon-button [disabled]=\"first\" (click)=\"move(true, index)\">\n            <mat-icon>arrow_upward</mat-icon>\n          </button>\n          <button mat-icon-button [disabled]=\"last\" (click)=\"move(false, index)\">\n            <mat-icon>arrow_downward</mat-icon>\n          </button>\n          <button mat-icon-button cdkDragHandle>\n            <mat-icon>drag_indicator</mat-icon>\n          </button>\n        </div>\n      </div>\n\n    </div>\n  </mat-dialog-content>\n</ng-template>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [".fb-gallery{border:1px dashed var(--tertiary);margin-bottom:1.25em;position:relative}.fb-gallery-list{cursor:-webkit-grab;cursor:grab;display:flex;flex-wrap:wrap}.fb-gallery-list-placeholder{border:2px dashed var(--tertiary)}.fb-gallery-list-image,.fb-gallery-list-placeholder{flex-basis:33.33333%;padding-bottom:33.33333%;position:relative;width:33.33333%}.fb-gallery-list-image{background:#eee;border:2px solid #fff}.fb-gallery-list-image-inner,.fb-gallery-list-image>div{height:100%;position:absolute;width:100%}.fb-gallery-list-image-inner{-o-object-fit:contain;left:0;object-fit:contain;top:0}.fb-gallery-list-image-remove{background:#fff;border:1px solid #222;line-height:24px;opacity:0;position:absolute;right:0;top:0;transition:.2s;visibility:hidden}.fb-gallery-list-image:hover .fb-gallery-list-image-remove{opacity:1;visibility:visible}.fb-gallery:before{bottom:0;content:\"Drop To Upload\";display:none;font-size:20px;left:0;margin:auto;position:absolute;right:0;text-align:center;top:0}.fb-gallery.active{background:#ccc;border:3px dashed var(--tertiary)}.fb-gallery.active:before{display:block}.sort-wrapper{background:#fff;border:1px solid #ccc;border-radius:4px;display:block;max-width:100%;min-height:60px;overflow:hidden}.sort-image{-o-object-fit:cover;height:40px;object-fit:cover;width:40px}.sort-box{align-items:center;background:#fff;border-bottom:1px solid #ccc;box-sizing:border-box;color:rgba(0,0,0,.87);display:flex;flex-direction:row;font-size:14px;justify-content:space-between;padding:20px 10px}.sort-box:last-child{border:none}.cdk-drag-preview{border-radius:4px;box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);box-sizing:border-box}.cdk-drag-placeholder{opacity:.3}.cdk-drag-animating,.cdk-drop-list-dragging .sort-box:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}"]
                },] }
    ];
    GalleryComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [COMPONENT_DATA,] }] },
        { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [STORAGE_URL,] }] },
        { type: dialog.MatDialog },
        { type: core.ChangeDetectorRef },
        { type: http.HttpClient },
        { type: StorageService },
        { type: FormBuilderService },
        { type: overlay.ViewportRuler },
        { type: transloco.TranslocoService },
        { type: snackBar.MatSnackBar }
    ]; };
    GalleryComponent.propDecorators = {
        listGroup: [{ type: core.ViewChild, args: [dragDrop.CdkDropListGroup, { static: true },] }],
        placeholder: [{ type: core.ViewChild, args: [dragDrop.CdkDropList, { static: true },] }],
        modalTemplate: [{ type: core.ViewChild, args: ['modal', { static: true },] }],
        imagesSort: [{ type: core.ViewChild, args: ['imagesSort', { static: true },] }],
        fileEl: [{ type: core.ViewChild, args: ['file', { static: true },] }]
    };
    function __indexOf(collection, node) {
        return Array.prototype.indexOf.call(collection, node);
    }
    /** Determines whether an event is a touch event. */
    function __isTouchEvent(event) {
        return event.type.startsWith('touch');
    }
    function __isInsideDropListClientRect(dropList, x, y) {
        var _a = dropList.element.nativeElement.getBoundingClientRect(), top = _a.top, bottom = _a.bottom, left = _a.left, right = _a.right;
        return y >= top && y <= bottom && x >= left && x <= right;
    }

    var ImageComponent = /** @class */ (function (_super) {
        __extends(ImageComponent, _super);
        function ImageComponent(cData, storage, cdr, formBuilderService, transloco, snackBar, domSanitizer) {
            var _this = _super.call(this, cData) || this;
            _this.cData = cData;
            _this.storage = storage;
            _this.cdr = cdr;
            _this.formBuilderService = formBuilderService;
            _this.transloco = transloco;
            _this.snackBar = snackBar;
            _this.domSanitizer = domSanitizer;
            _this.disInput = false;
            return _this;
        }
        ImageComponent.prototype.ngOnInit = function () {
            this.imageUrl = new forms.FormControl(this.cData.control.value);
            this.formBuilderService.saveComponents.push(this);
            this.allowedImageTypes = this.cData.allowedImageTypes || [];
            this.forbiddenImageTypes = this.cData.forbiddenImageTypes || [];
            this.minSizeBytes = this.cData.minSize ? parseSize(this.cData.minSize) : 0;
            this.maxSizeBytes = this.cData.maxSize ? parseSize(this.cData.maxSize) : 0;
        };
        ImageComponent.prototype.errorSnack = function (message, dismiss) {
            if (message === void 0) { message = 'GENERAL.ERROR'; }
            if (dismiss === void 0) { dismiss = 'GENERAL.DISMISS'; }
            this.snackBar.open(this.transloco.translate(message), this.transloco.translate(dismiss), {
                panelClass: 'snack-bar-error',
                duration: 5000
            });
        };
        ImageComponent.prototype.openFileUpload = function () {
            this.fileEl.nativeElement.click();
        };
        ImageComponent.prototype.filesImage = function (event) {
            var _this = this;
            var el = event.target;
            var image = Array.from(el.files)[0];
            Object.defineProperty(image, 'name', {
                writable: true,
                value: formatFileName(image.name)
            });
            if (!this.allowedImageTypes.includes(image.type) && !!this.allowedImageTypes.length) {
                this.errorSnack('FIELDS.GALLERY.INVALID_IMAGE_FORMAT');
                return rxjs.throwError('Invalid Image Format');
            }
            if (this.forbiddenImageTypes.includes(image.type)) {
                this.errorSnack('FIELDS.GALLERY.FORBIDDEN_IMAGE_FORMAT');
                return rxjs.throwError('Forbidden Image Format');
            }
            if (image.size < this.minSizeBytes) {
                this.errorSnack('FIELDS.GALLERY.BELOW_SIZE');
                return rxjs.throwError('Image below minimal allowed size');
            }
            if (image.size > this.maxSizeBytes && !!this.maxSizeBytes) {
                this.errorSnack('FIELDS.GALLERY.EXCEED_SIZE');
                return rxjs.throwError('Image exceeding allowed size');
            }
            this.value = image;
            this.disInput = true;
            this.imageUrl.setValue(this.value.name);
            var reader = new FileReader();
            reader.onload = function () {
                _this.imageSrc = _this.domSanitizer.bypassSecurityTrustResourceUrl(reader.result);
                _this.cdr.detectChanges();
            };
            reader.readAsDataURL(this.value);
            el.value = '';
        };
        ImageComponent.prototype.remove = function () {
            this.imageUrl.setValue('');
            this.value = null;
            this.disInput = false;
            this.cdr.detectChanges();
        };
        ImageComponent.prototype.save = function (moduleId, documentId) {
            var _this = this;
            if (this.value) {
                if (this.imageUrl.value && this.imageUrl.value !== this.value.name) {
                    return rxjs.of(this.imageUrl.value).pipe(operators.tap(function () { return _this.cData.control.setValue(_this.imageUrl.value); }));
                }
                else {
                    var name = [
                        moduleId,
                        documentId,
                        this.value.name
                    ]
                        .join('-');
                    return rxjs.from(this.storage.upload(name, this.value, {
                        contentType: this.value.type,
                        customMetadata: Object.assign({ moduleId: moduleId,
                            documentId: documentId }, (this.cData.generatedImages &&
                            formatGeneratedImages(this.cData.generatedImages)))
                    })).pipe(operators.switchMap(function (res) { return res.ref.getDownloadURL(); }), operators.tap(function (url) { return _this.cData.control.setValue(url); }));
                }
            }
            else {
                this.cData.control.setValue(this.imageUrl.value);
                return rxjs.of({});
            }
        };
        return ImageComponent;
    }(FieldComponent));
    ImageComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-image',
                    template: "<mat-form-field appearance=\"outline\" class=\"w-full\">\n  <mat-label>{{(cData.label || '') | transloco}}</mat-label>\n  <input\n    matInput\n    type=\"url\"\n    [placeholder]=\"(cData.placeholder || '') | transloco\"\n    [class.disabled]=\"disInput\"\n    [formControl]=\"imageUrl\">\n  <div matSuffix class=\"fb-image-suffix\">\n    <ng-container *ngIf=\"imageUrl.value\">\n      <div class=\"fb-image-suffix-preview\">\n        <button class=\"fb-image-suffix-preview-button\" mat-icon-button>\n          <mat-icon>visibility</mat-icon>\n        </button>\n        <img class=\"fb-image-suffix-preview-image\" [attr.src]=\"imageSrc || imageUrl.value || value\" [alt]=\"'FIELDS.IMAGE.PREVIEW' | transloco\">\n      </div>\n    </ng-container>\n    <button mat-icon-button *ngIf=\"!imageUrl.value && !cData.preventServerUpload\">\n      <mat-icon (click)=\"openFileUpload()\">perm_media</mat-icon>\n    </button>\n    <button mat-icon-button *ngIf=\"imageUrl.value\">\n      <mat-icon (click)=\"remove()\">highlight_off</mat-icon>\n    </button>\n  </div>\n  <mat-hint *ngIf=\"cData.hint\" [innerHTML]=\"cData.hint | jpSanitize\"></mat-hint>\n</mat-form-field>\n\n<input #file type=\"file\" hidden (change)=\"filesImage($event)\">\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [".fb-image-suffix{display:flex}.fb-image-suffix-preview{display:inline-block;position:relative}.fb-image-suffix-preview-image{-o-object-fit:contain;background:#fff;box-shadow:0 2px 5px 0 rgba(0,0,0,.4);height:200px;max-width:unset;object-fit:contain;opacity:0;position:absolute;right:0;top:100%;transition:.2s;visibility:hidden;width:200px;z-index:2}.fb-image-suffix-preview-button:hover+.fb-image-suffix-preview-image{opacity:1;visibility:visible}"]
                },] }
    ];
    ImageComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [COMPONENT_DATA,] }] },
        { type: StorageService },
        { type: core.ChangeDetectorRef },
        { type: FormBuilderService },
        { type: transloco.TranslocoService },
        { type: snackBar.MatSnackBar },
        { type: platformBrowser.DomSanitizer }
    ]; };
    ImageComponent.propDecorators = {
        fileEl: [{ type: core.ViewChild, args: ['file', { static: true },] }]
    };

    var InputComponent = /** @class */ (function (_super) {
        __extends(InputComponent, _super);
        function InputComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        InputComponent.prototype.ngOnInit = function () {
            this.prefix$ = getHsd('prefix', this.cData);
            this.suffix$ = getHsd('suffix', this.cData);
        };
        return InputComponent;
    }(FieldComponent));
    InputComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-input',
                    template: "<!--TODO: Format this when fixed. For some reason if the type is passed through a variable angular doesn't properly parse-->\n<ng-container [ngSwitch]=\"cData.type\">\n  <mat-form-field *ngSwitchCase=\"'number'\" class=\"w-full\" appearance=\"outline\" [class.mat-form-field-has-hint]=\"cData.hint\">\n    <mat-label>{{(cData.label || '') | transloco}}</mat-label>\n    <span *ngIf=\"cData.prefix\" matPrefix [innerHTML]=\"((prefix$ | async) || '') | jpSanitize\"></span>\n    <input\n      matInput\n      type=\"number\"\n      [attr.autocomplete]=\"cData.autocomplete || 'on'\"\n      [placeholder]=\"(cData.placeholder || '') | transloco\"\n      [formControl]=\"cData.control\">\n    <span *ngIf=\"cData.suffix\" matSuffix [innerHTML]=\"((suffix$ | async) || '') | jpSanitize\"></span>\n    <mat-hint *ngIf=\"cData.hint\" [innerHTML]=\"cData.hint | jpSanitize\"></mat-hint>\n  </mat-form-field>\n\n  <mat-form-field *ngSwitchDefault class=\"w-full\" appearance=\"outline\" [class.mat-form-field-has-hint]=\"cData.hint\">\n    <mat-label>{{(cData.label || '') | transloco}}</mat-label>\n    <span *ngIf=\"cData.prefix\" matPrefix [innerHTML]=\"((prefix$ | async) || '') | jpSanitize\"></span>\n    <input\n        matInput\n        [attr.autocomplete]=\"cData.autocomplete || 'on'\"\n        [attr.type]=\"cData.type\"\n        [placeholder]=\"(cData.placeholder || '') | transloco\"\n        [formControl]=\"cData.control\">\n    <span *ngIf=\"cData.suffix\" matSuffix [innerHTML]=\"((suffix$ | async) || '') | jpSanitize\"></span>\n    <mat-hint *ngIf=\"cData.hint\" [innerHTML]=\"cData.hint | jpSanitize\"></mat-hint>\n  </mat-form-field>\n</ng-container>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [""]
                },] }
    ];

    var RadioComponent = /** @class */ (function (_super) {
        __extends(RadioComponent, _super);
        function RadioComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return RadioComponent;
    }(FieldComponent));
    RadioComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-radio',
                    template: "<div class=\"mat-form-field-wrapper\">\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.label\">{{(cData.label || '') | transloco}}</p>\n  <mat-radio-group [formControl]=\"cData.control\">\n    <mat-radio-button\n      *ngFor=\"let option of cData.options\"\n      [disabled]=\"option.disabled\"\n      [value]=\"option.value\">\n      {{option.name}}\n    </mat-radio-button>\n  </mat-radio-group>\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.hint\">\n    {{(cData.hint | transloco) | transloco}}\n  </p>\n</div>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [""]
                },] }
    ];

    var RangeComponent = /** @class */ (function (_super) {
        __extends(RangeComponent, _super);
        function RangeComponent(cData, cdr, formBuilderService) {
            var _this = _super.call(this, cData) || this;
            _this.cData = cData;
            _this.cdr = cdr;
            _this.formBuilderService = formBuilderService;
            return _this;
        }
        RangeComponent.prototype.ngOnInit = function () {
            this.formBuilderService.saveComponents.push(this);
            this.min = new Date(this.cData.min || 0);
            this.max = new Date(this.cData.max || Date.now() * 2);
            this.entryControl = cloneAbstractControl(this.cData.control);
            this.start = new forms.FormControl({ value: this.entryControl.value.start || '', disabled: this.cData.control.disabled }, [forms.Validators.min(this.cData.min || 0)]);
            this.end = new forms.FormControl({ value: this.entryControl.value.end || '', disabled: this.cData.control.disabled }, [forms.Validators.max(this.cData.max || Date.now() * 2)]);
        };
        RangeComponent.prototype.save = function () {
            var _this = this;
            return rxjs.of({}).pipe(operators.tap(function () {
                var start = _this.start.value;
                var end = _this.end.value;
                _this.cData.control.setValue({ start: start, end: end });
            }));
        };
        return RangeComponent;
    }(FieldComponent));
    RangeComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-range',
                    template: "<div class=\"mat-form-field-wrapper\">\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.label\">{{(cData.label || '') | transloco}}</p>\n\n  <mat-form-field appearance=\"outline\" class=\"w-full\">\n    <mat-label>Enter a date range</mat-label>\n    <mat-date-range-input [rangePicker]=\"picker\">\n      <input matStartDate placeholder=\"Start date\" [formControl]=\"start\" [min]=\"min\">\n      <input matEndDate placeholder=\"End date\" [formControl]=\"end\" [max]=\"max\">\n    </mat-date-range-input>\n    <mat-datepicker-toggle matSuffix [for]=\"picker\"></mat-datepicker-toggle>\n    <mat-date-range-picker #picker></mat-date-range-picker>\n  </mat-form-field>\n\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.hint\">\n    {{(cData.hint | transloco) | transloco}}\n  </p>\n</div>\n",
                    styles: [""]
                },] }
    ];
    RangeComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [COMPONENT_DATA,] }] },
        { type: core.ChangeDetectorRef },
        { type: FormBuilderService }
    ]; };

    var ADDITIONAL_CONTEXT = new core.InjectionToken('ADDITIONAL_CONTEXT');

    function parseTemplate(value, obj) {
        if (value === void 0) { value = ''; }
        if (obj === void 0) { obj = {}; }
        if (!value.includes('{{')) {
            return obj[value];
        }
        else {
            var lookUp = new RegExp("{{(.*?)}}");
            while (lookUp.test(value)) {
                value = value.replace(lookUp, (RegExp.$1)
                    .split('.')
                    .reduce(function (acc, cur) { return acc[cur]; }, obj));
            }
            return value;
        }
    }

    var ROLE = new core.InjectionToken('ROLE');

    var SelectComponent = /** @class */ (function (_super) {
        __extends(SelectComponent, _super);
        function SelectComponent(cData, dbService, role, additionalContext) {
            var _this = _super.call(this, cData) || this;
            _this.cData = cData;
            _this.dbService = dbService;
            _this.role = role;
            _this.additionalContext = additionalContext;
            _this.loading$ = new rxjs.BehaviorSubject(true);
            return _this;
        }
        SelectComponent.prototype.ngOnInit = function () {
            var _this = this;
            if (this.cData.populate) {
                var populate_1 = this.cData.populate;
                var mapResults_1 = populate_1.mapResults ? safeEval(populate_1.mapResults) : null;
                var documentsMethod_1 = function (query) {
                    _this.loading$.next(true);
                    if (!query) {
                        _this.loading$.next(false);
                        return rxjs.of([]);
                    }
                    if (query.filter && typeof query.filter === 'string') {
                        return _this.dbService.getDocument(query.collection, query.filter)
                            .pipe(operators.map(function (it) {
                            return (mapResults_1 ? mapResults_1(it) : [it]).map(function (doc) { return ({
                                value: doc[populate_1.valueKey || 'id'],
                                name: parseTemplate(populate_1.nameKey || 'name', doc)
                            }); });
                        }), operators.tap(function () { return _this.loading$.next(false); }));
                    }
                    return _this.dbService
                        .getDocumentsSimple(query.collection, query.orderBy, query.filter)
                        .pipe(operators.map(function (docs) {
                        if (mapResults_1) {
                            docs = mapResults_1(docs, {
                                fieldData: _this.cData,
                                value: _this.cData.form.getRawValue(),
                                role: _this.role,
                                additionalContext: _this.additionalContext
                            });
                        }
                        return docs.map(function (doc) { return ({
                            value: doc[populate_1.valueKey || 'id'],
                            name: parseTemplate(populate_1.nameKey || 'name', doc)
                        }); });
                    }), operators.tap(function () { return _this.loading$.next(false); }));
                };
                if (populate_1.dependency) {
                    var pointer = this.cData.pointers[populate_1.dependency.key];
                    var gm_1 = safeEval(populate_1.dependency.method);
                    this.dataSet$ = pointer.control.valueChanges
                        .pipe(operators.startWith(pointer.control.value), operators.switchMap(function (value) { return documentsMethod_1(gm_1(value, {
                        fieldData: _this.cData,
                        value: _this.cData.form.getRawValue(),
                        role: _this.role,
                        additionalContext: _this.additionalContext
                    })); }));
                }
                else {
                    var filter = populate_1.filter;
                    if (populate_1.dynamicFilter) {
                        filter = safeEval(populate_1.dynamicFilter)({
                            fieldData: this.cData,
                            value: this.cData.form.getRawValue(),
                            role: this.role,
                            additionalContext: this.additionalContext
                        });
                    }
                    this.dataSet$ = documentsMethod_1({
                        collection: populate_1.collection,
                        orderBy: populate_1.orderBy,
                        filter: filter
                    });
                }
            }
            else {
                this.dataSet$ = rxjs.of(this.cData.dataSet);
            }
        };
        return SelectComponent;
    }(FieldComponent));
    SelectComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-select',
                    template: "<mat-form-field class=\"w-full\" appearance=\"outline\" [class.mat-form-field-has-hint]=\"cData.hint\">\n  <mat-label>{{(cData.label || '') | transloco}}</mat-label>\n  <mat-select\n    [placeholder]=\"(cData.placeholder || '') | transloco\"\n    [formControl]=\"cData.control\"\n    [multiple]=\"cData.multiple\"\n    [attr.autocomplite]=\"cData.autocomplete || 'off'\">\n    <mat-option *ngFor=\"let data of dataSet$ | async\" [value]=\"data.value\" [disabled]=\"data.disabled\">\n      {{data.name}}\n    </mat-option>\n  </mat-select>\n  <mat-spinner\n    matSuffix\n    *ngIf=\"cData.populate && (loading$ | async)\"\n    [diameter]=\"20\"></mat-spinner>\n  <mat-hint *ngIf=\"cData.hint\" [innerHTML]=\"cData.hint | jpSanitize\"></mat-hint>\n</mat-form-field>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [""]
                },] }
    ];
    SelectComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [COMPONENT_DATA,] }] },
        { type: DbService },
        { type: String, decorators: [{ type: core.Inject, args: [ROLE,] }] },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [ADDITIONAL_CONTEXT,] }] }
    ]; };

    var SliderComponent = /** @class */ (function (_super) {
        __extends(SliderComponent, _super);
        function SliderComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SliderComponent.prototype.ngOnInit = function () {
            this.startAt = this.cData.starAt
                ? this.cData.starAt
                : this.cData.validation.minimum
                    ? this.cData.validation.minimum
                    : 0;
            this.endAt = this.cData.endAt
                ? this.cData.endAt
                : this.cData.validation.maximum
                    ? this.cData.validation.maximum
                    : 100;
        };
        return SliderComponent;
    }(FieldComponent));
    SliderComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-slider',
                    template: "<div class=\"mat-form-field-wrapper\">\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.label\">{{(cData.label || '') | transloco}}</p>\n  <mat-slider\n    [formControl]=\"cData.control\"\n    [thumbLabel]=\"cData.thumbLabel\"\n    [tickInterval]=\"cData.tickInterval\"\n    [min]=\"startAt\"\n    [max]=\"endAt\">\n  </mat-slider>\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.hint\">\n    {{(cData.hint || '') | transloco}}\n  </p>\n</div>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [""]
                },] }
    ];

    var TextareaComponent = /** @class */ (function (_super) {
        __extends(TextareaComponent, _super);
        function TextareaComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        TextareaComponent.prototype.ngOnInit = function () {
            this.prefix$ = getHsd('prefix', this.cData);
            this.suffix$ = getHsd('suffix', this.cData);
        };
        return TextareaComponent;
    }(FieldComponent));
    TextareaComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-textarea',
                    template: "<mat-form-field class=\"w-full\" appearance=\"outline\">\n  <mat-label>{{(cData.label || '') | transloco}}</mat-label>\n  <textarea\n    matInput\n    [placeholder]=\"(cData.placeholder || '') | transloco\"\n    [attr.autocomplete]=\"cData.autocomplete || 'on'\"\n    [rows]=\"cData.rows\"\n    [cols]=\"cData.cols\"\n    [formControl]=\"cData.control\">\n  </textarea>\n  <mat-hint *ngIf=\"cData.hint\" [innerHTML]=\"cData.hint | jpSanitize\"></mat-hint>\n  <span *ngIf=\"cData.suffix\" matSuffix [innerHTML]=\"((suffix$ | async) || '') | jpSanitize\"></span>\n  <span *ngIf=\"cData.prefix\" matPrefix [innerHTML]=\"((prefix$ | async) || '') | jpSanitize\"></span>\n</mat-form-field>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [""]
                },] }
    ];

    var ToggleComponent = /** @class */ (function (_super) {
        __extends(ToggleComponent, _super);
        function ToggleComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return ToggleComponent;
    }(FieldComponent));
    ToggleComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-toggle',
                    template: "<div class=\"mat-form-field-wrapper\">\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.label\">{{(cData.label || '') | transloco}}</p>\n  <mat-slide-toggle [formControl]=\"cData.control\"></mat-slide-toggle>\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.hint\">\n    {{(cData.hint || '') | transloco}}\n  </p>\n</div>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [""]
                },] }
    ];

    var WysiwygComponent = /** @class */ (function (_super) {
        __extends(WysiwygComponent, _super);
        function WysiwygComponent(cData, fb, dialog, storage, formBuilderComponent) {
            var _this = _super.call(this, cData) || this;
            _this.cData = cData;
            _this.fb = fb;
            _this.dialog = dialog;
            _this.storage = storage;
            _this.formBuilderComponent = formBuilderComponent;
            _this.ytDefault = {
                fullWidth: true,
                showPlayerControls: true,
                privacyEnhancedMode: false,
                align: 'left'
            };
            return _this;
        }
        WysiwygComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.ytForm = this.fb.group(Object.assign({ value: ['', forms.Validators.required] }, this.ytDefault));
            this.cData.control.statusChanges.subscribe(function (value) {
                if (value === 'DISABLED') {
                    tinymce.activeEditor.getBody().setAttribute('readonly', true);
                }
                else if (_this.cData.control.disabled) {
                    tinymce.activeEditor.getBody().setAttribute('readonly', false);
                }
            });
        };
        WysiwygComponent.prototype.ngAfterViewInit = function () {
            this.registerTiny();
        };
        WysiwygComponent.prototype.registerTiny = function () {
            var _this = this;
            tinymce.init({
                target: this.textarea.nativeElement,
                branding: false,
                height: this.cData.height || 420,
                plugins: [
                    'code',
                    'print',
                    'wordcount',
                    'link',
                    'lists',
                    'advlist',
                    'autolink',
                    'image',
                    'imagetools',
                    'fullscreen',
                    'table'
                ],
                menubar: this.cData.menubar || 'edit insert view format table tools help',
                image_advtab: true,
                /**
                 * Link settings
                 */
                default_link_target: '_blank',
                readonly: this.cData.control.disabled,
                toolbar: this.cData.toolbar || [
                    'undo redo',
                    'insert',
                    'styleselect',
                    'bold italic',
                    'forecolor backcolor',
                    'alignleft aligncenter alignright alignjustify',
                    'bullist numlist outdent indent',
                    'link',
                    'image',
                    'youTube',
                    'fullscreen',
                ].join(' | '),
                images_upload_handler: function (blobInfo, success, failure) {
                    _this.storage
                        .upload(blobInfo.filename(), blobInfo.blob(), _this.formBuilderComponent.id ? {
                        customMetadata: {
                            collection: _this.formBuilderComponent.id
                        }
                    } : {})
                        .then(function (data) { return data.ref.getDownloadURL(); })
                        .then(function (url) { return success(url); })
                        .catch(function (error) { return failure(error.toString()); });
                },
                setup: function (editor) {
                    _this.editor = editor;
                    editor.on('keyup change', function () {
                        var tinyContent = editor.getContent();
                        _this.cData.control.setValue(tinyContent);
                    });
                    editor.ui.registry.addButton('youTube', {
                        type: 'button',
                        icon: 'embed',
                        tooltip: 'Embed youtube video',
                        onAction: function () {
                            _this.ytForm.reset(_this.ytDefault);
                            _this.dialog
                                .open(_this.youTubeDialogTemplate, { width: '500px' })
                                .afterClosed()
                                .pipe(operators.filter(function (value) { return !!value; }), operators.take(1))
                                .subscribe(function () {
                                var data = _this.ytForm.getRawValue();
                                var url = data.privacyEnhancedMode
                                    ? 'https://www.youtube-nocookie.com/embed/'
                                    : 'https://www.youtube.com/embed/';
                                url = url + data.value;
                                if (!data.showPlayerControls) {
                                    data.value += '?controls=0';
                                }
                                var iframe = "<iframe width=\"560\" height=\"315\" src=\"" + url + "\" frameborder=\"0\"\n                    allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>";
                                editor.insertContent(data.fullWidth
                                    ? "<div class=\"evw-full\" style=\"text-align: " + data.align + "\">" + iframe + "</div>"
                                    : "<div style=\"text-align: " + data.align + "\">" + iframe + "</div>");
                            });
                        }
                    });
                }
            });
        };
        return WysiwygComponent;
    }(FieldComponent));
    WysiwygComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-wysiwyg',
                    template: "<div class=\"mat-form-field-wrapper\">\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.label\">{{(cData.label || '') | transloco}}</p>\n  <textarea #textarea role=\"textarea\">{{cData.control.value}}</textarea>\n</div>\n\n<ng-template #youTubeDialog>\n  <h1 mat-dialog-title>{{'FIELDS.WYSIWYG.EMBED_YOUTUBE' | transloco}}</h1>\n\n  <form [formGroup]=\"ytForm\">\n    <mat-dialog-content>\n      <mat-form-field class=\"w-full\">\n        <mat-label>{{'FIELDS.WYSIWYG.VIDEO_ID' | transloco}}</mat-label>\n        <input matInput formControlName=\"value\">\n      </mat-form-field>\n\n      <label class=\"mat-form-field-wrapper flex jc-between\">\n        <span>{{'FIELDS.WYSIWYG.FULL_WIDTH' | transloco}}</span>\n        <mat-slide-toggle formControlName=\"fullWidth\"></mat-slide-toggle>\n      </label>\n\n      <label class=\"mat-form-field-wrapper flex jc-between\">\n        <span>{{'FIELDS.WYSIWYG.SHOW_PLAYER_CONTROLS' | transloco}}</span>\n        <mat-slide-toggle formControlName=\"showPlayerControls\"></mat-slide-toggle>\n      </label>\n\n      <label class=\"mat-form-field-wrapper flex jc-between\">\n        <span>{{'FIELDS.WYSIWYG.PRIVACY_ENHANCED_MODE' | transloco}}</span>\n        <mat-slide-toggle formControlName=\"privacyEnhancedMode\"></mat-slide-toggle>\n      </label>\n\n      <mat-form-field class=\"w-full\">\n        <mat-label>{{'FIELDS.WYSIWYG.ALIGNMENT' | transloco}}</mat-label>\n        <mat-select formControlName=\"align\">\n          <mat-option value=\"left\">{{'FIELDS.WYSIWYG.LEFT' | transloco}}</mat-option>\n          <mat-option value=\"center\">{{'FIELDS.WYSIWYG.CENTER' | transloco}}</mat-option>\n          <mat-option value=\"right\">{{'FIELDS.WYSIWYG.RIGHT' | transloco}}</mat-option>\n        </mat-select>\n      </mat-form-field>\n    </mat-dialog-content>\n\n    <mat-dialog-actions class=\"jc-end\">\n      <button mat-button mat-dialog-close>{{'GENERAL.CLOSE' | transloco}}</button>\n      <button mat-raised-button color=\"primary\" [mat-dialog-close]=\"true\">{{'GENERAL.SAVE' | transloco}}</button>\n    </mat-dialog-actions>\n  </form>\n</ng-template>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    styles: [""]
                },] }
    ];
    WysiwygComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: core.Inject, args: [COMPONENT_DATA,] }] },
        { type: forms.FormBuilder },
        { type: dialog.MatDialog },
        { type: StorageService },
        { type: FormBuilderComponent }
    ]; };
    WysiwygComponent.propDecorators = {
        textarea: [{ type: core.ViewChild, args: ['textarea', { static: true },] }],
        youTubeDialogTemplate: [{ type: core.ViewChild, args: ['youTubeDialog', { static: true },] }]
    };

    var _a$1;
    var COMPONENT_TYPE_COMPONENT_MAP = (_a$1 = {},
        _a$1[exports.ComponentType.Input] = InputComponent,
        _a$1[exports.ComponentType.Toggle] = ToggleComponent,
        _a$1[exports.ComponentType.Select] = SelectComponent,
        _a$1[exports.ComponentType.File] = FileComponent,
        _a$1[exports.ComponentType.Image] = ImageComponent,
        _a$1[exports.ComponentType.Gallery] = GalleryComponent,
        _a$1[exports.ComponentType.Checkbox] = CheckboxComponent,
        _a$1[exports.ComponentType.Autocomplete] = AutocompleteComponent,
        _a$1[exports.ComponentType.Date] = DateFieldComponent,
        _a$1[exports.ComponentType.Range] = RangeComponent,
        _a$1[exports.ComponentType.Slider] = SliderComponent,
        _a$1[exports.ComponentType.Wysiwyg] = WysiwygComponent,
        _a$1[exports.ComponentType.Draggable] = DraggableListComponent,
        _a$1[exports.ComponentType.Radio] = RadioComponent,
        _a$1[exports.ComponentType.Chips] = ChipsComponent,
        _a$1[exports.ComponentType.Textarea] = TextareaComponent,
        _a$1);

    (function (SchemaType) {
        SchemaType["Object"] = "object";
        SchemaType["Array"] = "array";
        // Simple
        SchemaType["String"] = "string";
        SchemaType["Number"] = "number";
        SchemaType["Integer"] = "integer";
        SchemaType["Boolean"] = "boolean";
        SchemaType["Null"] = "null";
    })(exports.SchemaType || (exports.SchemaType = {}));

    // @dynamic
    var SchemaValidators = /** @class */ (function () {
        function SchemaValidators() {
        }
        SchemaValidators.multipleOf = function (num) {
            return function (control) {
                return control.value % num === 0 ? null : { multipleOf: num };
            };
        };
        return SchemaValidators;
    }());

    function schemaToComponent(schemaType) {
        switch (schemaType) {
            case exports.SchemaType.String:
                return {
                    type: exports.ComponentType.Input,
                    configuration: {
                        type: 'text'
                    }
                };
            case exports.SchemaType.Number:
            case exports.SchemaType.Integer:
                return {
                    type: exports.ComponentType.Input,
                    configuration: {
                        type: 'number'
                    }
                };
            case exports.SchemaType.Boolean:
                return {
                    type: exports.ComponentType.Checkbox
                };
            case exports.SchemaType.Array:
                return {
                    type: exports.ComponentType.Chips
                };
        }
    }

    // @dynamic
    var Parser = /** @class */ (function () {
        function Parser(schema, injector, state, role, definitions, customFields) {
            if (definitions === void 0) { definitions = {}; }
            if (customFields === void 0) { customFields = {}; }
            this.schema = schema;
            this.injector = injector;
            this.state = state;
            this.role = role;
            this.definitions = definitions;
            this.customFields = customFields;
            this.pointers = {};
        }
        Parser.standardizeKey = function (key) {
            if (key[0] === '/') {
                key = key.slice(1, key.length);
            }
            return key;
        };
        Parser.stringControl = function (definition, required) {
            var controlValidation = [];
            var validation = {};
            if (required) {
                controlValidation.push(forms.Validators.required);
                validation.required = true;
            }
            if (definition.maxLength) {
                controlValidation.push(forms.Validators.maxLength(definition.maxLength));
                validation.maxLength = definition.maxLength;
            }
            if (definition.minLength) {
                controlValidation.push(forms.Validators.minLength(definition.minLength));
                validation.minLength = definition.minLength;
            }
            if (definition.pattern) {
                controlValidation.push(forms.Validators.pattern(definition.pattern));
                validation.patter = definition.pattern;
            }
            return {
                control: new forms.FormControl(definition.default || '', controlValidation),
                validation: validation
            };
        };
        Parser.numberControl = function (definition, required) {
            var validation = {};
            var controlValidation = [];
            if (required) {
                controlValidation.push(forms.Validators.required);
                validation.required = true;
            }
            if (definition.minimum) {
                var minimum = definition.minimum + (definition.exclusiveMinimum ? 1 : 0);
                controlValidation.push(forms.Validators.min(minimum));
                validation.minimum = minimum;
            }
            if (definition.maximum) {
                var maximum = definition.maximum - (definition.exclusiveMaximum ? 1 : 0);
                controlValidation.push(forms.Validators.max(maximum));
                validation.maximum = maximum;
            }
            if (definition.multipleOf) {
                controlValidation.push(SchemaValidators.multipleOf(definition.multipleOf));
                validation.multipleOf = definition.multipleOf;
            }
            return {
                control: new forms.FormControl(definition.default || null, controlValidation),
                validation: validation
            };
        };
        Parser.booleanControl = function (definition, required) {
            var controlValidation = [];
            var validation = {};
            if (required) {
                controlValidation.push(forms.Validators.required);
                validation.required = true;
            }
            return {
                control: new forms.FormControl(definition.default || false, controlValidation),
                validation: validation
            };
        };
        Parser.prototype.buildForm = function (value, required, base, addId) {
            if (required === void 0) { required = []; }
            if (base === void 0) { base = '/'; }
            if (addId === void 0) { addId = true; }
            var properties = this.buildProperties(this.schema.properties || {}, required, base, addId);
            this.form = properties.form;
            this.pointers = properties.pointers;
            if (value) {
                this.form.patchValue(value);
            }
            return this.form;
        };
        Parser.prototype.buildProperties = function (properties, required, base, addId) {
            var _this = this;
            if (required === void 0) { required = []; }
            if (base === void 0) { base = '/'; }
            if (addId === void 0) { addId = true; }
            var _a = __spread(Object.entries(properties), (addId
                ? [
                    [
                        'id',
                        {
                            type: 'string'
                        }
                    ]
                ]
                : [])).reduce(function (group, _a) {
                var _b = __read(_a, 2), key = _b[0], value = _b[1];
                var isRequired = required.includes(key);
                var parsed;
                switch (value.type) {
                    case exports.SchemaType.String:
                        parsed = Parser.stringControl(value, isRequired);
                        break;
                    case exports.SchemaType.Number:
                    case exports.SchemaType.Integer:
                        parsed = Parser.numberControl(value, isRequired);
                        break;
                    case exports.SchemaType.Boolean:
                        parsed = Parser.booleanControl(value, isRequired);
                        break;
                    case exports.SchemaType.Object:
                        var objectProperties = _this.buildProperties(
                        /**
                         * Supporting both {type: 'object', properties: {}} and
                         * {type: 'object', items: {properties: {}}}
                         */
                        value.properties || (value.items && value.items.properties ? value.items.properties : {}), value.required || value.items && value.items.required ? value.items.required : [], base + key + '/', false);
                        for (var added in objectProperties.pointers) {
                            if (objectProperties.pointers.hasOwnProperty(added)) {
                                // @ts-ignore
                                group.pointers[added] = objectProperties.pointers[added];
                            }
                        }
                        parsed = {
                            control: objectProperties.form,
                            validation: {}
                        };
                        break;
                    case exports.SchemaType.Array:
                        parsed = _this.buildArray(base, value);
                        break;
                }
                var pointerKey = base + key;
                var definition = _this.getFromDefinitions(pointerKey) || {};
                // @ts-ignore
                group.form[key] = parsed.control;
                // @ts-ignore
                group.pointers[pointerKey] = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ key: key, type: value.type }, definition.formatOnLoad
                    && { formatOnLoad: safeEval(definition.formatOnLoad) }), definition.formatOnSave
                    && { formatOnSave: safeEval(definition.formatOnSave) }), definition.formatOnCreate
                    && { formatOnCreate: safeEval(definition.formatOnCreate) }), definition.formatOnEdit
                    && { formatOnEdit: safeEval(definition.formatOnEdit) }), parsed);
                return group;
            }, {
                form: {},
                pointers: {}
            }), form = _a.form, pointers = _a.pointers;
            return {
                pointers: pointers,
                form: new forms.FormGroup(form)
            };
        };
        /**
         * @param pointerKey Lookup key for the pointer
         * @param pointer Entire pointer object that should be used
         * @param definitions Entire definitions object that should be used
         * @param single Defines if the field shown in the form or in the table
         * @param arrayRoot If the field is in an array what root lookup to use
         */
        Parser.prototype.field = function (pointerKey, pointer, definitions, single, arrayRoot) {
            if (definitions === void 0) { definitions = {}; }
            if (single === void 0) { single = true; }
            if (!pointer) {
                console.log('Pointers: ', this.pointers);
                throw new Error("Couldn't find pointer for " + pointerKey + ".");
            }
            var key = pointer.key, type = pointer.type, control = pointer.control, validation = pointer.validation;
            var definition = Object.assign({ label: key }, this.getFromDefinitions(pointerKey, definitions));
            if ((definition.disableOn &&
                (Array.isArray(definition.disableOn) ?
                    definition.disableOn.includes(this.state)
                    : definition.disableOn === this.state)) ||
                (definition.disableForRoles &&
                    (Array.isArray(definition.disableForRoles) ?
                        definition.disableForRoles.includes(this.role)
                        : definition.disableForRoles === this.role))) {
                control.disable();
            }
            /**
             * We don't show labels in the table
             */
            if (!single) {
                definition.label = '';
            }
            if (!definition.component) {
                definition.component = schemaToComponent(type);
            }
            // @ts-ignore
            var component = COMPONENT_TYPE_COMPONENT_MAP[definition.component.type] || this.customFields[definition.component.type];
            if (!component) {
                // @ts-ignore
                throw new Error("Couldn't find a component defined for type: " + definition.component.type);
            }
            var portal$1 = new portal.ComponentPortal(component, null, createComponentInjector(this.injector, Object.assign(Object.assign({ control: control,
                validation: validation,
                single: single, pointers: this.pointers, form: this.form }, definition), (definition.component.configuration || {}))));
            return {
                pointer: pointerKey,
                control: control,
                portal: portal$1,
                validation: validation,
                placeholder: definition.placeholder || '',
                label: definition.label,
                onlyOn: definition.onlyOn
            };
        };
        Parser.prototype.addArrayItem = function (pointer, loadHooks, parentArray) {
            if (loadHooks === void 0) { loadHooks = false; }
            var pointers = parentArray ? this.pointers[parentArray.pointer].arrayPointers[parentArray.index] : this.pointers;
            var target = pointers[pointer];
            var control = pointers[pointer].control;
            if (target.arrayType === exports.SchemaType.Array ||
                target.arrayType === exports.SchemaType.Object) {
                var properties = this.buildProperties(target.properties, target.required, pointer + '/', false);
                if (loadHooks) {
                    this.loadHooks(properties.pointers);
                }
                // @ts-ignore
                target.arrayPointers.unshift(properties.pointers);
                control.controls.unshift(properties.form);
                return properties.pointers;
            }
            else {
                var cont = new forms.FormControl('');
                control.controls.unshift(cont);
                return cont;
            }
        };
        Parser.prototype.moveArrayItem = function (pointer, fromIndex, toIndex, parentArray) {
            var pointers = parentArray ? this.pointers[parentArray.pointer].arrayPointers[parentArray.index] : this.pointers;
            var target = pointers[pointer];
            var control = pointers[pointer].control;
            if (target.arrayType === exports.SchemaType.Array ||
                target.arrayType === exports.SchemaType.Object) {
                dragDrop.moveItemInArray(target.arrayPointers, fromIndex, toIndex);
            }
            dragDrop.moveItemInArray(control.controls, fromIndex, toIndex);
        };
        Parser.prototype.removeArrayItem = function (pointer, index, parentArray) {
            var pointers = parentArray ? this.pointers[parentArray.pointer].arrayPointers[parentArray.index] : this.pointers;
            pointers[pointer].arrayPointers.splice(index, 1);
            pointers[pointer].control.removeAt(index);
        };
        Parser.prototype.loadHooks = function (pointers) {
            if (pointers === void 0) { pointers = this.pointers; }
            Object.values(pointers).forEach(function (entry) {
                /**
                 * TODO:
                 * For the moment formatOn methods are
                 * only supported on FormControls.
                 * We might want to expand on this later on.
                 */
                if (entry.control instanceof forms.FormControl && entry.formatOnLoad) {
                    var adjustedValue = entry.formatOnLoad(entry.control.value);
                    if (adjustedValue !== entry.control.value) {
                        entry.control.setValue(adjustedValue);
                    }
                }
            });
        };
        Parser.prototype.preSaveHooks = function (currentState, statesToProcess, pointers) {
            var _this = this;
            if (statesToProcess === void 0) { statesToProcess = [exports.State.Create, exports.State.Edit]; }
            if (pointers === void 0) { pointers = this.pointers; }
            var preSaveData = this.form.getRawValue();
            Object.values(pointers).forEach(function (entry) {
                /**
                 * TODO:
                 * For the moment formatOn methods are
                 * only supported on FormControls.
                 * We might want to expand on this later on.
                 */
                if (entry.control instanceof forms.FormControl) {
                    var value = entry.control.value;
                    if (entry.formatOnSave) {
                        value = entry.formatOnSave(value, preSaveData);
                    }
                    if (statesToProcess.includes(currentState)) {
                        if (currentState === exports.State.Edit && entry.formatOnEdit) {
                            value = entry.formatOnEdit(value, preSaveData);
                        }
                        else if (entry.formatOnCreate) {
                            value = entry.formatOnCreate(value, preSaveData);
                        }
                    }
                    if (value !== entry.control.value) {
                        entry.control.setValue(value);
                    }
                }
                if (entry.arrayPointers) {
                    entry.arrayPointers.forEach(function (arrayPointers) { return _this.preSaveHooks(currentState, statesToProcess, arrayPointers); });
                }
            });
        };
        Parser.prototype.getFromDefinitions = function (key, definitions) {
            if (definitions === void 0) { definitions = this.definitions; }
            return definitions[Parser.standardizeKey(key)];
        };
        /**
         * TODO:
         * - Handle contains case
         * - Handle items or contains as array not object
         */
        Parser.prototype.buildArray = function (base, definition) {
            if (!definition.items) {
                return Object.assign({ control: new forms.FormControl([]) }, (definition.items
                    ? {
                        arrayType: definition.items.type,
                        properties: definition.items.properties,
                        required: definition.items.required,
                        validation: {}
                    }
                    : {
                        arrayType: exports.SchemaType.String,
                        validation: {}
                    }));
            }
            else {
                return {
                    arrayType: definition.items.type,
                    properties: definition.items.properties,
                    required: definition.items.required,
                    validation: {},
                    control: new forms.FormArray([]),
                    arrayPointers: []
                };
            }
        };
        return Parser;
    }());

    var FormBuilderComponent = /** @class */ (function () {
        function FormBuilderComponent(injector, role, customFields, cdr, service) {
            this.injector = injector;
            this.role = role;
            this.customFields = customFields;
            this.cdr = cdr;
            this.service = service;
            this.valueChanges = new core.EventEmitter();
            this.validityChanges = new core.EventEmitter();
            this.state = exports.State.Create;
        }
        FormBuilderComponent.prototype.ngOnChanges = function (changes) {
            if (changes.data) {
                this.render();
            }
            if (changes.value && this.form) {
                this.form.patchValue(changes.value.currentValue);
            }
        };
        FormBuilderComponent.prototype.ngOnDestroy = function () {
            if (this.changeSubscription) {
                this.changeSubscription.unsubscribe();
            }
            if (this.statusSubscription) {
                this.statusSubscription.unsubscribe();
            }
        };
        FormBuilderComponent.prototype.process = function () {
            this.parser.preSaveHooks(this.state);
            return this.form.getRawValue();
        };
        FormBuilderComponent.prototype.save = function (collectionId, documentId) {
            var toExec = this.service.saveComponents.map(function (comp) { return comp.save(collectionId, documentId); });
            return toExec.length ? rxjs.forkJoin(toExec) : rxjs.of({});
        };
        FormBuilderComponent.prototype.saveAndProcess = function (collectionId, documentId) {
            this.process();
            return this.save(collectionId, documentId);
        };
        FormBuilderComponent.prototype.render = function () {
            var _this = this;
            var value = this.data.value || {};
            var definitions = this.data.definitions || {};
            this.parser = new Parser(this.data.schema, this.injector, this.state, this.role, definitions, this.customFields);
            this.form = this.parser.buildForm(value, [], '/', false);
            this.parser.loadHooks();
            this.segments = filterAndCompileSegments(this.data.segments ||
                [{
                        title: '',
                        fields: Object.keys(this.parser.pointers),
                        columnsDesktop: 12,
                        type: exports.SegmentType.Empty
                    }], this.parser, definitions, this.injector, value);
            if (this.changeSubscription) {
                this.changeSubscription.unsubscribe();
            }
            if (this.statusSubscription) {
                this.statusSubscription.unsubscribe();
            }
            this.changeSubscription = this.form.valueChanges
                .subscribe(function (val) {
                _this.valueChanges.emit(val);
            });
            this.statusSubscription = this.form.statusChanges
                .subscribe(function (val) {
                _this.validityChanges.emit(val === 'VALID');
            });
            this.cdr.markForCheck();
        };
        return FormBuilderComponent;
    }());
    FormBuilderComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'fb-form-builder',
                    template: "<div class=\"grid\">\n  <ng-container *ngFor=\"let segment of segments\">\n    <ng-template [cdkPortalOutlet]=\"segment.component\"></ng-template>\n  </ng-container>\n</div>\n",
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    providers: [FormBuilderService]
                },] }
    ];
    FormBuilderComponent.ctorParameters = function () { return [
        { type: core.Injector },
        { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [ROLE,] }] },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [CUSTOM_FIELDS,] }] },
        { type: core.ChangeDetectorRef },
        { type: FormBuilderService }
    ]; };
    FormBuilderComponent.propDecorators = {
        data: [{ type: core.Input }],
        value: [{ type: core.Input }],
        id: [{ type: core.Input }],
        valueChanges: [{ type: core.Output }],
        validityChanges: [{ type: core.Output }],
        state: [{ type: core.Input }]
    };

    var DropzoneDirective = /** @class */ (function () {
        function DropzoneDirective(el, renderer) {
            this.el = el;
            this.renderer = renderer;
            this.hoverClass = 'active';
            this.dropped = new core.EventEmitter();
            this.hovered = new core.EventEmitter();
        }
        DropzoneDirective.prototype.onDrop = function ($event) {
            $event.preventDefault();
            this.dropped.emit($event.dataTransfer.files);
            this.renderer.removeClass(this.el.nativeElement, this.hoverClass);
            this.hovered.emit(false);
        };
        DropzoneDirective.prototype.onDragOver = function ($event) {
            $event.preventDefault();
            this.renderer.addClass(this.el.nativeElement, this.hoverClass);
            this.hovered.emit(true);
        };
        DropzoneDirective.prototype.onDragLeave = function ($event) {
            $event.preventDefault();
            this.renderer.removeClass(this.el.nativeElement, this.hoverClass);
            this.hovered.emit(false);
        };
        return DropzoneDirective;
    }());
    DropzoneDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[fbDropzone]'
                },] }
    ];
    DropzoneDirective.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 }
    ]; };
    DropzoneDirective.propDecorators = {
        hoverClass: [{ type: core.Input }],
        dropped: [{ type: core.Output }],
        hovered: [{ type: core.Output }],
        onDrop: [{ type: core.HostListener, args: ['drop', ['$event'],] }],
        onDragOver: [{ type: core.HostListener, args: ['dragover', ['$event'],] }],
        onDragLeave: [{ type: core.HostListener, args: ['dragleave', ['$event'],] }]
    };

    var ShowFieldPipe = /** @class */ (function () {
        function ShowFieldPipe() {
        }
        ShowFieldPipe.prototype.transform = function (fields, parser) {
            return fields.filter(function (field) { return !field.onlyOn ||
                (Array.isArray(field.onlyOn) ?
                    field.onlyOn.includes(parser.state) :
                    field.onlyOn === parser.state); });
        };
        return ShowFieldPipe;
    }());
    ShowFieldPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'showField'
                },] }
    ];

    var FormBuilderModule = /** @class */ (function () {
        function FormBuilderModule() {
        }
        return FormBuilderModule;
    }());
    FormBuilderModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [
                        /**
                         * Fields
                         */
                        FieldComponent,
                        AutocompleteComponent,
                        CheckboxComponent,
                        ChipsComponent,
                        DateFieldComponent,
                        RangeComponent,
                        DraggableListComponent,
                        FileComponent,
                        GalleryComponent,
                        ImageComponent,
                        InputComponent,
                        RadioComponent,
                        SelectComponent,
                        SliderComponent,
                        TextareaComponent,
                        ToggleComponent,
                        WysiwygComponent,
                        /**
                         * Segments
                         */
                        SegmentComponent,
                        AccordionComponent,
                        CardComponent,
                        EmptyComponent,
                        StepperComponent,
                        TabsComponent,
                        /**
                         * Directives
                         */
                        DropzoneDirective,
                        /**
                         * Pipes
                         */
                        ShowFieldPipe,
                        FormBuilderComponent
                    ],
                    imports: [
                        common.CommonModule,
                        forms.ReactiveFormsModule,
                        /**
                         * Material
                         */
                        formField.MatFormFieldModule,
                        input.MatInputModule,
                        button.MatButtonModule,
                        autocomplete.MatAutocompleteModule,
                        select.MatSelectModule,
                        slider.MatSliderModule,
                        slideToggle.MatSlideToggleModule,
                        checkbox.MatCheckboxModule,
                        chips.MatChipsModule,
                        icon.MatIconModule,
                        datepicker.MatDatepickerModule,
                        core$1.MatNativeDateModule,
                        dragDrop.DragDropModule,
                        dialog.MatDialogModule,
                        tooltip.MatTooltipModule,
                        progressSpinner.MatProgressSpinnerModule,
                        expansion.MatExpansionModule,
                        divider.MatDividerModule,
                        portal.PortalModule,
                        card.MatCardModule,
                        tabs.MatTabsModule,
                        radio.MatRadioModule,
                        /**
                         * Jp Helpers
                         */
                        ngHelpers.SanitizeModule,
                        /**
                         * Other
                         */
                        transloco.TranslocoModule
                    ],
                    exports: [FormBuilderComponent]
                },] }
    ];

    /**
     * Public API Surface of form-builder
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.ADDITIONAL_CONTEXT = ADDITIONAL_CONTEXT;
    exports.COMPONENT_DATA = COMPONENT_DATA;
    exports.CUSTOM_FIELDS = CUSTOM_FIELDS;
    exports.DbService = DbService;
    exports.FieldComponent = FieldComponent;
    exports.FormBuilderComponent = FormBuilderComponent;
    exports.FormBuilderModule = FormBuilderModule;
    exports.FormBuilderService = FormBuilderService;
    exports.Parser = Parser;
    exports.ROLE = ROLE;
    exports.STORAGE_URL = STORAGE_URL;
    exports.StorageService = StorageService;
    exports.cloneAbstractControl = cloneAbstractControl;
    exports.formatFileName = formatFileName;
    exports.formatGeneratedImages = formatGeneratedImages;
    exports.parseTemplate = parseTemplate;
    exports.safeEval = safeEval;
    exports.switchItemLocations = switchItemLocations;
    exports.a = AutocompleteComponent;
    exports.b = CheckboxComponent;
    exports.c = ChipsComponent;
    exports.d = DateFieldComponent;
    exports.e = RangeComponent;
    exports.f = DraggableListComponent;
    exports.g = FileComponent;
    exports.h = GalleryComponent;
    exports.i = ImageComponent;
    exports.j = InputComponent;
    exports.k = RadioComponent;
    exports.l = SelectComponent;
    exports.m = SliderComponent;
    exports.n = TextareaComponent;
    exports.o = ToggleComponent;
    exports.p = WysiwygComponent;
    exports.q = SegmentComponent;
    exports.r = SEGMENT_DATA;
    exports.s = AccordionComponent;
    exports.t = CardComponent;
    exports.u = EmptyComponent;
    exports.v = StepperComponent;
    exports.w = TabsComponent;
    exports.x = DropzoneDirective;
    exports.y = ShowFieldPipe;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=jaspero-form-builder.umd.js.map
