import { Injectable, InjectionToken, Component, Inject, Injector, HostBinding, ChangeDetectionStrategy, ChangeDetectorRef, ViewChild, Optional, EventEmitter, Input, Output, Directive, ElementRef, Renderer2, HostListener, Pipe, NgModule } from '@angular/core';
import { throwError, of, BehaviorSubject, from, Observable, forkJoin } from 'rxjs';
import { MatSnackBar } from '@angular/material/snack-bar';
import { TranslocoService, TranslocoModule } from '@ngneat/transloco';
import { tap, catchError, map, switchMap, startWith, filter, take } from 'rxjs/operators';
import { PortalInjector, ComponentPortal, PortalModule } from '@angular/cdk/portal';
import { moveItemInArray, CdkDropListGroup, CdkDropList, DragDropModule } from '@angular/cdk/drag-drop';
import { get } from 'json-pointer';
import { FormGroup, FormArray, FormControl, Validators, FormBuilder, ReactiveFormsModule } from '@angular/forms';
import { DatePipe, CommonModule } from '@angular/common';
import { ViewportRuler } from '@angular/cdk/overlay';
import { HttpClient } from '@angular/common/http';
import { MatDialog, MatDialogModule } from '@angular/material/dialog';
import { DomSanitizer } from '@angular/platform-browser';
import 'tinymce/plugins/code';
import 'tinymce/plugins/print';
import 'tinymce/plugins/wordcount';
import 'tinymce/plugins/link';
import 'tinymce/plugins/image';
import 'tinymce/plugins/imagetools';
import 'tinymce/plugins/fullscreen';
import 'tinymce/plugins/lists';
import 'tinymce/plugins/autolink';
import 'tinymce/plugins/advlist';
import 'tinymce/plugins/table';
import { MatAutocompleteModule } from '@angular/material/autocomplete';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatChipsModule } from '@angular/material/chips';
import { MatNativeDateModule } from '@angular/material/core';
import { MatDatepickerModule } from '@angular/material/datepicker';
import { MatDividerModule } from '@angular/material/divider';
import { MatExpansionModule } from '@angular/material/expansion';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatIconModule } from '@angular/material/icon';
import { MatInputModule } from '@angular/material/input';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatRadioModule } from '@angular/material/radio';
import { MatSelectModule } from '@angular/material/select';
import { MatSlideToggleModule } from '@angular/material/slide-toggle';
import { MatSliderModule } from '@angular/material/slider';
import { MatTabsModule } from '@angular/material/tabs';
import { MatTooltipModule } from '@angular/material/tooltip';
import { SanitizeModule } from '@jaspero/ng-helpers';

var SegmentType;
(function (SegmentType) {
    SegmentType["Empty"] = "empty";
    SegmentType["Card"] = "card";
    SegmentType["Accordion"] = "accordion";
    SegmentType["Tabs"] = "tabs";
    SegmentType["Stepper"] = "stepper";
})(SegmentType || (SegmentType = {}));

var State;
(function (State) {
    State["Create"] = "create";
    State["Edit"] = "edit";
})(State || (State = {}));

class FormBuilderService {
    constructor(transloco, snackBar) {
        this.transloco = transloco;
        this.snackBar = snackBar;
        /**
         * Array of components that need to
         * run save() methods on single instance
         */
        this.saveComponents = [];
    }
    notify(options = {}) {
        const finalOptions = Object.assign({ success: 'GENERAL.OPERATION_COMPLETED', error: 'GENERAL.OPERATION_FAILED' }, options);
        return (source$) => {
            return source$.pipe(tap(() => {
                if (finalOptions.success) {
                    this.snackBar.open(this.transloco.translate(finalOptions.success), this.transloco.translate('GENERAL.DISMISS'), {
                        duration: 5000
                    });
                }
            }), catchError(err => {
                if (finalOptions.error) {
                    this.snackBar.open(this.transloco.translate(finalOptions.error), this.transloco.translate('GENERAL.DISMISS'), {
                        panelClass: 'snack-bar-error',
                        duration: 5000
                    });
                }
                console.error(err);
                return throwError(err);
            }));
        };
    }
}
FormBuilderService.decorators = [
    { type: Injectable }
];
FormBuilderService.ctorParameters = () => [
    { type: TranslocoService },
    { type: MatSnackBar }
];

const CUSTOM_FIELDS = new InjectionToken('CUSTOM_FIELDS');

const SEGMENT_DATA = new InjectionToken('SEGMENT_DATA');
function createSegmentInjector(injector, dataToPass) {
    const injectorTokens = new WeakMap();
    injectorTokens.set(SEGMENT_DATA, dataToPass);
    return new PortalInjector(injector, injectorTokens);
}

class SegmentComponent {
    constructor(sData, injector) {
        this.sData = sData;
        this.injector = injector;
        this.nestedArraySegments = [];
        this.arrayFields = [];
    }
    ngOnInit() {
        this.segment = this.sData.segment;
        this.classes = this.sData.segment.classes.join(' ');
        this.pointers = this.sData.parser.pointers;
        this.id = this.sData.segment.id || '';
        /**
         * Each segment compiles all nested segments
         */
        this.nestedSegments = filterAndCompileSegments(this.sData.segment.nestedSegments || [], this.sData.parser, this.sData.definitions, this.injector, this.segment.entryValue);
        const array = this.segment.array;
        /**
         * Add array items if necessary
         */
        if (array && this.segment.entryValue) {
            let values;
            try {
                values = get(this.segment.entryValue, array);
            }
            catch (e) { }
            if (values) {
                values.forEach(() => this.addArrayItem(false));
                this.pointers[array].control.patchValue(values);
                for (let i = 0; i < values.length; i++) {
                    // @ts-ignore
                    this.sData.parser.loadHooks(this.pointers[array].arrayPointers[i]);
                }
            }
        }
    }
    addArrayItem(loadHook = true) {
        const array = this.segment.array;
        const pointers = this.sData.parser.addArrayItem((this.sData.parent || '') + array, loadHook, this.sData.parent ? {
            pointer: this.sData.parent,
            index: 0
        } : undefined);
        let fields;
        if (this.segment.fields && this.segment.fields.length) {
            fields = this.segment.fields.map(key => {
                key = (this.sData.parent || '') + key;
                return this.sData.parser.field(key, pointers[key], this.sData.definitions, true, array);
            });
        }
        else {
            fields = [this.sData.parser.field(array, Object.assign(Object.assign({}, this.pointers[array]), { control: pointers }), this.sData.definitions)];
        }
        this.arrayFields.unshift(fields);
        this.nestedArraySegments.unshift(this.nestedSegments = filterAndCompileSegments(this.sData.segment.nestedSegments || [], this.sData.parser, this.sData.definitions, this.injector, this.segment.entryValue, this.segment.array));
    }
    moveArray(up, fromIndex) {
        let toIndex;
        if (up) {
            toIndex = fromIndex === 0 ? this.arrayFields.length - 1 : fromIndex - 1;
        }
        else {
            toIndex = fromIndex === (this.arrayFields.length - 1) ? 0 : fromIndex + 1;
        }
        moveItemInArray(this.arrayFields, fromIndex, toIndex);
        moveItemInArray(this.nestedArraySegments, fromIndex, toIndex);
        this.sData.parser.moveArrayItem((this.sData.parent || '') + this.segment.array, fromIndex, toIndex, this.sData.parent ? {
            pointer: this.sData.parent,
            index: 0
        } : undefined);
    }
    removeArrayItem(index) {
        this.sData.parser.removeArrayItem((this.sData.parent || '') + this.segment.array, index, this.sData.parent ? {
            pointer: this.sData.parent,
            index: 0
        } : undefined);
        this.nestedArraySegments.splice(index, 1);
        this.arrayFields.splice(index, 1);
    }
}
SegmentComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-segment',
                template: ''
            },] }
];
SegmentComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [SEGMENT_DATA,] }] },
    { type: Injector }
];
SegmentComponent.propDecorators = {
    classes: [{ type: HostBinding, args: ['class',] }],
    id: [{ type: HostBinding, args: ['id',] }]
};

class AccordionComponent extends SegmentComponent {
    ngOnInit() {
        super.ngOnInit();
        this.accordions = (this.sData.segment.configuration || []).map((accord) => ({
            title: accord.title,
            fields: (accord.fields || []).map(key => this.sData.parser.field(key, this.pointers[key], this.sData.definitions)),
            nestedSegments: filterAndCompileSegments(accord.nestedSegments || [], this.sData.parser, this.sData.definitions, this.injector, this.segment.entryValue)
        }));
    }
}
AccordionComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-accordion',
                template: "<ng-container *ngIf=\"segment.title || segment.subTitle\">\n  <h4 *ngIf=\"segment.title\">{{segment.title}}</h4>\n  <h5 *ngIf=\"segment.subTitle\">{{segment.subTitle}}</h5>\n  <div class=\"p-y-m\">\n    <mat-divider></mat-divider>\n  </div>\n</ng-container>\n\n<p *ngIf=\"segment.description\">{{segment.description}}</p>\n\n<mat-accordion>\n  <mat-expansion-panel *ngFor=\"let accord of accordions\" [expanded]=\"accord.expanded || false\">\n    <mat-expansion-panel-header>\n      <mat-panel-title *ngIf=\"accord.title\">{{accord.title}}</mat-panel-title>\n      <mat-panel-description *ngIf=\"accord.description\">\n        {{accord.description}}\n      </mat-panel-description>\n    </mat-expansion-panel-header>\n\n    <ng-container *ngFor=\"let field of accord.fields | showField:sData.parser\">\n      <ng-template [cdkPortalOutlet]=\"field.portal\"></ng-template>\n    </ng-container>\n\n    <ng-container *ngFor=\"let nested of accord.nestedSegments\">\n      <ng-template [cdkPortalOutlet]=\"nested.component\"></ng-template>\n    </ng-container>\n  </mat-expansion-panel>\n</mat-accordion>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            },] }
];

class CardComponent extends SegmentComponent {
    get fields() {
        return this.segment.fields;
    }
}
CardComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-card',
                template: "<mat-card>\n  <mat-card-header *ngIf=\"segment.title || segment.subTitle || segment.array\">\n    <div>\n      <h1 *ngIf=\"segment.title\">{{segment.title}}</h1>\n      <h2 class=\"fs-small\" *ngIf=\"segment.subTitle\">{{segment.subTitle}}</h2>\n    </div>\n    <div class=\"flex-1\"></div>\n    <button *ngIf=\"segment.array\" mat-icon-button (click)=\"addArrayItem()\" [matTooltip]=\"'GENERAL.ADD' | transloco\">\n      <mat-icon>add</mat-icon>\n    </button>\n  </mat-card-header>\n\n  <mat-card-content>\n    <div class=\"fb-fields\">\n      <p class=\"mat-form-field-wrapper\" *ngIf=\"segment.description\">{{segment.description}}</p>\n\n      <ng-container *ngIf=\"segment.array; else regular\">\n        <ng-container *ngFor=\"let fields of arrayFields; index as index; last as last\">\n          <ng-container *ngFor=\"let field of fields | showField:sData.parser\">\n            <ng-template [cdkPortalOutlet]=\"field.portal\"></ng-template>\n          </ng-container>\n\n          <div class=\"fb-field-12\" *ngFor=\"let nested of (nestedArraySegments[index] || [])\">\n            <ng-template [cdkPortalOutlet]=\"nested.component\"></ng-template>\n          </div>\n\n          <div class=\"ta-right fb-field-12\">\n            <button mat-icon-button (click)=\"moveArray(true, index)\">\n              <mat-icon>arrow_upward</mat-icon>\n            </button>\n            &nbsp;\n            <button mat-icon-button (click)=\"moveArray(false, index)\">\n              <mat-icon>arrow_downward</mat-icon>\n            </button>\n            &nbsp;\n            <button mat-icon-button color=\"warn\" (click)=\"removeArrayItem(index)\">\n              <mat-icon>delete_forever</mat-icon>\n            </button>\n          </div>\n          <hr *ngIf=\"!last\" class=\"fb-field-12 m-y-m nested-divider\">\n        </ng-container>\n      </ng-container>\n\n      <ng-template #regular>\n        <ng-container *ngFor=\"let field of fields | showField:sData.parser\">\n          <ng-template [cdkPortalOutlet]=\"field.portal\"></ng-template>\n        </ng-container>\n\n        <ng-container *ngFor=\"let nested of nestedSegments\">\n          <ng-template [cdkPortalOutlet]=\"nested.component\"></ng-template>\n        </ng-container>\n      </ng-template>\n    </div>\n  </mat-card-content>\n</mat-card>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".nested-divider{margin-left:-16px;margin-right:-16px}"]
            },] }
];

class EmptyComponent extends SegmentComponent {
    get fields() {
        return this.segment.fields;
    }
}
EmptyComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-empty',
                template: "<ng-container *ngIf=\"segment.title || segment.subTitle\">\n  <div class=\"flex jc-between\">\n    <div>\n      <h4 *ngIf=\"segment.title\">{{segment.title}}</h4>\n      <h5 *ngIf=\"segment.subTitle\">{{segment.subTitle}}</h5>\n    </div>\n    <button *ngIf=\"segment.array\" mat-icon-button (click)=\"addArrayItem()\" [matTooltip]=\"'GENERAL.ADD' | transloco\">\n      <mat-icon>add</mat-icon>\n    </button>\n  </div>\n  <div class=\"p-y-m\">\n    <mat-divider></mat-divider>\n  </div>\n</ng-container>\n\n<div class=\"fb-fields panel\">\n  <p *ngIf=\"segment.description\">{{segment.description}}</p>\n\n  <ng-container *ngIf=\"segment.array; else regular\">\n    <ng-container *ngFor=\"let fields of arrayFields; index as index; last as last\">\n      <ng-container *ngFor=\"let field of fields | showField:sData.parser\">\n        <ng-template [cdkPortalOutlet]=\"field.portal\"></ng-template>\n      </ng-container>\n\n      <div class=\"fb-field-12\" *ngFor=\"let nested of (nestedArraySegments[index] || [])\">\n        <ng-template [cdkPortalOutlet]=\"nested.component\"></ng-template>\n      </div>\n\n      <div class=\"ta-right fb-field-12\">\n        <button mat-icon-button (click)=\"moveArray(true, index)\">\n          <mat-icon>arrow_upward</mat-icon>\n        </button>\n        &nbsp;\n        <button mat-icon-button (click)=\"moveArray(false, index)\">\n          <mat-icon>arrow_downward</mat-icon>\n        </button>\n        &nbsp;\n        <button mat-icon-button color=\"warn\" (click)=\"removeArrayItem(index)\">\n          <mat-icon>delete_forever</mat-icon>\n        </button>\n      </div>\n      <hr *ngIf=\"!last\" class=\"fb-field-12 m-y-m nested-divider\">\n    </ng-container>\n  </ng-container>\n\n  <ng-template #regular>\n    <ng-container *ngFor=\"let field of fields | showField:sData.parser\">\n      <ng-template [cdkPortalOutlet]=\"field.portal\"></ng-template>\n    </ng-container>\n\n    <ng-container *ngFor=\"let nested of nestedSegments\">\n      <ng-template [cdkPortalOutlet]=\"nested.component\"></ng-template>\n    </ng-container>\n  </ng-template>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".nested-divider{margin-left:-16px;margin-right:-16px}"]
            },] }
];

class StepperComponent extends SegmentComponent {
}
StepperComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-stepper',
                template: "<p>\n  stepper works!\n</p>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            },] }
];

function safeEval(method) {
    let final;
    try {
        // tslint:disable-next-line:no-eval
        final = eval(method);
    }
    catch (e) { }
    return final;
}

class TabsComponent extends SegmentComponent {
    get configuration() {
        return this.segment.configuration;
    }
    ngOnInit() {
        super.ngOnInit();
        if (this.configuration.selectedTabChange) {
            this.selectedTabChange = safeEval(this.configuration.selectedTabChange);
        }
        this.tabs = this.configuration.tabs.map(tab => (Object.assign(Object.assign({}, tab), { fields: (tab.fields || []).map(key => this.sData.parser.field(key, this.pointers[key], this.sData.definitions)), nestedSegments: filterAndCompileSegments(tab.nestedSegments || [], this.sData.parser, this.sData.definitions, this.injector, this.segment.entryValue) })));
    }
    tabChange(event) {
        if (this.selectedTabChange) {
            this.selectedTabChange(event, this.sData);
        }
    }
}
TabsComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-tabs',
                template: "<ng-container *ngIf=\"segment.title || segment.subTitle\">\n  <h4 *ngIf=\"segment.title\">{{segment.title}}</h4>\n  <h5 *ngIf=\"segment.subTitle\">{{segment.subTitle}}</h5>\n  <div class=\"p-y-m\">\n    <mat-divider></mat-divider>\n  </div>\n</ng-container>\n\n<p *ngIf=\"segment.description\">{{segment.description}}</p>\n\n<mat-tab-group\n  [selectedIndex]=\"configuration.selectedIndex\"\n  [dynamicHeight]=\"configuration.dynamicHeight\"\n  [disableRipple]=\"configuration.disableRipple\"\n  [attr.mat-align-tabs]=\"configuration.alignment\"\n  (selectedTabChange)=\"tabChange($event)\">\n\n  <mat-tab\n    *ngFor=\"let tab of tabs\"\n    [label]=\"tab.title\"\n    [disabled]=\"tab.disabled\">\n\n    <div class=\"p-a-s\">\n      <ng-container *ngFor=\"let field of tab.fields | showField:sData.parser\">\n        <ng-template [cdkPortalOutlet]=\"field.portal\"></ng-template>\n      </ng-container>\n    </div>\n\n    <ng-container *ngFor=\"let nested of tab.nestedSegments\">\n      <ng-template [cdkPortalOutlet]=\"nested.component\"></ng-template>\n    </ng-container>\n  </mat-tab>\n</mat-tab-group>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            },] }
];

const SEGMENT_TYPE_COMPONENT_MAP = {
    [SegmentType.Empty]: EmptyComponent,
    [SegmentType.Card]: CardComponent,
    [SegmentType.Accordion]: AccordionComponent,
    [SegmentType.Tabs]: TabsComponent,
    [SegmentType.Stepper]: StepperComponent
};

var ConditionType;
(function (ConditionType) {
    ConditionType["Function"] = "function";
    ConditionType["Statement"] = "statement";
})(ConditionType || (ConditionType = {}));
var ConditionAction;
(function (ConditionAction) {
    ConditionAction["Show"] = "show";
    ConditionAction["Hide"] = "hide";
})(ConditionAction || (ConditionAction = {}));
var ConditionEvaluate;
(function (ConditionEvaluate) {
    ConditionEvaluate["OnLoad"] = "onLoad";
    ConditionEvaluate["OnChange"] = "onChange";
})(ConditionEvaluate || (ConditionEvaluate = {}));

function compileSegment(segment, parser, definitions, injector, entryValue, parent = '') {
    const classes = [];
    let fields = [];
    if (segment.columnsDesktop) {
        classes.push(`col-${segment.columnsDesktop}`);
    }
    if (segment.columnsTablet) {
        classes.push(`col-m-${segment.columnsTablet}`);
    }
    if (segment.columnsMobile) {
        classes.push(`col-s-${segment.columnsMobile}`);
    }
    /**
     * If there aren't any column definitions
     * default to full width
     */
    if (!classes.length) {
        classes.push('col-12');
    }
    if (segment.classes) {
        classes.push(...segment.classes);
    }
    if (segment.fields) {
        /**
         * If it's an array fields aren' parsed
         */
        if (segment.array) {
            // @ts-ignore
            fields = (segment.fields || []).map(fi => segment.array + fi);
        }
        else {
            fields = (segment.fields || [])
                // @ts-ignore
                .reduce((acc, key) => {
                const definition = parser.getFromDefinitions(key, definitions);
                if (!definition ||
                    !definition.roles ||
                    (typeof definition.roles === 'string' ?
                        definition.roles === parser.role :
                        definition.roles.includes(parser.role))) {
                    acc.push(parser.field(key, parser.pointers[key], definitions));
                }
                return acc;
            }, []);
        }
    }
    const compiledSegment = Object.assign(Object.assign({}, segment), { classes,
        fields,
        entryValue });
    /**
     * TODO:
     * Statement support
     */
    if (segment.conditions) {
        compiledSegment.conditions = [];
        const valToPass = entryValue || {};
        for (const cur of segment.conditions) {
            let condition;
            const type = cur.type || ConditionType.Function;
            const action = cur.action || ConditionAction.Show;
            const evaluateOn = cur.evaluateOn || ConditionEvaluate.OnLoad;
            const evaluateStates = cur.evaluateStates || [0, 1, 2];
            if (cur.condition) {
                condition = safeEval(cur.condition);
            }
            if (condition) {
                /**
                 * Evaluate on load conditions
                 */
                if (evaluateOn === ConditionEvaluate.OnLoad) {
                    /**
                     * Check if items should be excluded right away
                     */
                    if ((action === ConditionAction.Show && !condition(valToPass)) ||
                        (action === ConditionAction.Hide && condition(valToPass))) {
                        return null;
                    }
                }
                compiledSegment.conditions.push(Object.assign({ condition,
                    type,
                    action,
                    evaluateStates,
                    evaluateOn }, cur.data && {
                    data: cur.data
                }));
            }
        }
    }
    return Object.assign({ component: new ComponentPortal(SEGMENT_TYPE_COMPONENT_MAP[segment.type || SegmentType.Card], null, createSegmentInjector(injector, Object.assign({ segment: compiledSegment, parser,
            definitions }, parent && { parent }))) }, compiledSegment);
}

function filterAndCompileSegments(segments, parser, definitions, injector, value, parent) {
    return segments.reduce((acc, cur) => {
        if (!cur.authorization || cur.authorization.includes(parser.role)) {
            const compiled = compileSegment(cur, parser, definitions, injector, value, parent);
            if (compiled) {
                acc.push(
                // @ts-ignore
                compiled);
            }
        }
        return acc;
    }, []);
}

var ComponentType;
(function (ComponentType) {
    ComponentType["Input"] = "input";
    ComponentType["Select"] = "select";
    ComponentType["File"] = "file";
    ComponentType["Image"] = "image";
    ComponentType["Gallery"] = "gallery";
    ComponentType["Toggle"] = "toggle";
    ComponentType["Checkbox"] = "checkbox";
    ComponentType["Date"] = "date";
    ComponentType["Range"] = "range";
    ComponentType["Radio"] = "radio";
    ComponentType["Slider"] = "slider";
    ComponentType["Autocomplete"] = "autocomplete";
    ComponentType["Wysiwyg"] = "wysiwyg";
    ComponentType["Chips"] = "chips";
    ComponentType["Draggable"] = "draggable";
    ComponentType["Textarea"] = "textarea";
})(ComponentType || (ComponentType = {}));

class DbService {
    getDocuments(moduleId, pageSize, sort, cursor, filters) {
        return of([]);
    }
    getDocumentsSimple(moduleId, orderBy, filter) {
        return of([]);
    }
    getStateChanges(moduleId, pageSize, sort, cursor, filters) {
        return of([]);
    }
    getDocument(moduleId, documentId, stream = false) {
        return of();
    }
    setDocument(moduleId, documentId, data, options) {
        return of();
    }
    removeDocument(moduleId, documentId) {
        return of();
    }
    createUserAccount(email, password) {
        return of();
    }
    removeUserAccount(id) {
        return of();
    }
}

const COMPONENT_DATA = new InjectionToken('COMPONENT_DATA');
function createComponentInjector(injector, dataToPass) {
    const injectorTokens = new WeakMap();
    injectorTokens.set(COMPONENT_DATA, dataToPass);
    return new PortalInjector(injector, injectorTokens);
}

// @dynamic
class FieldComponent {
    constructor(cData) {
        this.cData = cData;
        const classes = [
            `fb-field-${this.cData.columnsDesktop || 12}`
        ];
        if (this.cData.columnsTablet) {
            classes.push(`m-fb-field-${this.cData.columnsTablet}`);
        }
        if (this.cData.columnsMobile) {
            classes.push(`s-fb-field-${this.cData.columnsMobile}`);
        }
        if (this.cData.class) {
            classes.push(this.cData.class);
        }
        this.class = classes.join(' ');
    }
}
FieldComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-field',
                template: ''
            },] }
];
FieldComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [COMPONENT_DATA,] }] }
];
FieldComponent.propDecorators = {
    class: [{ type: HostBinding, args: ['class',] }]
};

function getHsd(key, data) {
    if (data[key]) {
        let item;
        switch (data[key].type) {
            case 'dynamic':
                item = safeEval(data[key].value);
                if (item) {
                    return data.form.valueChanges
                        .pipe(map(value => item(data.control.value, value)));
                }
                break;
            case 'static':
                item = safeEval(data[key].value);
                if (item) {
                    return of(item(data.control.value, data.form.getRawValue()));
                }
                break;
            case 'html':
            default:
                return of(data[key].value);
        }
    }
    return of('');
}

class AutocompleteComponent extends FieldComponent {
    constructor(cData, dbService) {
        super(cData);
        this.cData = cData;
        this.dbService = dbService;
        this.loading$ = new BehaviorSubject(true);
    }
    ngOnInit() {
        this.prefix$ = getHsd('prefix', this.cData);
        this.suffix$ = getHsd('suffix', this.cData);
        let dataSet$;
        if (this.cData.populate) {
            const { populate } = this.cData;
            dataSet$ = this.dbService
                .getDocumentsSimple(this.cData.populate.collection, this.cData.populate.orderBy, this.cData.populate.filter)
                .pipe(map(docs => docs.map(doc => ({
                value: doc[populate.valueKey || 'id'],
                name: doc[populate.nameKey]
            }))), tap(() => this.loading$.next(false)));
        }
        else {
            dataSet$ = of(this.cData.dataSet);
        }
        this.filteredSet$ = dataSet$.pipe(switchMap(dataSet => this.cData.control.valueChanges.pipe(startWith(this.cData.control.value), map(value => {
            if (!value) {
                return dataSet;
            }
            value = value.toLowerCase();
            return dataSet.filter(item => item.name.toLowerCase().includes(value));
        }))));
    }
}
AutocompleteComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-autocomplete',
                template: "<mat-form-field appearance=\"outline\" class=\"w-full\">\n  <mat-label>{{(cData.label || '') | transloco}}</mat-label>\n  <input\n    matInput\n    [placeholder]=\"(cData.placeholder || '') | transloco\"\n    [attr.autocomplete]=\"cData.autocomplete || 'on'\"\n    [formControl]=\"cData.control\"\n    [matAutocomplete]=\"auto\">\n  <mat-autocomplete #auto=\"matAutocomplete\">\n    <mat-option *ngFor=\"let data of filteredSet$ | async\" [value]=\"data.value\">\n      {{data.name}}\n    </mat-option>\n  </mat-autocomplete>\n  <mat-hint *ngIf=\"cData.hint\" [innerHTML]=\"cData.hint | jpSanitize\"></mat-hint>\n  <span *ngIf=\"cData.suffix\" matSuffix [innerHTML]=\"((suffix$ | async) || '') | jpSanitize\"></span>\n  <span *ngIf=\"cData.prefix\" matPrefix [innerHTML]=\"((prefix$ | async) || '') | jpSanitize\"></span>\n</mat-form-field>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            },] }
];
AutocompleteComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [COMPONENT_DATA,] }] },
    { type: DbService }
];

class CheckboxComponent extends FieldComponent {
}
CheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-checkbox',
                template: "<div class=\"mat-form-field-wrapper\">\n  <mat-checkbox [formControl]=\"cData.control\">\n    <mat-label>{{cData.label | transloco}}</mat-label>\n  </mat-checkbox>\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.hint\">\n    {{cData.hint | transloco}}\n  </p>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            },] }
];

class ChipsComponent extends FieldComponent {
    constructor() {
        super(...arguments);
        this.data = [];
    }
    ngOnInit() {
        this.data = this.cData.control.value;
        this.removable = this.cData.hasOwnProperty('removable') ? this.cData.removable : true;
        this.prefix$ = getHsd('prefix', this.cData);
        this.suffix$ = getHsd('suffix', this.cData);
    }
    add(event) {
        const value = (event.value || '').trim();
        const input = event.input;
        if (value && (this.cData.unique ? !this.data.includes(value) : true)) {
            this.data.push(value);
            this.cData.control.setValue(this.data);
        }
        if (input) {
            input.value = '';
        }
    }
    remove(chip) {
        const index = this.cData.control.value.indexOf(chip);
        if (index >= 0) {
            this.data.splice(index, 1);
            this.cData.control.setValue(this.data);
        }
    }
}
ChipsComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-chips',
                template: "<mat-form-field class=\"w-full\" appearance=\"outline\">\n  <mat-label>{{(cData.label || '') | transloco}}</mat-label>\n  <mat-chip-list #chipList>\n    <mat-chip\n      *ngFor=\"let chip of data\"\n      [selectable]=\"cData.selectable\"\n      [removable]=\"removable\"\n      (removed)=\"remove(chip)\">\n      {{chip}}\n      <mat-icon *ngIf=\"removable\" matChipRemove>cancel</mat-icon>\n    </mat-chip>\n    <input\n      matInput\n      [attr.autocomplete]=\"cData.autocomplete || 'on'\"\n      [placeholder]=\"(cData.placeholder || '') | transloco\"\n      (matChipInputTokenEnd)=\"add($event)\"\n      [matChipInputFor]=\"chipList\">\n  </mat-chip-list>\n  <span *ngIf=\"cData.suffix\" matSuffix [innerHTML]=\"((suffix$ | async) || '') | jpSanitize\"></span>\n  <span *ngIf=\"cData.prefix\" matPrefix [innerHTML]=\"((prefix$ | async) || '') | jpSanitize\"></span>\n  <mat-hint *ngIf=\"cData.hint\" [innerHTML]=\"cData.hint | jpSanitize\"></mat-hint>\n</mat-form-field>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            },] }
];

/**
 * Deep clones the given AbstractControl, preserving values, validators, async validators, and disabled status.
 * @param control AbstractControl
 * @returns AbstractControl
 */
function cloneAbstractControl(control) {
    let newControl;
    if (control instanceof FormGroup) {
        const formGroup = new FormGroup({}, control.validator, control.asyncValidator);
        const controls = control.controls;
        Object.keys(controls).forEach(key => {
            formGroup.addControl(key, cloneAbstractControl(controls[key]));
        });
        newControl = formGroup;
    }
    else if (control instanceof FormArray) {
        const formArray = new FormArray([], control.validator, control.asyncValidator);
        control.controls.forEach(formControl => formArray.push(cloneAbstractControl(formControl)));
        newControl = formArray;
    }
    else if (control instanceof FormControl) {
        newControl = new FormControl(control.value, control.validator, control.asyncValidator);
    }
    else {
        throw new Error('Error: unexpected control value');
    }
    if (control.disabled) {
        newControl.disable({ emitEvent: false });
    }
    return newControl;
}

class DateFieldComponent extends FieldComponent {
    constructor(cData, cdr, formBuilderService) {
        super(cData);
        this.cData = cData;
        this.cdr = cdr;
        this.formBuilderService = formBuilderService;
    }
    ngOnInit() {
        this.formBuilderService.saveComponents.push(this);
        this.startDate = this.cData.startAt
            ? new Date(this.cData.startAt)
            : new Date();
        const date = new Date(this.cData.control.value);
        this.entryControl = cloneAbstractControl(this.cData.control);
        this.hoursControl = new FormControl({ value: date.getHours() || 0, disabled: this.cData.control.disabled }, [Validators.min(0), Validators.max(23)]);
        this.minutesControl = new FormControl({ value: date.getMinutes() || 0, disabled: this.cData.control.disabled }, [Validators.min(0), Validators.max(59)]);
        /**
         * Dirty hack for getting numbers to display properly might need revisiting
         */
        if (typeof this.entryControl.value === 'number' ||
            typeof this.entryControl.value === 'string') {
            this.entryControl.setValue(new Date(this.entryControl.value));
        }
    }
    save() {
        return of({}).pipe(tap(() => {
            let value = this.entryControl.value;
            if (value) {
                if (this.cData.includeTime) {
                    value.setHours(this.hoursControl.value || 0);
                    value.setMinutes(this.minutesControl.value || 0);
                }
                if (this.cData.format) {
                    if (this.cData.format === 'number') {
                        value = value.getTime();
                    }
                    else {
                        const pipe = new DatePipe('en');
                        value = pipe.transform(value, this.cData.format);
                    }
                }
            }
            this.cData.control.setValue(value);
        }));
    }
}
DateFieldComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-date-field',
                template: "<div class=\"grid\">\n  <div class=\"p-l-0 {{!cData.includeTime ? 'col-12' : 'col-8'}}\">\n    <mat-form-field class=\"w-full\" appearance=\"outline\">\n      <mat-label>\n        {{(cData.label || '') | transloco}}\n      </mat-label>\n      <input\n        matInput\n        [attr.autocomplete]=\"cData.autocomplete || 'off'\"\n        [matDatepicker]=\"picker\"\n        [placeholder]=\"(cData.placeholder || '') | transloco\"\n        [formControl]=\"entryControl\">\n      <mat-datepicker-toggle matSuffix [for]=\"picker\"></mat-datepicker-toggle>\n      <mat-datepicker\n        #picker\n        [touchUi]=\"cData.touchUi || false\"\n        [startView]=\"cData.startView || 'month'\"\n        [startAt]=\"startDate\">\n      </mat-datepicker>\n      <mat-hint *ngIf=\"cData.hint\" [innerHTML]=\"cData.hint | jpSanitize\"></mat-hint>\n    </mat-form-field>\n  </div>\n  <ng-container *ngIf=\"cData.includeTime\">\n    <div class=\"col-2\">\n      <mat-form-field class=\"w-full\" class=\"w-full\" appearance=\"outline\">\n        <mat-label>{{(cData.labelHours || 'HOURS') | transloco}}</mat-label>\n        <input matInput type=\"number\" [placeholder]=\"cData.placeholderHours || 'HH'\" [formControl]=\"hoursControl\">\n      </mat-form-field>\n    </div>\n    <div class=\"col-2 p-r-0\">\n      <mat-form-field class=\"w-full\" appearance=\"outline\">\n        <mat-label>{{(cData.labelMinutes || 'MINUTES') | transloco}}</mat-label>\n        <input matInput type=\"number\" [placeholder]=\"cData.placeholderMinutes || 'MM'\" [formControl]=\"minutesControl\">\n      </mat-form-field>\n    </div>\n  </ng-container>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            },] }
];
DateFieldComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [COMPONENT_DATA,] }] },
    { type: ChangeDetectorRef },
    { type: FormBuilderService }
];

class DraggableListComponent extends FieldComponent {
    ngOnInit() {
        if (this.cData.control.value.length) {
            this.cData.options.sort((optionOne, optionTwo) => {
                const indexOne = this.cData.control.value.indexOf(optionOne);
                const indexTwo = this.cData.control.value.indexOf(optionTwo);
                return indexTwo - indexOne;
            });
        }
    }
    drop(event) {
        moveItemInArray(this.cData.options, event.previousIndex, event.currentIndex);
        this.cData.control.setValue(this.cData.options.map(val => {
            return val.value;
        }));
    }
}
DraggableListComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-draggable-list',
                template: "<div class=\"mat-form-field-wrapper\">\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.label\">{{cData.label | transloco}}</p>\n\n  <div\n    class=\"fb-draggable-list\"\n    cdkDropList\n    (cdkDropListDropped)=\"drop($event)\">\n    <div\n      class=\"fb-draggable-list-item\"\n      *ngFor=\"let item of cData.options; index as index\"\n      [cdkDragDisabled]=\"item.disabled\"\n      cdkDrag>\n      {{index + 1}}. {{item.name}}\n    </div>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".fb-draggable-list{border:1px solid var(--panel-tertiary);border-radius:4px;overflow:hidden}.fb-draggable-list-item{align-items:center;background:var(--panel-theme);border-bottom:1px solid var(--panel-tertiary);cursor:move;display:flex;padding:20px 10px}.fb-draggable-list-item:last-child{border:none}.cdk-drag-preview{border-radius:4px;box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}.cdk-drag-placeholder{opacity:0}.cdk-drag-animating,.fb-draggable-list.cdk-drop-list-dragging .fb-draggable-list-item:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}"]
            },] }
];

class StorageService {
    upload(path, data, metadata) { }
}

/**
 * Remove all characters that are not alphanumeric.
 *
 * In case of not finding any alphanumeric characters
 * return string `file-{random number}`
 *
 * @param name
 * File name to format
 */
const formatFileName = (name) => {
    const extension = name.slice(name.lastIndexOf('.'));
    name = name.slice(0, name.lastIndexOf('.'));
    name = (name.match(/[a-zA-Z\d.]/g) || []).join('');
    return !!name.length ? name + extension : `file-${Math.floor(Math.random() * Math.pow(10, 5)) + 1}${extension}`;
};

const parseSize = (size) => {
    if (typeof size === 'number') {
        return size;
    }
    const KB = 1024;
    const MB = Math.pow(KB, 2);
    const num = parseFloat(size);
    const unit = size.replace(/[0-9]/g, '').toLowerCase();
    switch (unit) {
        case 'kb': {
            return num * KB;
        }
        case 'mb': {
            return num * MB;
        }
        default: {
            return 0;
        }
    }
};

class FileComponent extends FieldComponent {
    constructor(cData, storage, cdr, formBuilderService, transloco, snackBar) {
        super(cData);
        this.cData = cData;
        this.storage = storage;
        this.cdr = cdr;
        this.formBuilderService = formBuilderService;
        this.transloco = transloco;
        this.snackBar = snackBar;
    }
    ngOnInit() {
        if (this.cData.control.value) {
            this.name = this.cData.control.value;
        }
        this.emptyLabel = (this.cData.hasOwnProperty('emptyLabel') ? this.cData.emptyLabel : 'FIELDS.FILE.EMPTY');
        this.formBuilderService.saveComponents.push(this);
        this.allowedFileTypes = this.cData.allowedFileTypes || [];
        this.forbiddenFileTypes = this.cData.forbiddenFileTypes || [];
        this.minSizeBytes = this.cData.minSize ? parseSize(this.cData.minSize) : 0;
        this.maxSizeBytes = this.cData.maxSize ? parseSize(this.cData.maxSize) : 0;
    }
    errorSnack(message = 'GENERAL.ERROR', dismiss = 'GENERAL.DISMISS') {
        this.snackBar.open(this.transloco.translate(message), this.transloco.translate(dismiss), {
            panelClass: 'snack-bar-error',
            duration: 5000
        });
    }
    fileChange(ev) {
        const el = ev.target;
        const file = Array.from(el.files)[0];
        Object.defineProperty(file, 'name', {
            writable: true,
            value: formatFileName(file.name)
        });
        if (!this.allowedFileTypes.includes(file.type) && !!this.allowedFileTypes.length) {
            this.errorSnack('FIELDS.FILE.INVALID_FILE_FORMAT');
            return throwError('Invalid File Format');
        }
        if (this.forbiddenFileTypes.includes(file.type)) {
            this.errorSnack('FIELDS.FILE.FORBIDDEN_FILE_FORMAT');
            return throwError('Forbidden File Format');
        }
        if (file.size < this.minSizeBytes) {
            this.errorSnack('FIELDS.FILE.BELOW_SIZE');
            return throwError('File below minimal allowed size');
        }
        if (file.size > this.maxSizeBytes && !!this.maxSizeBytes) {
            this.errorSnack('FIELDS.FILE.EXCEED_SIZE');
            return throwError('File exceeding allowed size');
        }
        this.value = file;
        if (this.value) {
            this.name = this.value.name;
        }
        el.value = '';
    }
    clear() {
        this.name = '';
        this.cData.control.setValue('');
    }
    save(moduleId, documentId) {
        if (this.value) {
            const name = [
                moduleId,
                documentId,
                this.value.name
            ]
                .join('-');
            return from(this.storage.upload(name, this.value, {
                contentType: this.value.type,
                customMetadata: {
                    moduleId,
                    documentId
                }
            })).pipe(switchMap((res) => res.ref.getDownloadURL()), tap(url => this.cData.control.setValue(url)));
        }
        else {
            return of({});
        }
    }
}
FileComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-file',
                template: "<div class=\"mat-form-field-wrapper\">\n  <fieldset class=\"fb-file\">\n    <input #file type=\"file\" hidden (change)=\"fileChange($event)\">\n\n    <legend class=\"fb-file-legend\">{{(cData.label || '') | transloco}}</legend>\n\n    <div class=\"fb-file-field\">\n      <span class=\"fb-file-field-name\">{{name || (emptyLabel | transloco)}}</span>\n\n      <div class=\"fb-file-field-actions\">\n        <ng-container *ngIf=\"!cData.preventClear && name\">\n          <button mat-button (click)=\"clear()\">{{'REMOVE' | transloco}}</button>|\n        </ng-container>\n        <button mat-button (click)=\"file.click()\">{{'ADD' | transloco}}</button>\n      </div>\n    </div>\n  </fieldset>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".fb-file{border:1px solid var(--panel-tertiary);border-radius:4px;overflow:hidden;transition:.2s}.fb-file:hover{border:1px solid var(--panel-primary);box-shadow:0 0 0 1px var(--panel-primary)}.fb-file:focus-within{border:1px solid var(--primary-theme);box-shadow:0 0 0 1px var(--primary-theme)}.fb-file-legend{background:var(--panel-theme);color:var(--panel-secondary);font-size:.8em;margin-left:-8px;padding:0 4px}.fb-file-field{align-items:center;display:flex}.fb-file-field-name{color:var(--panel-secondary);flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:1px}.fb-file-field-actions{margin-left:auto;white-space:nowrap}"]
            },] }
];
FileComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [COMPONENT_DATA,] }] },
    { type: StorageService },
    { type: ChangeDetectorRef },
    { type: FormBuilderService },
    { type: TranslocoService },
    { type: MatSnackBar }
];
FileComponent.propDecorators = {
    fileEl: [{ type: ViewChild, args: ['file', { static: true },] }]
};

function formatGeneratedImages(data) {
    return data.reduce((acc, cur, index) => {
        acc[`generate_${index + 1}`] = Object.entries(cur).reduce((generated, [key, value]) => {
            generated += `----${key}:${value}`;
            return generated;
        }, '');
        return acc;
    }, {});
}

const STORAGE_URL = new InjectionToken('STORAGE_URL');

/**
 * Switches the location of two items
 * in an array
 */
function switchItemLocations(items, previousIndex, currentIndex) {
    const itemOne = items[previousIndex];
    const itemTwo = items[currentIndex];
    items[currentIndex] = itemOne;
    items[previousIndex] = itemTwo;
}

function readFile(blob) {
    return new Observable(obs => {
        if (!(blob instanceof Blob)) {
            obs.error(new Error('`blob` must be an instance of File or Blob.'));
            return;
        }
        const reader = new FileReader();
        reader.onerror = err => obs.error(err);
        reader.onabort = err => obs.error(err);
        reader.onload = () => obs.next(reader.result);
        reader.onloadend = () => obs.complete();
        return reader.readAsDataURL(blob);
    });
}

class GalleryComponent extends FieldComponent {
    constructor(cData, storageUrl, dialog, cdr, http, storage, formBuilderService, viewportRuler, transloco, snackBar) {
        super(cData);
        this.cData = cData;
        this.storageUrl = storageUrl;
        this.dialog = dialog;
        this.cdr = cdr;
        this.http = http;
        this.storage = storage;
        this.formBuilderService = formBuilderService;
        this.viewportRuler = viewportRuler;
        this.transloco = transloco;
        this.snackBar = snackBar;
        this.files = [];
        this.toRemove = [];
    }
    ngOnInit() {
        this.formBuilderService.saveComponents.push(this);
        this.allowedImageTypes = this.cData.allowedImageTypes || [];
        this.forbiddenImageTypes = this.cData.forbiddenImageTypes || [];
        this.minSizeBytes = this.cData.minSize ? parseSize(this.cData.minSize) : 0;
        this.maxSizeBytes = this.cData.maxSize ? parseSize(this.cData.maxSize) : 0;
    }
    ngAfterViewInit() {
        const phElement = this.placeholder.element.nativeElement;
        const { parentElement } = phElement;
        phElement.style.display = 'none';
        parentElement.removeChild(phElement);
    }
    openUploadDialog() {
        this.dialog.open(this.modalTemplate, {
            width: '420px'
        });
    }
    addImage(image) {
        this.http
            .get(image, {
            withCredentials: false,
            responseType: 'blob'
        })
            .pipe(switchMap((blob) => {
            const type = blob.type.split('/')[1].toLowerCase();
            if (!this.allowedImageTypes.includes(type) && !!this.allowedImageTypes.length) {
                return throwError('Invalid Image Format');
            }
            if (this.forbiddenImageTypes.includes(type)) {
                return throwError('Forbidden Image Format');
            }
            if (blob.size < this.minSizeBytes) {
                return throwError('Image below minimal allowed size');
            }
            if (blob.size > this.maxSizeBytes && !!this.maxSizeBytes) {
                return throwError('Image exceeding allowed size');
            }
            return of(blob);
        }), this.formBuilderService.notify({
            error: 'FIELDS.GALLERY.UPLOAD_ERROR',
            success: null
        }))
            .subscribe(res => {
            const urlCreator = window.URL || window.webkitURL;
            const value = this.cData.control.value;
            value.push({
                data: urlCreator.createObjectURL(res),
                live: true
            });
            this.cData.control.setValue(value);
            this.cdr.detectChanges();
        });
    }
    openFileUpload() {
        this.fileEl.nativeElement.click();
    }
    openSortImages() {
        this.dialog.open(this.imagesSort, {
            width: '800px'
        });
    }
    drop(event) {
        const value = this.cData.control.value;
        switchItemLocations(value, event.previousIndex, event.currentIndex);
        this.cData.control.setValue(value);
        this.cdr.detectChanges();
    }
    move(up = false, index) {
        const currentIndex = up ? index - 1 : index + 1;
        const value = this.cData.control.value;
        moveItemInArray(value, index, currentIndex);
        this.cData.control.setValue(value);
        this.cdr.detectChanges();
    }
    errorSnack(message = 'GENERAL.ERROR', dismiss = 'GENERAL.DISMISS') {
        this.snackBar.open(this.transloco.translate(message), this.transloco.translate(dismiss), {
            panelClass: 'snack-bar-error',
            duration: 5000
        });
    }
    filesUploaded(el) {
        const files = Array.from((el instanceof FileList ? el : el.files));
        for (const file of files) {
            Object.defineProperty(file, 'name', {
                writable: true,
                value: formatFileName(file.name)
            });
            const type = file.type.split('/')[1].toLowerCase();
            if (!this.allowedImageTypes.includes(type) && !!this.allowedImageTypes.length) {
                this.errorSnack('FIELDS.GALLERY.INVALID_IMAGE_FORMAT');
                return throwError('Invalid Image Format');
            }
            if (this.forbiddenImageTypes.includes(type)) {
                this.errorSnack('FIELDS.GALLERY.FORBIDDEN_IMAGE_FORMAT');
                return throwError('Forbidden Image Format');
            }
            if (file.size < this.minSizeBytes) {
                this.errorSnack('FIELDS.GALLERY.BELOW_SIZE');
                return throwError('Image below minimal allowed size');
            }
            if (file.size > this.maxSizeBytes && !!this.maxSizeBytes) {
                this.errorSnack('FIELDS.GALLERY.EXCEED_SIZE');
                return throwError('Image exceeding allowed size');
            }
        }
        forkJoin(files.map(file => readFile(file).pipe(map(data => ({
            data,
            pushToLive: file,
            live: false
        }))))).subscribe(fls => {
            const value = this.cData.control.value;
            value.push(...fls);
            this.cData.control.setValue(value);
            if (!(el instanceof FileList)) {
                el.value = '';
            }
            this.cdr.detectChanges();
        }, () => {
            if (!(el instanceof FileList)) {
                el.value = '';
            }
        });
    }
    removeImage(index, item) {
        if (item.live && item.data.includes(this.storageUrl)) {
            this.toRemove.push(item.data);
        }
        this.cData.control.value.splice(index, 1);
    }
    sortDrop(event) {
        const value = this.cData.control.value;
        moveItemInArray(value, event.previousIndex, event.currentIndex);
        this.cData.control.setValue(value);
    }
    /**
     * Drag and Drop
     */
    dragMoved(e) {
        const point = this.getPointerPositionOnPage(e.event);
        this.listGroup._items.forEach(dropList => {
            if (__isInsideDropListClientRect(dropList, point.x, point.y)) {
                this.activeContainer = dropList;
                return;
            }
        });
    }
    dropListDropped() {
        if (!this.target) {
            return;
        }
        const phElement = this.placeholder.element.nativeElement;
        const parent = phElement.parentElement;
        phElement.style.display = 'none';
        const { element } = this.source;
        parent.removeChild(phElement);
        parent.appendChild(phElement);
        parent.insertBefore(element.nativeElement, parent.children[this.sourceIndex]);
        this.target = null;
        this.source = null;
        if (this.sourceIndex !== this.targetIndex) {
            const value = this.cData.control.value;
            moveItemInArray(value, this.sourceIndex, this.targetIndex);
            this.cData.control.setValue(value);
        }
    }
    /** Determines the point of the page that was touched by the user. */
    getPointerPositionOnPage(event) {
        // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.
        const point = __isTouchEvent(event) ? (event.touches[0] || event.changedTouches[0]) : event;
        const scrollPosition = this.viewportRuler.getViewportScrollPosition();
        return {
            x: point.pageX - scrollPosition.left,
            y: point.pageY - scrollPosition.top
        };
    }
    /**
     * Executes all uploads/removes to persist
     * the changes on server
     */
    save(moduleId, documentId) {
        if (!this.toRemove.length &&
            !this.cData.control.value ||
            !this.cData.control.value.find((val) => !val.live)) {
            return of([]);
        }
        return forkJoin([
            ...this.toRemove.map(file => from(this.storage.storage.refFromURL(file).delete()).pipe(
            /**
             * Dont' fail if files didn't delete
             */
            catchError(() => of([])))),
            ...this.cData.control.value.reduce((acc, cur) => {
                if (cur.live !== undefined && !cur.live) {
                    const name = [
                        moduleId,
                        documentId,
                        cur.pushToLive.name
                    ]
                        .join('-');
                    acc.push(from(this.storage.upload(name, cur.pushToLive, {
                        contentType: cur.pushToLive.type,
                        customMetadata: Object.assign({ moduleId,
                            documentId }, this.cData.generatedImages &&
                            formatGeneratedImages(this.cData.generatedImages))
                    })).pipe(switchMap((task) => task.ref.getDownloadURL()), tap(url => {
                        cur.data = url;
                    })));
                }
                else {
                    acc.push(cur);
                }
                return acc;
            }, [])
        ]).pipe(tap(() => this.cData.control.setValue(this.cData.control.value.map((item) => (item.data ? item.data : item)))));
    }
}
GalleryComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-gallery',
                template: "<p class=\"fs-small fg-secondary\" *ngIf=\"cData.label\">{{(cData.label || '') | transloco}}</p>\n\n<div class=\"fb-gallery\" fbDropzone (dropped)=\"filesUploaded($event)\">\n  <div class=\"ta-center p-y-l\">\n    <button mat-button *ngIf=\"cData.allowUrl\" (click)=\"openUploadDialog()\">{{'FIELDS.GALLERY.ENTER_URL' | transloco}}</button>\n    <button mat-button *ngIf=\"cData.allowServerUpload\" (click)=\"openFileUpload()\">{{'FIELDS.GALLERY.CHOOSE_FILES' | transloco}}</button>\n    <button mat-button *ngIf=\"cData.allowServerUpload\" (click)=\"openSortImages()\">{{'FIELDS.GALLERY.SORT_IMAGES' | transloco}}</button>\n  </div>\n\n  <!--Upload from disk-->\n  <input #file type=\"file\" multiple hidden (change)=\"filesUploaded($event.target)\">\n\n  <!--Uploaded images list-->\n  <ng-container>\n    <div class=\"fb-gallery-list\" cdkDropListGroup>\n\n      <div class=\"fb-gallery-list-placeholder\" cdkDropList (cdkDropListDropped)=\"dropListDropped()\"></div>\n\n      <div\n        cdkDropList\n        class=\"fb-gallery-list-image\"\n        (cdkDropListDropped)=\"dropListDropped()\"\n        *ngFor=\"let val of cData.control.value; index as index\">\n\n        <div cdkDrag (cdkDragMoved)=\"dragMoved($event);\">\n          <img class=\"fb-gallery-list-image-inner\" [src]=\"(val.data || val) | jpSanitize:'resourceUrl'\">\n          <button class=\"fb-gallery-list-image-remove\" type=\"button\" mat-icon-button [matTooltip]=\"'GENERAL.REMOVE' | transloco\" (click)=\"removeImage(index, val)\">\n            <mat-icon>close</mat-icon>\n          </button>\n        </div>\n\n      </div>\n    </div>\n  </ng-container>\n</div>\n\n<!--Uplaod from URL-->\n<ng-template #modal>\n  <mat-dialog-content>\n    <mat-form-field class=\"w-full\" appearance=\"outline\">\n      <mat-label>{{'FIELDS.GALLERY.IMAGE_URL' | transloco}}</mat-label>\n      <input matInput #url>\n    </mat-form-field>\n  </mat-dialog-content>\n\n  <mat-dialog-actions class=\"jc-end\">\n    <button mat-button mat-dialog-close>{{'GENERAL.CANCEL' | transloco}}</button>&nbsp;\n    <button mat-flat-button color=\"primary\" [disabled]=\"!url.value\" (click)=\"addImage(url.value)\" mat-dialog-close>{{'FIELDS.GALLERY.ADD_IMAGE' | transloco}}</button>\n  </mat-dialog-actions>\n</ng-template>\n\n<!--Image sort-->\n<ng-template #imagesSort>\n  <h1 mat-dialog-title>{{'FIELDS.GALLERY.SORT_IMAGES' | transloco}}</h1>\n\n  <mat-dialog-content>\n\n    <div\n      class=\"sort-wrapper\"\n      cdkDropList\n      (cdkDropListDropped)=\"sortDrop($event)\">\n\n      <div class=\"sort-box\" *ngFor=\"let val of cData.control.value; index as index; first as first; last as last;\" cdkDrag>\n        <img class=\"sort-image\" [src]=\"(val.data || val) | jpSanitize:'resourceUrl'\">\n        <div class=\"flex-1\"></div>\n        <div>\n          <button mat-icon-button [disabled]=\"first\" (click)=\"move(true, index)\">\n            <mat-icon>arrow_upward</mat-icon>\n          </button>\n          <button mat-icon-button [disabled]=\"last\" (click)=\"move(false, index)\">\n            <mat-icon>arrow_downward</mat-icon>\n          </button>\n          <button mat-icon-button cdkDragHandle>\n            <mat-icon>drag_indicator</mat-icon>\n          </button>\n        </div>\n      </div>\n\n    </div>\n  </mat-dialog-content>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".fb-gallery{border:1px dashed var(--tertiary);margin-bottom:1.25em;position:relative}.fb-gallery-list{cursor:-webkit-grab;cursor:grab;display:flex;flex-wrap:wrap}.fb-gallery-list-placeholder{border:2px dashed var(--tertiary)}.fb-gallery-list-image,.fb-gallery-list-placeholder{flex-basis:33.33333%;padding-bottom:33.33333%;position:relative;width:33.33333%}.fb-gallery-list-image{background:#eee;border:2px solid #fff}.fb-gallery-list-image-inner,.fb-gallery-list-image>div{height:100%;position:absolute;width:100%}.fb-gallery-list-image-inner{-o-object-fit:contain;left:0;object-fit:contain;top:0}.fb-gallery-list-image-remove{background:#fff;border:1px solid #222;line-height:24px;opacity:0;position:absolute;right:0;top:0;transition:.2s;visibility:hidden}.fb-gallery-list-image:hover .fb-gallery-list-image-remove{opacity:1;visibility:visible}.fb-gallery:before{bottom:0;content:\"Drop To Upload\";display:none;font-size:20px;left:0;margin:auto;position:absolute;right:0;text-align:center;top:0}.fb-gallery.active{background:#ccc;border:3px dashed var(--tertiary)}.fb-gallery.active:before{display:block}.sort-wrapper{background:#fff;border:1px solid #ccc;border-radius:4px;display:block;max-width:100%;min-height:60px;overflow:hidden}.sort-image{-o-object-fit:cover;height:40px;object-fit:cover;width:40px}.sort-box{align-items:center;background:#fff;border-bottom:1px solid #ccc;box-sizing:border-box;color:rgba(0,0,0,.87);display:flex;flex-direction:row;font-size:14px;justify-content:space-between;padding:20px 10px}.sort-box:last-child{border:none}.cdk-drag-preview{border-radius:4px;box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);box-sizing:border-box}.cdk-drag-placeholder{opacity:.3}.cdk-drag-animating,.cdk-drop-list-dragging .sort-box:not(.cdk-drag-placeholder){transition:transform .25s cubic-bezier(0,0,.2,1)}"]
            },] }
];
GalleryComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [COMPONENT_DATA,] }] },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [STORAGE_URL,] }] },
    { type: MatDialog },
    { type: ChangeDetectorRef },
    { type: HttpClient },
    { type: StorageService },
    { type: FormBuilderService },
    { type: ViewportRuler },
    { type: TranslocoService },
    { type: MatSnackBar }
];
GalleryComponent.propDecorators = {
    listGroup: [{ type: ViewChild, args: [CdkDropListGroup, { static: true },] }],
    placeholder: [{ type: ViewChild, args: [CdkDropList, { static: true },] }],
    modalTemplate: [{ type: ViewChild, args: ['modal', { static: true },] }],
    imagesSort: [{ type: ViewChild, args: ['imagesSort', { static: true },] }],
    fileEl: [{ type: ViewChild, args: ['file', { static: true },] }]
};
function __indexOf(collection, node) {
    return Array.prototype.indexOf.call(collection, node);
}
/** Determines whether an event is a touch event. */
function __isTouchEvent(event) {
    return event.type.startsWith('touch');
}
function __isInsideDropListClientRect(dropList, x, y) {
    const { top, bottom, left, right } = dropList.element.nativeElement.getBoundingClientRect();
    return y >= top && y <= bottom && x >= left && x <= right;
}

class ImageComponent extends FieldComponent {
    constructor(cData, storage, cdr, formBuilderService, transloco, snackBar, domSanitizer) {
        super(cData);
        this.cData = cData;
        this.storage = storage;
        this.cdr = cdr;
        this.formBuilderService = formBuilderService;
        this.transloco = transloco;
        this.snackBar = snackBar;
        this.domSanitizer = domSanitizer;
        this.disInput = false;
    }
    ngOnInit() {
        this.imageUrl = new FormControl(this.cData.control.value);
        this.formBuilderService.saveComponents.push(this);
        this.allowedImageTypes = this.cData.allowedImageTypes || [];
        this.forbiddenImageTypes = this.cData.forbiddenImageTypes || [];
        this.minSizeBytes = this.cData.minSize ? parseSize(this.cData.minSize) : 0;
        this.maxSizeBytes = this.cData.maxSize ? parseSize(this.cData.maxSize) : 0;
    }
    errorSnack(message = 'GENERAL.ERROR', dismiss = 'GENERAL.DISMISS') {
        this.snackBar.open(this.transloco.translate(message), this.transloco.translate(dismiss), {
            panelClass: 'snack-bar-error',
            duration: 5000
        });
    }
    openFileUpload() {
        this.fileEl.nativeElement.click();
    }
    filesImage(event) {
        const el = event.target;
        const image = Array.from(el.files)[0];
        Object.defineProperty(image, 'name', {
            writable: true,
            value: formatFileName(image.name)
        });
        if (!this.allowedImageTypes.includes(image.type) && !!this.allowedImageTypes.length) {
            this.errorSnack('FIELDS.GALLERY.INVALID_IMAGE_FORMAT');
            return throwError('Invalid Image Format');
        }
        if (this.forbiddenImageTypes.includes(image.type)) {
            this.errorSnack('FIELDS.GALLERY.FORBIDDEN_IMAGE_FORMAT');
            return throwError('Forbidden Image Format');
        }
        if (image.size < this.minSizeBytes) {
            this.errorSnack('FIELDS.GALLERY.BELOW_SIZE');
            return throwError('Image below minimal allowed size');
        }
        if (image.size > this.maxSizeBytes && !!this.maxSizeBytes) {
            this.errorSnack('FIELDS.GALLERY.EXCEED_SIZE');
            return throwError('Image exceeding allowed size');
        }
        this.value = image;
        this.disInput = true;
        this.imageUrl.setValue(this.value.name);
        const reader = new FileReader();
        reader.onload = () => {
            this.imageSrc = this.domSanitizer.bypassSecurityTrustResourceUrl(reader.result);
            this.cdr.detectChanges();
        };
        reader.readAsDataURL(this.value);
        el.value = '';
    }
    remove() {
        this.imageUrl.setValue('');
        this.value = null;
        this.disInput = false;
        this.cdr.detectChanges();
    }
    save(moduleId, documentId) {
        if (this.value) {
            if (this.imageUrl.value && this.imageUrl.value !== this.value.name) {
                return of(this.imageUrl.value).pipe(tap(() => this.cData.control.setValue(this.imageUrl.value)));
            }
            else {
                const name = [
                    moduleId,
                    documentId,
                    this.value.name
                ]
                    .join('-');
                return from(this.storage.upload(name, this.value, {
                    contentType: this.value.type,
                    customMetadata: Object.assign({ moduleId,
                        documentId }, (this.cData.generatedImages &&
                        formatGeneratedImages(this.cData.generatedImages)))
                })).pipe(switchMap((res) => res.ref.getDownloadURL()), tap(url => this.cData.control.setValue(url)));
            }
        }
        else {
            this.cData.control.setValue(this.imageUrl.value);
            return of({});
        }
    }
}
ImageComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-image',
                template: "<mat-form-field appearance=\"outline\" class=\"w-full\">\n  <mat-label>{{(cData.label || '') | transloco}}</mat-label>\n  <input\n    matInput\n    type=\"url\"\n    [placeholder]=\"(cData.placeholder || '') | transloco\"\n    [class.disabled]=\"disInput\"\n    [formControl]=\"imageUrl\">\n  <div matSuffix class=\"fb-image-suffix\">\n    <ng-container *ngIf=\"imageUrl.value\">\n      <div class=\"fb-image-suffix-preview\">\n        <button class=\"fb-image-suffix-preview-button\" mat-icon-button>\n          <mat-icon>visibility</mat-icon>\n        </button>\n        <img class=\"fb-image-suffix-preview-image\" [attr.src]=\"imageSrc || imageUrl.value || value\" [alt]=\"'FIELDS.IMAGE.PREVIEW' | transloco\">\n      </div>\n    </ng-container>\n    <button mat-icon-button *ngIf=\"!imageUrl.value && !cData.preventServerUpload\">\n      <mat-icon (click)=\"openFileUpload()\">perm_media</mat-icon>\n    </button>\n    <button mat-icon-button *ngIf=\"imageUrl.value\">\n      <mat-icon (click)=\"remove()\">highlight_off</mat-icon>\n    </button>\n  </div>\n  <mat-hint *ngIf=\"cData.hint\" [innerHTML]=\"cData.hint | jpSanitize\"></mat-hint>\n</mat-form-field>\n\n<input #file type=\"file\" hidden (change)=\"filesImage($event)\">\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".fb-image-suffix{display:flex}.fb-image-suffix-preview{display:inline-block;position:relative}.fb-image-suffix-preview-image{-o-object-fit:contain;background:#fff;box-shadow:0 2px 5px 0 rgba(0,0,0,.4);height:200px;max-width:unset;object-fit:contain;opacity:0;position:absolute;right:0;top:100%;transition:.2s;visibility:hidden;width:200px;z-index:2}.fb-image-suffix-preview-button:hover+.fb-image-suffix-preview-image{opacity:1;visibility:visible}"]
            },] }
];
ImageComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [COMPONENT_DATA,] }] },
    { type: StorageService },
    { type: ChangeDetectorRef },
    { type: FormBuilderService },
    { type: TranslocoService },
    { type: MatSnackBar },
    { type: DomSanitizer }
];
ImageComponent.propDecorators = {
    fileEl: [{ type: ViewChild, args: ['file', { static: true },] }]
};

class InputComponent extends FieldComponent {
    ngOnInit() {
        this.prefix$ = getHsd('prefix', this.cData);
        this.suffix$ = getHsd('suffix', this.cData);
    }
}
InputComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-input',
                template: "<!--TODO: Format this when fixed. For some reason if the type is passed through a variable angular doesn't properly parse-->\n<ng-container [ngSwitch]=\"cData.type\">\n  <mat-form-field *ngSwitchCase=\"'number'\" class=\"w-full\" appearance=\"outline\" [class.mat-form-field-has-hint]=\"cData.hint\">\n    <mat-label>{{(cData.label || '') | transloco}}</mat-label>\n    <span *ngIf=\"cData.prefix\" matPrefix [innerHTML]=\"((prefix$ | async) || '') | jpSanitize\"></span>\n    <input\n      matInput\n      type=\"number\"\n      [attr.autocomplete]=\"cData.autocomplete || 'on'\"\n      [placeholder]=\"(cData.placeholder || '') | transloco\"\n      [formControl]=\"cData.control\">\n    <span *ngIf=\"cData.suffix\" matSuffix [innerHTML]=\"((suffix$ | async) || '') | jpSanitize\"></span>\n    <mat-hint *ngIf=\"cData.hint\" [innerHTML]=\"cData.hint | jpSanitize\"></mat-hint>\n  </mat-form-field>\n\n  <mat-form-field *ngSwitchDefault class=\"w-full\" appearance=\"outline\" [class.mat-form-field-has-hint]=\"cData.hint\">\n    <mat-label>{{(cData.label || '') | transloco}}</mat-label>\n    <span *ngIf=\"cData.prefix\" matPrefix [innerHTML]=\"((prefix$ | async) || '') | jpSanitize\"></span>\n    <input\n        matInput\n        [attr.autocomplete]=\"cData.autocomplete || 'on'\"\n        [attr.type]=\"cData.type\"\n        [placeholder]=\"(cData.placeholder || '') | transloco\"\n        [formControl]=\"cData.control\">\n    <span *ngIf=\"cData.suffix\" matSuffix [innerHTML]=\"((suffix$ | async) || '') | jpSanitize\"></span>\n    <mat-hint *ngIf=\"cData.hint\" [innerHTML]=\"cData.hint | jpSanitize\"></mat-hint>\n  </mat-form-field>\n</ng-container>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            },] }
];

class RadioComponent extends FieldComponent {
}
RadioComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-radio',
                template: "<div class=\"mat-form-field-wrapper\">\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.label\">{{(cData.label || '') | transloco}}</p>\n  <mat-radio-group [formControl]=\"cData.control\">\n    <mat-radio-button\n      *ngFor=\"let option of cData.options\"\n      [disabled]=\"option.disabled\"\n      [value]=\"option.value\">\n      {{option.name}}\n    </mat-radio-button>\n  </mat-radio-group>\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.hint\">\n    {{(cData.hint | transloco) | transloco}}\n  </p>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            },] }
];

class RangeComponent extends FieldComponent {
    constructor(cData, cdr, formBuilderService) {
        super(cData);
        this.cData = cData;
        this.cdr = cdr;
        this.formBuilderService = formBuilderService;
    }
    ngOnInit() {
        this.formBuilderService.saveComponents.push(this);
        this.min = new Date(this.cData.min || 0);
        this.max = new Date(this.cData.max || Date.now() * 2);
        this.entryControl = cloneAbstractControl(this.cData.control);
        this.start = new FormControl({ value: this.entryControl.value.start || '', disabled: this.cData.control.disabled }, [Validators.min(this.cData.min || 0)]);
        this.end = new FormControl({ value: this.entryControl.value.end || '', disabled: this.cData.control.disabled }, [Validators.max(this.cData.max || Date.now() * 2)]);
    }
    save() {
        return of({}).pipe(tap(() => {
            const start = this.start.value;
            const end = this.end.value;
            this.cData.control.setValue({ start, end });
        }));
    }
}
RangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-range',
                template: "<div class=\"mat-form-field-wrapper\">\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.label\">{{(cData.label || '') | transloco}}</p>\n\n  <mat-form-field appearance=\"outline\" class=\"w-full\">\n    <mat-label>Enter a date range</mat-label>\n    <mat-date-range-input [rangePicker]=\"picker\">\n      <input matStartDate placeholder=\"Start date\" [formControl]=\"start\" [min]=\"min\">\n      <input matEndDate placeholder=\"End date\" [formControl]=\"end\" [max]=\"max\">\n    </mat-date-range-input>\n    <mat-datepicker-toggle matSuffix [for]=\"picker\"></mat-datepicker-toggle>\n    <mat-date-range-picker #picker></mat-date-range-picker>\n  </mat-form-field>\n\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.hint\">\n    {{(cData.hint | transloco) | transloco}}\n  </p>\n</div>\n",
                styles: [""]
            },] }
];
RangeComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [COMPONENT_DATA,] }] },
    { type: ChangeDetectorRef },
    { type: FormBuilderService }
];

const ADDITIONAL_CONTEXT = new InjectionToken('ADDITIONAL_CONTEXT');

function parseTemplate(value = '', obj = {}) {
    if (!value.includes('{{')) {
        return obj[value];
    }
    else {
        const lookUp = new RegExp(`{{(.*?)}}`);
        while (lookUp.test(value)) {
            value = value.replace(lookUp, (RegExp.$1)
                .split('.')
                .reduce((acc, cur) => acc[cur], obj));
        }
        return value;
    }
}

const ROLE = new InjectionToken('ROLE');

class SelectComponent extends FieldComponent {
    constructor(cData, dbService, role, additionalContext) {
        super(cData);
        this.cData = cData;
        this.dbService = dbService;
        this.role = role;
        this.additionalContext = additionalContext;
        this.loading$ = new BehaviorSubject(true);
    }
    ngOnInit() {
        if (this.cData.populate) {
            const populate = this.cData.populate;
            const mapResults = populate.mapResults ? safeEval(populate.mapResults) : null;
            const documentsMethod = (query) => {
                this.loading$.next(true);
                if (!query) {
                    this.loading$.next(false);
                    return of([]);
                }
                if (query.filter && typeof query.filter === 'string') {
                    return this.dbService.getDocument(query.collection, query.filter)
                        .pipe(map(it => {
                        return (mapResults ? mapResults(it) : [it]).map((doc) => ({
                            value: doc[populate.valueKey || 'id'],
                            name: parseTemplate(populate.nameKey || 'name', doc)
                        }));
                    }), tap(() => this.loading$.next(false)));
                }
                return this.dbService
                    .getDocumentsSimple(query.collection, query.orderBy, query.filter)
                    .pipe(map(docs => {
                    if (mapResults) {
                        docs = mapResults(docs, {
                            fieldData: this.cData,
                            value: this.cData.form.getRawValue(),
                            role: this.role,
                            additionalContext: this.additionalContext
                        });
                    }
                    return docs.map(doc => ({
                        value: doc[populate.valueKey || 'id'],
                        name: parseTemplate(populate.nameKey || 'name', doc)
                    }));
                }), tap(() => this.loading$.next(false)));
            };
            if (populate.dependency) {
                const pointer = this.cData.pointers[populate.dependency.key];
                const gm = safeEval(populate.dependency.method);
                this.dataSet$ = pointer.control.valueChanges
                    .pipe(startWith(pointer.control.value), switchMap(value => documentsMethod(gm(value, {
                    fieldData: this.cData,
                    value: this.cData.form.getRawValue(),
                    role: this.role,
                    additionalContext: this.additionalContext
                }))));
            }
            else {
                let filter = populate.filter;
                if (populate.dynamicFilter) {
                    filter = safeEval(populate.dynamicFilter)({
                        fieldData: this.cData,
                        value: this.cData.form.getRawValue(),
                        role: this.role,
                        additionalContext: this.additionalContext
                    });
                }
                this.dataSet$ = documentsMethod({
                    collection: populate.collection,
                    orderBy: populate.orderBy,
                    filter
                });
            }
        }
        else {
            this.dataSet$ = of(this.cData.dataSet);
        }
    }
}
SelectComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-select',
                template: "<mat-form-field class=\"w-full\" appearance=\"outline\" [class.mat-form-field-has-hint]=\"cData.hint\">\n  <mat-label>{{(cData.label || '') | transloco}}</mat-label>\n  <mat-select\n    [placeholder]=\"(cData.placeholder || '') | transloco\"\n    [formControl]=\"cData.control\"\n    [multiple]=\"cData.multiple\"\n    [attr.autocomplite]=\"cData.autocomplete || 'off'\">\n    <mat-option *ngFor=\"let data of dataSet$ | async\" [value]=\"data.value\" [disabled]=\"data.disabled\">\n      {{data.name}}\n    </mat-option>\n  </mat-select>\n  <mat-spinner\n    matSuffix\n    *ngIf=\"cData.populate && (loading$ | async)\"\n    [diameter]=\"20\"></mat-spinner>\n  <mat-hint *ngIf=\"cData.hint\" [innerHTML]=\"cData.hint | jpSanitize\"></mat-hint>\n</mat-form-field>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            },] }
];
SelectComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [COMPONENT_DATA,] }] },
    { type: DbService },
    { type: String, decorators: [{ type: Inject, args: [ROLE,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [ADDITIONAL_CONTEXT,] }] }
];

class SliderComponent extends FieldComponent {
    ngOnInit() {
        this.startAt = this.cData.starAt
            ? this.cData.starAt
            : this.cData.validation.minimum
                ? this.cData.validation.minimum
                : 0;
        this.endAt = this.cData.endAt
            ? this.cData.endAt
            : this.cData.validation.maximum
                ? this.cData.validation.maximum
                : 100;
    }
}
SliderComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-slider',
                template: "<div class=\"mat-form-field-wrapper\">\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.label\">{{(cData.label || '') | transloco}}</p>\n  <mat-slider\n    [formControl]=\"cData.control\"\n    [thumbLabel]=\"cData.thumbLabel\"\n    [tickInterval]=\"cData.tickInterval\"\n    [min]=\"startAt\"\n    [max]=\"endAt\">\n  </mat-slider>\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.hint\">\n    {{(cData.hint || '') | transloco}}\n  </p>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            },] }
];

class TextareaComponent extends FieldComponent {
    ngOnInit() {
        this.prefix$ = getHsd('prefix', this.cData);
        this.suffix$ = getHsd('suffix', this.cData);
    }
}
TextareaComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-textarea',
                template: "<mat-form-field class=\"w-full\" appearance=\"outline\">\n  <mat-label>{{(cData.label || '') | transloco}}</mat-label>\n  <textarea\n    matInput\n    [placeholder]=\"(cData.placeholder || '') | transloco\"\n    [attr.autocomplete]=\"cData.autocomplete || 'on'\"\n    [rows]=\"cData.rows\"\n    [cols]=\"cData.cols\"\n    [formControl]=\"cData.control\">\n  </textarea>\n  <mat-hint *ngIf=\"cData.hint\" [innerHTML]=\"cData.hint | jpSanitize\"></mat-hint>\n  <span *ngIf=\"cData.suffix\" matSuffix [innerHTML]=\"((suffix$ | async) || '') | jpSanitize\"></span>\n  <span *ngIf=\"cData.prefix\" matPrefix [innerHTML]=\"((prefix$ | async) || '') | jpSanitize\"></span>\n</mat-form-field>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            },] }
];

class ToggleComponent extends FieldComponent {
}
ToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-toggle',
                template: "<div class=\"mat-form-field-wrapper\">\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.label\">{{(cData.label || '') | transloco}}</p>\n  <mat-slide-toggle [formControl]=\"cData.control\"></mat-slide-toggle>\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.hint\">\n    {{(cData.hint || '') | transloco}}\n  </p>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            },] }
];

class WysiwygComponent extends FieldComponent {
    constructor(cData, fb, dialog, storage, formBuilderComponent) {
        super(cData);
        this.cData = cData;
        this.fb = fb;
        this.dialog = dialog;
        this.storage = storage;
        this.formBuilderComponent = formBuilderComponent;
        this.ytDefault = {
            fullWidth: true,
            showPlayerControls: true,
            privacyEnhancedMode: false,
            align: 'left'
        };
    }
    ngOnInit() {
        this.ytForm = this.fb.group(Object.assign({ value: ['', Validators.required] }, this.ytDefault));
        this.cData.control.statusChanges.subscribe(value => {
            if (value === 'DISABLED') {
                tinymce.activeEditor.getBody().setAttribute('readonly', true);
            }
            else if (this.cData.control.disabled) {
                tinymce.activeEditor.getBody().setAttribute('readonly', false);
            }
        });
    }
    ngAfterViewInit() {
        this.registerTiny();
    }
    registerTiny() {
        tinymce.init({
            target: this.textarea.nativeElement,
            branding: false,
            height: this.cData.height || 420,
            plugins: [
                'code',
                'print',
                'wordcount',
                'link',
                'lists',
                'advlist',
                'autolink',
                'image',
                'imagetools',
                'fullscreen',
                'table'
            ],
            menubar: this.cData.menubar || 'edit insert view format table tools help',
            image_advtab: true,
            /**
             * Link settings
             */
            default_link_target: '_blank',
            readonly: this.cData.control.disabled,
            toolbar: this.cData.toolbar || [
                'undo redo',
                'insert',
                'styleselect',
                'bold italic',
                'forecolor backcolor',
                'alignleft aligncenter alignright alignjustify',
                'bullist numlist outdent indent',
                'link',
                'image',
                'youTube',
                'fullscreen',
            ].join(' | '),
            images_upload_handler: (blobInfo, success, failure) => {
                this.storage
                    .upload(blobInfo.filename(), blobInfo.blob(), this.formBuilderComponent.id ? {
                    customMetadata: {
                        collection: this.formBuilderComponent.id
                    }
                } : {})
                    .then((data) => data.ref.getDownloadURL())
                    .then((url) => success(url))
                    .catch((error) => failure(error.toString()));
            },
            setup: (editor) => {
                this.editor = editor;
                editor.on('keyup change', () => {
                    const tinyContent = editor.getContent();
                    this.cData.control.setValue(tinyContent);
                });
                editor.ui.registry.addButton('youTube', {
                    type: 'button',
                    icon: 'embed',
                    tooltip: 'Embed youtube video',
                    onAction: () => {
                        this.ytForm.reset(this.ytDefault);
                        this.dialog
                            .open(this.youTubeDialogTemplate, { width: '500px' })
                            .afterClosed()
                            .pipe(filter(value => !!value), take(1))
                            .subscribe(() => {
                            const data = this.ytForm.getRawValue();
                            let url = data.privacyEnhancedMode
                                ? 'https://www.youtube-nocookie.com/embed/'
                                : 'https://www.youtube.com/embed/';
                            url = url + data.value;
                            if (!data.showPlayerControls) {
                                data.value += '?controls=0';
                            }
                            const iframe = `<iframe width="560" height="315" src="${url}" frameborder="0"
                    allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>`;
                            editor.insertContent(data.fullWidth
                                ? `<div class="evw-full" style="text-align: ${data.align}">${iframe}</div>`
                                : `<div style="text-align: ${data.align}">${iframe}</div>`);
                        });
                    }
                });
            }
        });
    }
}
WysiwygComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-wysiwyg',
                template: "<div class=\"mat-form-field-wrapper\">\n  <p class=\"fs-small fg-secondary\" *ngIf=\"cData.label\">{{(cData.label || '') | transloco}}</p>\n  <textarea #textarea role=\"textarea\">{{cData.control.value}}</textarea>\n</div>\n\n<ng-template #youTubeDialog>\n  <h1 mat-dialog-title>{{'FIELDS.WYSIWYG.EMBED_YOUTUBE' | transloco}}</h1>\n\n  <form [formGroup]=\"ytForm\">\n    <mat-dialog-content>\n      <mat-form-field class=\"w-full\">\n        <mat-label>{{'FIELDS.WYSIWYG.VIDEO_ID' | transloco}}</mat-label>\n        <input matInput formControlName=\"value\">\n      </mat-form-field>\n\n      <label class=\"mat-form-field-wrapper flex jc-between\">\n        <span>{{'FIELDS.WYSIWYG.FULL_WIDTH' | transloco}}</span>\n        <mat-slide-toggle formControlName=\"fullWidth\"></mat-slide-toggle>\n      </label>\n\n      <label class=\"mat-form-field-wrapper flex jc-between\">\n        <span>{{'FIELDS.WYSIWYG.SHOW_PLAYER_CONTROLS' | transloco}}</span>\n        <mat-slide-toggle formControlName=\"showPlayerControls\"></mat-slide-toggle>\n      </label>\n\n      <label class=\"mat-form-field-wrapper flex jc-between\">\n        <span>{{'FIELDS.WYSIWYG.PRIVACY_ENHANCED_MODE' | transloco}}</span>\n        <mat-slide-toggle formControlName=\"privacyEnhancedMode\"></mat-slide-toggle>\n      </label>\n\n      <mat-form-field class=\"w-full\">\n        <mat-label>{{'FIELDS.WYSIWYG.ALIGNMENT' | transloco}}</mat-label>\n        <mat-select formControlName=\"align\">\n          <mat-option value=\"left\">{{'FIELDS.WYSIWYG.LEFT' | transloco}}</mat-option>\n          <mat-option value=\"center\">{{'FIELDS.WYSIWYG.CENTER' | transloco}}</mat-option>\n          <mat-option value=\"right\">{{'FIELDS.WYSIWYG.RIGHT' | transloco}}</mat-option>\n        </mat-select>\n      </mat-form-field>\n    </mat-dialog-content>\n\n    <mat-dialog-actions class=\"jc-end\">\n      <button mat-button mat-dialog-close>{{'GENERAL.CLOSE' | transloco}}</button>\n      <button mat-raised-button color=\"primary\" [mat-dialog-close]=\"true\">{{'GENERAL.SAVE' | transloco}}</button>\n    </mat-dialog-actions>\n  </form>\n</ng-template>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [""]
            },] }
];
WysiwygComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [COMPONENT_DATA,] }] },
    { type: FormBuilder },
    { type: MatDialog },
    { type: StorageService },
    { type: FormBuilderComponent }
];
WysiwygComponent.propDecorators = {
    textarea: [{ type: ViewChild, args: ['textarea', { static: true },] }],
    youTubeDialogTemplate: [{ type: ViewChild, args: ['youTubeDialog', { static: true },] }]
};

const COMPONENT_TYPE_COMPONENT_MAP = {
    [ComponentType.Input]: InputComponent,
    [ComponentType.Toggle]: ToggleComponent,
    [ComponentType.Select]: SelectComponent,
    [ComponentType.File]: FileComponent,
    [ComponentType.Image]: ImageComponent,
    [ComponentType.Gallery]: GalleryComponent,
    [ComponentType.Checkbox]: CheckboxComponent,
    [ComponentType.Autocomplete]: AutocompleteComponent,
    [ComponentType.Date]: DateFieldComponent,
    [ComponentType.Range]: RangeComponent,
    [ComponentType.Slider]: SliderComponent,
    [ComponentType.Wysiwyg]: WysiwygComponent,
    [ComponentType.Draggable]: DraggableListComponent,
    [ComponentType.Radio]: RadioComponent,
    [ComponentType.Chips]: ChipsComponent,
    [ComponentType.Textarea]: TextareaComponent
};

var SchemaType;
(function (SchemaType) {
    SchemaType["Object"] = "object";
    SchemaType["Array"] = "array";
    // Simple
    SchemaType["String"] = "string";
    SchemaType["Number"] = "number";
    SchemaType["Integer"] = "integer";
    SchemaType["Boolean"] = "boolean";
    SchemaType["Null"] = "null";
})(SchemaType || (SchemaType = {}));

// @dynamic
class SchemaValidators {
    static multipleOf(num) {
        return (control) => {
            return control.value % num === 0 ? null : { multipleOf: num };
        };
    }
}

function schemaToComponent(schemaType) {
    switch (schemaType) {
        case SchemaType.String:
            return {
                type: ComponentType.Input,
                configuration: {
                    type: 'text'
                }
            };
        case SchemaType.Number:
        case SchemaType.Integer:
            return {
                type: ComponentType.Input,
                configuration: {
                    type: 'number'
                }
            };
        case SchemaType.Boolean:
            return {
                type: ComponentType.Checkbox
            };
        case SchemaType.Array:
            return {
                type: ComponentType.Chips
            };
    }
}

// @dynamic
class Parser {
    constructor(schema, injector, state, role, definitions = {}, customFields = {}) {
        this.schema = schema;
        this.injector = injector;
        this.state = state;
        this.role = role;
        this.definitions = definitions;
        this.customFields = customFields;
        this.pointers = {};
    }
    static standardizeKey(key) {
        if (key[0] === '/') {
            key = key.slice(1, key.length);
        }
        return key;
    }
    static stringControl(definition, required) {
        const controlValidation = [];
        const validation = {};
        if (required) {
            controlValidation.push(Validators.required);
            validation.required = true;
        }
        if (definition.maxLength) {
            controlValidation.push(Validators.maxLength(definition.maxLength));
            validation.maxLength = definition.maxLength;
        }
        if (definition.minLength) {
            controlValidation.push(Validators.minLength(definition.minLength));
            validation.minLength = definition.minLength;
        }
        if (definition.pattern) {
            controlValidation.push(Validators.pattern(definition.pattern));
            validation.patter = definition.pattern;
        }
        return {
            control: new FormControl(definition.default || '', controlValidation),
            validation
        };
    }
    static numberControl(definition, required) {
        const validation = {};
        const controlValidation = [];
        if (required) {
            controlValidation.push(Validators.required);
            validation.required = true;
        }
        if (definition.minimum) {
            const minimum = definition.minimum + (definition.exclusiveMinimum ? 1 : 0);
            controlValidation.push(Validators.min(minimum));
            validation.minimum = minimum;
        }
        if (definition.maximum) {
            const maximum = definition.maximum - (definition.exclusiveMaximum ? 1 : 0);
            controlValidation.push(Validators.max(maximum));
            validation.maximum = maximum;
        }
        if (definition.multipleOf) {
            controlValidation.push(SchemaValidators.multipleOf(definition.multipleOf));
            validation.multipleOf = definition.multipleOf;
        }
        return {
            control: new FormControl(definition.default || null, controlValidation),
            validation
        };
    }
    static booleanControl(definition, required) {
        const controlValidation = [];
        const validation = {};
        if (required) {
            controlValidation.push(Validators.required);
            validation.required = true;
        }
        return {
            control: new FormControl(definition.default || false, controlValidation),
            validation
        };
    }
    buildForm(value, required = [], base = '/', addId = true) {
        const properties = this.buildProperties(this.schema.properties || {}, required, base, addId);
        this.form = properties.form;
        this.pointers = properties.pointers;
        if (value) {
            this.form.patchValue(value);
        }
        return this.form;
    }
    buildProperties(properties, required = [], base = '/', addId = true) {
        const { form, pointers } = [
            ...Object.entries(properties),
            /**
             * Add the id field as a property so that
             * it can be added to the form if needed
             */
            ...(addId
                ? [
                    [
                        'id',
                        {
                            type: 'string'
                        }
                    ]
                ]
                : [])
        ].reduce((group, [key, value]) => {
            const isRequired = required.includes(key);
            let parsed;
            switch (value.type) {
                case SchemaType.String:
                    parsed = Parser.stringControl(value, isRequired);
                    break;
                case SchemaType.Number:
                case SchemaType.Integer:
                    parsed = Parser.numberControl(value, isRequired);
                    break;
                case SchemaType.Boolean:
                    parsed = Parser.booleanControl(value, isRequired);
                    break;
                case SchemaType.Object:
                    const objectProperties = this.buildProperties(
                    /**
                     * Supporting both {type: 'object', properties: {}} and
                     * {type: 'object', items: {properties: {}}}
                     */
                    value.properties || (value.items && value.items.properties ? value.items.properties : {}), value.required || value.items && value.items.required ? value.items.required : [], base + key + '/', false);
                    for (const added in objectProperties.pointers) {
                        if (objectProperties.pointers.hasOwnProperty(added)) {
                            // @ts-ignore
                            group.pointers[added] = objectProperties.pointers[added];
                        }
                    }
                    parsed = {
                        control: objectProperties.form,
                        validation: {}
                    };
                    break;
                case SchemaType.Array:
                    parsed = this.buildArray(base, value);
                    break;
            }
            const pointerKey = base + key;
            const definition = this.getFromDefinitions(pointerKey) || {};
            // @ts-ignore
            group.form[key] = parsed.control;
            // @ts-ignore
            group.pointers[pointerKey] = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ key, type: value.type }, definition.formatOnLoad
                && { formatOnLoad: safeEval(definition.formatOnLoad) }), definition.formatOnSave
                && { formatOnSave: safeEval(definition.formatOnSave) }), definition.formatOnCreate
                && { formatOnCreate: safeEval(definition.formatOnCreate) }), definition.formatOnEdit
                && { formatOnEdit: safeEval(definition.formatOnEdit) }), parsed);
            return group;
        }, {
            form: {},
            pointers: {}
        });
        return {
            pointers,
            form: new FormGroup(form)
        };
    }
    /**
     * @param pointerKey Lookup key for the pointer
     * @param pointer Entire pointer object that should be used
     * @param definitions Entire definitions object that should be used
     * @param single Defines if the field shown in the form or in the table
     * @param arrayRoot If the field is in an array what root lookup to use
     */
    field(pointerKey, pointer, definitions = {}, single = true, arrayRoot) {
        if (!pointer) {
            console.log('Pointers: ', this.pointers);
            throw new Error(`Couldn't find pointer for ${pointerKey}.`);
        }
        const { key, type, control, validation } = pointer;
        const definition = Object.assign({ label: key }, this.getFromDefinitions(pointerKey, definitions));
        if ((definition.disableOn &&
            (Array.isArray(definition.disableOn) ?
                definition.disableOn.includes(this.state)
                : definition.disableOn === this.state)) ||
            (definition.disableForRoles &&
                (Array.isArray(definition.disableForRoles) ?
                    definition.disableForRoles.includes(this.role)
                    : definition.disableForRoles === this.role))) {
            control.disable();
        }
        /**
         * We don't show labels in the table
         */
        if (!single) {
            definition.label = '';
        }
        if (!definition.component) {
            definition.component = schemaToComponent(type);
        }
        // @ts-ignore
        const component = COMPONENT_TYPE_COMPONENT_MAP[definition.component.type] || this.customFields[definition.component.type];
        if (!component) {
            // @ts-ignore
            throw new Error(`Couldn't find a component defined for type: ${definition.component.type}`);
        }
        const portal = new ComponentPortal(component, null, createComponentInjector(this.injector, Object.assign(Object.assign({ control,
            validation,
            single, pointers: this.pointers, form: this.form }, definition), (definition.component.configuration || {}))));
        return {
            pointer: pointerKey,
            control,
            portal,
            validation,
            placeholder: definition.placeholder || '',
            label: definition.label,
            onlyOn: definition.onlyOn
        };
    }
    addArrayItem(pointer, loadHooks = false, parentArray) {
        const pointers = parentArray ? this.pointers[parentArray.pointer].arrayPointers[parentArray.index] : this.pointers;
        const target = pointers[pointer];
        const control = pointers[pointer].control;
        if (target.arrayType === SchemaType.Array ||
            target.arrayType === SchemaType.Object) {
            const properties = this.buildProperties(target.properties, target.required, pointer + '/', false);
            if (loadHooks) {
                this.loadHooks(properties.pointers);
            }
            // @ts-ignore
            target.arrayPointers.unshift(properties.pointers);
            control.controls.unshift(properties.form);
            return properties.pointers;
        }
        else {
            const cont = new FormControl('');
            control.controls.unshift(cont);
            return cont;
        }
    }
    moveArrayItem(pointer, fromIndex, toIndex, parentArray) {
        const pointers = parentArray ? this.pointers[parentArray.pointer].arrayPointers[parentArray.index] : this.pointers;
        const target = pointers[pointer];
        const control = pointers[pointer].control;
        if (target.arrayType === SchemaType.Array ||
            target.arrayType === SchemaType.Object) {
            moveItemInArray(target.arrayPointers, fromIndex, toIndex);
        }
        moveItemInArray(control.controls, fromIndex, toIndex);
    }
    removeArrayItem(pointer, index, parentArray) {
        const pointers = parentArray ? this.pointers[parentArray.pointer].arrayPointers[parentArray.index] : this.pointers;
        pointers[pointer].arrayPointers.splice(index, 1);
        pointers[pointer].control.removeAt(index);
    }
    loadHooks(pointers = this.pointers) {
        Object.values(pointers).forEach(entry => {
            /**
             * TODO:
             * For the moment formatOn methods are
             * only supported on FormControls.
             * We might want to expand on this later on.
             */
            if (entry.control instanceof FormControl && entry.formatOnLoad) {
                const adjustedValue = entry.formatOnLoad(entry.control.value);
                if (adjustedValue !== entry.control.value) {
                    entry.control.setValue(adjustedValue);
                }
            }
        });
    }
    preSaveHooks(currentState, statesToProcess = [State.Create, State.Edit], pointers = this.pointers) {
        const preSaveData = this.form.getRawValue();
        Object.values(pointers).forEach(entry => {
            /**
             * TODO:
             * For the moment formatOn methods are
             * only supported on FormControls.
             * We might want to expand on this later on.
             */
            if (entry.control instanceof FormControl) {
                let value = entry.control.value;
                if (entry.formatOnSave) {
                    value = entry.formatOnSave(value, preSaveData);
                }
                if (statesToProcess.includes(currentState)) {
                    if (currentState === State.Edit && entry.formatOnEdit) {
                        value = entry.formatOnEdit(value, preSaveData);
                    }
                    else if (entry.formatOnCreate) {
                        value = entry.formatOnCreate(value, preSaveData);
                    }
                }
                if (value !== entry.control.value) {
                    entry.control.setValue(value);
                }
            }
            if (entry.arrayPointers) {
                entry.arrayPointers.forEach(arrayPointers => this.preSaveHooks(currentState, statesToProcess, arrayPointers));
            }
        });
    }
    getFromDefinitions(key, definitions = this.definitions) {
        return definitions[Parser.standardizeKey(key)];
    }
    /**
     * TODO:
     * - Handle contains case
     * - Handle items or contains as array not object
     */
    buildArray(base, definition) {
        if (!definition.items) {
            return Object.assign({ control: new FormControl([]) }, (definition.items
                ? {
                    arrayType: definition.items.type,
                    properties: definition.items.properties,
                    required: definition.items.required,
                    validation: {}
                }
                : {
                    arrayType: SchemaType.String,
                    validation: {}
                }));
        }
        else {
            return {
                arrayType: definition.items.type,
                properties: definition.items.properties,
                required: definition.items.required,
                validation: {},
                control: new FormArray([]),
                arrayPointers: []
            };
        }
    }
}

class FormBuilderComponent {
    constructor(injector, role, customFields, cdr, service) {
        this.injector = injector;
        this.role = role;
        this.customFields = customFields;
        this.cdr = cdr;
        this.service = service;
        this.valueChanges = new EventEmitter();
        this.validityChanges = new EventEmitter();
        this.state = State.Create;
    }
    ngOnChanges(changes) {
        if (changes.data) {
            this.render();
        }
        if (changes.value && this.form) {
            this.form.patchValue(changes.value.currentValue);
        }
    }
    ngOnDestroy() {
        if (this.changeSubscription) {
            this.changeSubscription.unsubscribe();
        }
        if (this.statusSubscription) {
            this.statusSubscription.unsubscribe();
        }
    }
    process() {
        this.parser.preSaveHooks(this.state);
        return this.form.getRawValue();
    }
    save(collectionId, documentId) {
        const toExec = this.service.saveComponents.map(comp => comp.save(collectionId, documentId));
        return toExec.length ? forkJoin(toExec) : of({});
    }
    saveAndProcess(collectionId, documentId) {
        this.process();
        return this.save(collectionId, documentId);
    }
    render() {
        const value = this.data.value || {};
        const definitions = this.data.definitions || {};
        this.parser = new Parser(this.data.schema, this.injector, this.state, this.role, definitions, this.customFields);
        this.form = this.parser.buildForm(value, [], '/', false);
        this.parser.loadHooks();
        this.segments = filterAndCompileSegments(this.data.segments ||
            [{
                    title: '',
                    fields: Object.keys(this.parser.pointers),
                    columnsDesktop: 12,
                    type: SegmentType.Empty
                }], this.parser, definitions, this.injector, value);
        if (this.changeSubscription) {
            this.changeSubscription.unsubscribe();
        }
        if (this.statusSubscription) {
            this.statusSubscription.unsubscribe();
        }
        this.changeSubscription = this.form.valueChanges
            .subscribe(val => {
            this.valueChanges.emit(val);
        });
        this.statusSubscription = this.form.statusChanges
            .subscribe(val => {
            this.validityChanges.emit(val === 'VALID');
        });
        this.cdr.markForCheck();
    }
}
FormBuilderComponent.decorators = [
    { type: Component, args: [{
                selector: 'fb-form-builder',
                template: "<div class=\"grid\">\n  <ng-container *ngFor=\"let segment of segments\">\n    <ng-template [cdkPortalOutlet]=\"segment.component\"></ng-template>\n  </ng-container>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [FormBuilderService]
            },] }
];
FormBuilderComponent.ctorParameters = () => [
    { type: Injector },
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ROLE,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CUSTOM_FIELDS,] }] },
    { type: ChangeDetectorRef },
    { type: FormBuilderService }
];
FormBuilderComponent.propDecorators = {
    data: [{ type: Input }],
    value: [{ type: Input }],
    id: [{ type: Input }],
    valueChanges: [{ type: Output }],
    validityChanges: [{ type: Output }],
    state: [{ type: Input }]
};

class DropzoneDirective {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.hoverClass = 'active';
        this.dropped = new EventEmitter();
        this.hovered = new EventEmitter();
    }
    onDrop($event) {
        $event.preventDefault();
        this.dropped.emit($event.dataTransfer.files);
        this.renderer.removeClass(this.el.nativeElement, this.hoverClass);
        this.hovered.emit(false);
    }
    onDragOver($event) {
        $event.preventDefault();
        this.renderer.addClass(this.el.nativeElement, this.hoverClass);
        this.hovered.emit(true);
    }
    onDragLeave($event) {
        $event.preventDefault();
        this.renderer.removeClass(this.el.nativeElement, this.hoverClass);
        this.hovered.emit(false);
    }
}
DropzoneDirective.decorators = [
    { type: Directive, args: [{
                selector: '[fbDropzone]'
            },] }
];
DropzoneDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
DropzoneDirective.propDecorators = {
    hoverClass: [{ type: Input }],
    dropped: [{ type: Output }],
    hovered: [{ type: Output }],
    onDrop: [{ type: HostListener, args: ['drop', ['$event'],] }],
    onDragOver: [{ type: HostListener, args: ['dragover', ['$event'],] }],
    onDragLeave: [{ type: HostListener, args: ['dragleave', ['$event'],] }]
};

class ShowFieldPipe {
    transform(fields, parser) {
        return fields.filter(field => !field.onlyOn ||
            (Array.isArray(field.onlyOn) ?
                field.onlyOn.includes(parser.state) :
                field.onlyOn === parser.state));
    }
}
ShowFieldPipe.decorators = [
    { type: Pipe, args: [{
                name: 'showField'
            },] }
];

class FormBuilderModule {
}
FormBuilderModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    /**
                     * Fields
                     */
                    FieldComponent,
                    AutocompleteComponent,
                    CheckboxComponent,
                    ChipsComponent,
                    DateFieldComponent,
                    RangeComponent,
                    DraggableListComponent,
                    FileComponent,
                    GalleryComponent,
                    ImageComponent,
                    InputComponent,
                    RadioComponent,
                    SelectComponent,
                    SliderComponent,
                    TextareaComponent,
                    ToggleComponent,
                    WysiwygComponent,
                    /**
                     * Segments
                     */
                    SegmentComponent,
                    AccordionComponent,
                    CardComponent,
                    EmptyComponent,
                    StepperComponent,
                    TabsComponent,
                    /**
                     * Directives
                     */
                    DropzoneDirective,
                    /**
                     * Pipes
                     */
                    ShowFieldPipe,
                    FormBuilderComponent
                ],
                imports: [
                    CommonModule,
                    ReactiveFormsModule,
                    /**
                     * Material
                     */
                    MatFormFieldModule,
                    MatInputModule,
                    MatButtonModule,
                    MatAutocompleteModule,
                    MatSelectModule,
                    MatSliderModule,
                    MatSlideToggleModule,
                    MatCheckboxModule,
                    MatChipsModule,
                    MatIconModule,
                    MatDatepickerModule,
                    MatNativeDateModule,
                    DragDropModule,
                    MatDialogModule,
                    MatTooltipModule,
                    MatProgressSpinnerModule,
                    MatExpansionModule,
                    MatDividerModule,
                    PortalModule,
                    MatCardModule,
                    MatTabsModule,
                    MatRadioModule,
                    /**
                     * Jp Helpers
                     */
                    SanitizeModule,
                    /**
                     * Other
                     */
                    TranslocoModule
                ],
                exports: [FormBuilderComponent]
            },] }
];

/**
 * Public API Surface of form-builder
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ADDITIONAL_CONTEXT, COMPONENT_DATA, CUSTOM_FIELDS, ComponentType, DbService, FieldComponent, FormBuilderComponent, FormBuilderModule, FormBuilderService, Parser, ROLE, STORAGE_URL, SchemaType, SegmentType, State, StorageService, cloneAbstractControl, formatFileName, formatGeneratedImages, parseTemplate, safeEval, switchItemLocations, AutocompleteComponent as ɵa, CheckboxComponent as ɵb, ChipsComponent as ɵc, DateFieldComponent as ɵd, RangeComponent as ɵe, DraggableListComponent as ɵf, FileComponent as ɵg, GalleryComponent as ɵh, ImageComponent as ɵi, InputComponent as ɵj, RadioComponent as ɵk, SelectComponent as ɵl, SliderComponent as ɵm, TextareaComponent as ɵn, ToggleComponent as ɵo, WysiwygComponent as ɵp, SegmentComponent as ɵq, SEGMENT_DATA as ɵr, AccordionComponent as ɵs, CardComponent as ɵt, EmptyComponent as ɵu, StepperComponent as ɵv, TabsComponent as ɵw, DropzoneDirective as ɵx, ShowFieldPipe as ɵy };
//# sourceMappingURL=jaspero-form-builder.js.map
