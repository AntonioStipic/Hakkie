import { ComponentPortal } from '@angular/cdk/portal';
import { SEGMENT_TYPE_COMPONENT_MAP } from '../consts/segment-type-component-map.const';
import { SegmentType } from '../enums/segment-type.enum';
import { ConditionAction, ConditionEvaluate, ConditionType } from '../interfaces/condition.interface';
import { createSegmentInjector } from './create-segment-injector';
import { safeEval } from './safe-eval';
export function compileSegment(segment, parser, definitions, injector, entryValue, parent = '') {
    const classes = [];
    let fields = [];
    if (segment.columnsDesktop) {
        classes.push(`col-${segment.columnsDesktop}`);
    }
    if (segment.columnsTablet) {
        classes.push(`col-m-${segment.columnsTablet}`);
    }
    if (segment.columnsMobile) {
        classes.push(`col-s-${segment.columnsMobile}`);
    }
    /**
     * If there aren't any column definitions
     * default to full width
     */
    if (!classes.length) {
        classes.push('col-12');
    }
    if (segment.classes) {
        classes.push(...segment.classes);
    }
    if (segment.fields) {
        /**
         * If it's an array fields aren' parsed
         */
        if (segment.array) {
            // @ts-ignore
            fields = (segment.fields || []).map(fi => segment.array + fi);
        }
        else {
            fields = (segment.fields || [])
                // @ts-ignore
                .reduce((acc, key) => {
                const definition = parser.getFromDefinitions(key, definitions);
                if (!definition ||
                    !definition.roles ||
                    (typeof definition.roles === 'string' ?
                        definition.roles === parser.role :
                        definition.roles.includes(parser.role))) {
                    acc.push(parser.field(key, parser.pointers[key], definitions));
                }
                return acc;
            }, []);
        }
    }
    const compiledSegment = Object.assign(Object.assign({}, segment), { classes,
        fields,
        entryValue });
    /**
     * TODO:
     * Statement support
     */
    if (segment.conditions) {
        compiledSegment.conditions = [];
        const valToPass = entryValue || {};
        for (const cur of segment.conditions) {
            let condition;
            const type = cur.type || ConditionType.Function;
            const action = cur.action || ConditionAction.Show;
            const evaluateOn = cur.evaluateOn || ConditionEvaluate.OnLoad;
            const evaluateStates = cur.evaluateStates || [0, 1, 2];
            if (cur.condition) {
                condition = safeEval(cur.condition);
            }
            if (condition) {
                /**
                 * Evaluate on load conditions
                 */
                if (evaluateOn === ConditionEvaluate.OnLoad) {
                    /**
                     * Check if items should be excluded right away
                     */
                    if ((action === ConditionAction.Show && !condition(valToPass)) ||
                        (action === ConditionAction.Hide && condition(valToPass))) {
                        return null;
                    }
                }
                compiledSegment.conditions.push(Object.assign({ condition,
                    type,
                    action,
                    evaluateStates,
                    evaluateOn }, cur.data && {
                    data: cur.data
                }));
            }
        }
    }
    return Object.assign({ component: new ComponentPortal(SEGMENT_TYPE_COMPONENT_MAP[segment.type || SegmentType.Card], null, createSegmentInjector(injector, Object.assign({ segment: compiledSegment, parser,
            definitions }, parent && { parent }))) }, compiledSegment);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGlsZS1zZWdtZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvZm9ybS1idWlsZGVyL3NyYy9saWIvdXRpbHMvY29tcGlsZS1zZWdtZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUVwRCxPQUFPLEVBQUMsMEJBQTBCLEVBQUMsTUFBTSw0Q0FBNEMsQ0FBQztBQUN0RixPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sNEJBQTRCLENBQUM7QUFHdkQsT0FBTyxFQUFvQixlQUFlLEVBQUUsaUJBQWlCLEVBQUUsYUFBYSxFQUFDLE1BQU0sbUNBQW1DLENBQUM7QUFJdkgsT0FBTyxFQUFDLHFCQUFxQixFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFFaEUsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUVyQyxNQUFNLFVBQVUsY0FBYyxDQUM1QixPQUFnQixFQUNoQixNQUFjLEVBQ2QsV0FBd0IsRUFDeEIsUUFBa0IsRUFDbEIsVUFBZSxFQUNmLE1BQU0sR0FBRyxFQUFFO0lBRVgsTUFBTSxPQUFPLEdBQWEsRUFBRSxDQUFDO0lBRTdCLElBQUksTUFBTSxHQUErQixFQUFFLENBQUM7SUFFNUMsSUFBSSxPQUFPLENBQUMsY0FBYyxFQUFFO1FBQzFCLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxPQUFPLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQztLQUMvQztJQUVELElBQUksT0FBTyxDQUFDLGFBQWEsRUFBRTtRQUN6QixPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsT0FBTyxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUM7S0FDaEQ7SUFFRCxJQUFJLE9BQU8sQ0FBQyxhQUFhLEVBQUU7UUFDekIsT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLE9BQU8sQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO0tBQ2hE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U0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQ3pEO3dCQUNBLE9BQU8sSUFBSSxDQUFDO3FCQUNiO2lCQUNGO2dCQUVELGVBQWUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLGdCQUM5QixTQUFTO29CQUNULElBQUk7b0JBQ0osTUFBTTtvQkFDTixjQUFjO29CQUNkLFVBQVUsSUFDUCxHQUFHLENBQUMsSUFBSSxJQUFJO29CQUNiLElBQUksRUFBRSxHQUFHLENBQUMsSUFBSTtpQkFDZixDQUNtQixDQUFDLENBQUM7YUFDekI7U0FDRjtLQUNGO0lBRUQsT0FBTyxnQkFDTCxTQUFTLEVBQUUsSUFBSSxlQUFlLENBQzVCLDBCQUEwQixDQUFDLE9BQU8sQ0FBQyxJQUFJLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxFQUM1RCxJQUFJLEVBQ0oscUJBQXFCLENBQUMsUUFBUSxrQkFDNUIsT0FBTyxFQUFFLGVBQWUsRUFDeEIsTUFBTTtZQUNOLFdBQVcsSUFDUixNQUFNLElBQUksRUFBQyxNQUFNLEVBQUMsRUFDckIsQ0FDSCxJQUNFLGVBQWUsQ0FDQSxDQUFDO0FBQ3ZCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0NvbXBvbmVudFBvcnRhbH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XG5pbXBvcnQge0luamVjdG9yfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7U0VHTUVOVF9UWVBFX0NPTVBPTkVOVF9NQVB9IGZyb20gJy4uL2NvbnN0cy9zZWdtZW50LXR5cGUtY29tcG9uZW50LW1hcC5jb25zdCc7XG5pbXBvcnQge1NlZ21lbnRUeXBlfSBmcm9tICcuLi9lbnVtcy9zZWdtZW50LXR5cGUuZW51bSc7XG5pbXBvcnQge0NvbXBpbGVkRmllbGR9IGZyb20gJy4uL2ludGVyZmFjZXMvY29tcGlsZWQtZmllbGQuaW50ZXJmYWNlJztcbmltcG9ydCB7Q29tcGlsZWRTZWdtZW50fSBmcm9tICcuLi9pbnRlcmZhY2VzL2NvbXBpbGVkLXNlZ21lbnQuaW50ZXJmYWNlJztcbmltcG9ydCB7Q29tcGlsZWRDb25kaXRpb24sIENvbmRpdGlvbkFjdGlvbiwgQ29uZGl0aW9uRXZhbHVhdGUsIENvbmRpdGlvblR5cGV9IGZyb20gJy4uL2ludGVyZmFjZXMvY29uZGl0aW9uLmludGVyZmFjZSc7XG5pbXBvcnQge0RlZmluaXRpb25zfSBmcm9tICcuLi9pbnRlcmZhY2VzL2RlZmluaXRpb25zLmludGVyZmFjZSc7XG5pbXBvcnQge1NlZ21lbnR9IGZyb20gJy4uL2ludGVyZmFjZXMvc2VnbWVudC5pbnRlcmZhY2UnO1xuaW1wb3J0IHtTZWdtZW50Q29tcG9uZW50fSBmcm9tICcuLi9zZWdtZW50L3NlZ21lbnQuY29tcG9uZW50JztcbmltcG9ydCB7Y3JlYXRlU2VnbWVudEluamVjdG9yfSBmcm9tICcuL2NyZWF0ZS1zZWdtZW50LWluamVjdG9yJztcbmltcG9ydCB7UGFyc2VyfSBmcm9tICcuL3BhcnNlcic7XG5pbXBvcnQge3NhZmVFdmFsfSBmcm9tICcuL3NhZmUtZXZhbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlU2VnbWVudChcbiAgc2VnbWVudDogU2VnbWVudCxcbiAgcGFyc2VyOiBQYXJzZXIsXG4gIGRlZmluaXRpb25zOiBEZWZpbml0aW9ucyxcbiAgaW5qZWN0b3I6IEluamVjdG9yLFxuICBlbnRyeVZhbHVlOiBhbnksXG4gIHBhcmVudCA9ICcnXG4pIHtcbiAgY29uc3QgY2xhc3Nlczogc3RyaW5nW10gPSBbXTtcblxuICBsZXQgZmllbGRzOiBDb21waWxlZEZpZWxkW10gfCBzdHJpbmdbXSA9IFtdO1xuXG4gIGlmIChzZWdtZW50LmNvbHVtbnNEZXNrdG9wKSB7XG4gICAgY2xhc3Nlcy5wdXNoKGBjb2wtJHtzZWdtZW50LmNvbHVtbnNEZXNrdG9wfWApO1xuICB9XG5cbiAgaWYgKHNlZ21lbnQuY29sdW1uc1RhYmxldCkge1xuICAgIGNsYXNzZXMucHVzaChgY29sLW0tJHtzZWdtZW50LmNvbHVtbnNUYWJsZXR9YCk7XG4gIH1cblxuICBpZiAoc2VnbWVudC5jb2x1bW5zTW9iaWxlKSB7XG4gICAgY2xhc3Nlcy5wdXNoKGBjb2wtcy0ke3NlZ21lbnQuY29sdW1uc01vYmlsZX1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGVyZSBhcmVuJ3QgYW55IGNvbHVtbiBkZWZpbml0aW9uc1xuICAgKiBkZWZhdWx0IHRvIGZ1bGwgd2lkdGhcbiAgICovXG4gIGlmICghY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICBjbGFzc2VzLnB1c2goJ2NvbC0xMicpO1xuICB9XG5cbiAgaWYgKHNlZ21lbnQuY2xhc3Nlcykge1xuICAgIGNsYXNzZXMucHVzaCguLi5zZWdtZW50LmNsYXNzZXMpO1xuICB9XG5cbiAgaWYgKHNlZ21lbnQuZmllbGRzKSB7XG5cbiAgICAvKipcbiAgICAgKiBJZiBpdCdzIGFuIGFycmF5IGZpZWxkcyBhcmVuJyBwYXJzZWRcbiAgICAgKi9cbiAgICBpZiAoc2VnbWVudC5hcnJheSkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZmllbGRzID0gKHNlZ21lbnQuZmllbGRzIHx8IFtdKS5tYXAoZmkgPT4gc2VnbWVudC5hcnJheSArIGZpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmllbGRzID0gKHNlZ21lbnQuZmllbGRzIHx8IFtdKVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC5yZWR1Y2UoKGFjYzogQ29tcGlsZWRGaWVsZFtdLCBrZXk6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBwYXJzZXIuZ2V0RnJvbURlZmluaXRpb25zKGtleSwgZGVmaW5pdGlvbnMpO1xuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWRlZmluaXRpb24gfHxcbiAgICAgICAgICAgICFkZWZpbml0aW9uLnJvbGVzIHx8XG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgIHR5cGVvZiBkZWZpbml0aW9uLnJvbGVzID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5yb2xlcyA9PT0gcGFyc2VyLnJvbGUgOlxuICAgICAgICAgICAgICAgIGRlZmluaXRpb24ucm9sZXMuaW5jbHVkZXMocGFyc2VyLnJvbGUpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBhY2MucHVzaChcbiAgICAgICAgICAgICAgcGFyc2VyLmZpZWxkKGtleSwgcGFyc2VyLnBvaW50ZXJzW2tleV0sIGRlZmluaXRpb25zKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY29tcGlsZWRTZWdtZW50ID0ge1xuICAgIC4uLnNlZ21lbnQsXG4gICAgY2xhc3NlcyxcbiAgICBmaWVsZHMsXG4gICAgZW50cnlWYWx1ZVxuICB9IGFzIENvbXBpbGVkU2VnbWVudDtcblxuICAvKipcbiAgICogVE9ETzpcbiAgICogU3RhdGVtZW50IHN1cHBvcnRcbiAgICovXG4gIGlmIChzZWdtZW50LmNvbmRpdGlvbnMpIHtcblxuICAgIGNvbXBpbGVkU2VnbWVudC5jb25kaXRpb25zID0gW107XG4gICAgY29uc3QgdmFsVG9QYXNzID0gZW50cnlWYWx1ZSB8fCB7fTtcblxuICAgIGZvciAoY29uc3QgY3VyIG9mIHNlZ21lbnQuY29uZGl0aW9ucykge1xuICAgICAgbGV0IGNvbmRpdGlvbjtcblxuICAgICAgY29uc3QgdHlwZSA9IGN1ci50eXBlIHx8IENvbmRpdGlvblR5cGUuRnVuY3Rpb247XG4gICAgICBjb25zdCBhY3Rpb24gPSBjdXIuYWN0aW9uIHx8IENvbmRpdGlvbkFjdGlvbi5TaG93O1xuICAgICAgY29uc3QgZXZhbHVhdGVPbiA9IGN1ci5ldmFsdWF0ZU9uIHx8IENvbmRpdGlvbkV2YWx1YXRlLk9uTG9hZDtcbiAgICAgIGNvbnN0IGV2YWx1YXRlU3RhdGVzID0gY3VyLmV2YWx1YXRlU3RhdGVzIHx8IFswLCAxLCAyXTtcblxuICAgICAgaWYgKGN1ci5jb25kaXRpb24pIHtcbiAgICAgICAgY29uZGl0aW9uID0gc2FmZUV2YWwoY3VyLmNvbmRpdGlvbiBhcyBzdHJpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZGl0aW9uKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2YWx1YXRlIG9uIGxvYWQgY29uZGl0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGV2YWx1YXRlT24gPT09IENvbmRpdGlvbkV2YWx1YXRlLk9uTG9hZCkge1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQ2hlY2sgaWYgaXRlbXMgc2hvdWxkIGJlIGV4Y2x1ZGVkIHJpZ2h0IGF3YXlcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoYWN0aW9uID09PSBDb25kaXRpb25BY3Rpb24uU2hvdyAmJiAhY29uZGl0aW9uKHZhbFRvUGFzcykpIHx8XG4gICAgICAgICAgICAoYWN0aW9uID09PSBDb25kaXRpb25BY3Rpb24uSGlkZSAmJiBjb25kaXRpb24odmFsVG9QYXNzKSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbXBpbGVkU2VnbWVudC5jb25kaXRpb25zLnB1c2goe1xuICAgICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICBldmFsdWF0ZVN0YXRlcyxcbiAgICAgICAgICBldmFsdWF0ZU9uLFxuICAgICAgICAgIC4uLmN1ci5kYXRhICYmIHtcbiAgICAgICAgICAgIGRhdGE6IGN1ci5kYXRhXG4gICAgICAgICAgfVxuICAgICAgICB9IGFzIENvbXBpbGVkQ29uZGl0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbXBvbmVudDogbmV3IENvbXBvbmVudFBvcnRhbDxTZWdtZW50Q29tcG9uZW50PihcbiAgICAgIFNFR01FTlRfVFlQRV9DT01QT05FTlRfTUFQW3NlZ21lbnQudHlwZSB8fCBTZWdtZW50VHlwZS5DYXJkXSxcbiAgICAgIG51bGwsXG4gICAgICBjcmVhdGVTZWdtZW50SW5qZWN0b3IoaW5qZWN0b3IsIHtcbiAgICAgICAgc2VnbWVudDogY29tcGlsZWRTZWdtZW50LFxuICAgICAgICBwYXJzZXIsXG4gICAgICAgIGRlZmluaXRpb25zLFxuICAgICAgICAuLi5wYXJlbnQgJiYge3BhcmVudH0sXG4gICAgICB9KVxuICAgICksXG4gICAgLi4uY29tcGlsZWRTZWdtZW50XG4gIH0gYXMgQ29tcGlsZWRTZWdtZW50O1xufVxuIl19