/**
 * @fileoverview added by tsickle
 * Generated from: lib/transloco.transpiler.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable, InjectionToken, Injector } from '@angular/core';
import { getValue, isString, isObject, setValue, isDefined } from './helpers';
/** @type {?} */
export var TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');
/**
 * @record
 */
export function TranslocoTranspiler() { }
if (false) {
    /**
     * @param {?} value
     * @param {?} params
     * @param {?} translation
     * @return {?}
     */
    TranslocoTranspiler.prototype.transpile = function (value, params, translation) { };
    /**
     * @param {?} lang
     * @return {?}
     */
    TranslocoTranspiler.prototype.onLangChanged = function (lang) { };
}
var DefaultTranspiler = /** @class */ (function () {
    function DefaultTranspiler() {
    }
    /**
     * @param {?} value
     * @param {?=} params
     * @param {?=} translation
     * @return {?}
     */
    DefaultTranspiler.prototype.transpile = /**
     * @param {?} value
     * @param {?=} params
     * @param {?=} translation
     * @return {?}
     */
    function (value, params, translation) {
        var _this = this;
        if (params === void 0) { params = {}; }
        if (isString(value)) {
            return value.replace(/{{(.*?)}}/g, (/**
             * @param {?} _
             * @param {?} match
             * @return {?}
             */
            function (_, match) {
                match = match.trim();
                if (isDefined(params[match])) {
                    return params[match];
                }
                return isDefined(translation[match]) ? _this.transpile(translation[match], params, translation) : '';
            }));
        }
        if (isObject(value) && params) {
            value = this.handleObject(value, params, translation);
        }
        return value;
    };
    /**
     *
     * @example
     *
     * const en = {
     *  a: {
     *    b: {
     *      c: "Hello {{ value }}"
     *    }
     *  }
     * }
     *
     * const params =  {
     *  "b.c": { value: "Transloco "}
     * }
     *
     * service.selectTranslate('a', params);
     *
     * // the first param will be the result of `en.a`.
     * // the second param will be `params`.
     * parser.transpile(value, params, {});
     *
     *
     */
    /**
     *
     * \@example
     *
     * const en = {
     *  a: {
     *    b: {
     *      c: "Hello {{ value }}"
     *    }
     *  }
     * }
     *
     * const params =  {
     *  "b.c": { value: "Transloco "}
     * }
     *
     * service.selectTranslate('a', params);
     *
     * // the first param will be the result of `en.a`.
     * // the second param will be `params`.
     * parser.transpile(value, params, {});
     *
     *
     * @protected
     * @param {?} value
     * @param {?=} params
     * @param {?=} translation
     * @return {?}
     */
    DefaultTranspiler.prototype.handleObject = /**
     *
     * \@example
     *
     * const en = {
     *  a: {
     *    b: {
     *      c: "Hello {{ value }}"
     *    }
     *  }
     * }
     *
     * const params =  {
     *  "b.c": { value: "Transloco "}
     * }
     *
     * service.selectTranslate('a', params);
     *
     * // the first param will be the result of `en.a`.
     * // the second param will be `params`.
     * parser.transpile(value, params, {});
     *
     *
     * @protected
     * @param {?} value
     * @param {?=} params
     * @param {?=} translation
     * @return {?}
     */
    function (value, params, translation) {
        var _this = this;
        if (params === void 0) { params = {}; }
        /** @type {?} */
        var result = value;
        Object.keys(params).forEach((/**
         * @param {?} p
         * @return {?}
         */
        function (p) {
            // get the value of "b.c" inside "a" => "Hello {{ value }}"
            /** @type {?} */
            var v = getValue(result, p);
            // get the params of "b.c" => { value: "Transloco" }
            /** @type {?} */
            var getParams = getValue(params, p);
            // transpile the value => "Hello Transloco"
            /** @type {?} */
            var transpiled = _this.transpile(v, getParams, translation);
            // set "b.c" to `transpiled`
            result = setValue(result, p, transpiled);
        }));
        return result;
    };
    return DefaultTranspiler;
}());
export { DefaultTranspiler };
/**
 * @record
 */
export function TranslocoTranspilerFunction() { }
if (false) {
    /**
     * @param {...?} args
     * @return {?}
     */
    TranslocoTranspilerFunction.prototype.transpile = function (args) { };
}
/**
 * @param {?} argsString
 * @return {?}
 */
export function getFunctionArgs(argsString) {
    /** @type {?} */
    var splitted = argsString ? argsString.split(',') : [];
    /** @type {?} */
    var args = [];
    for (var i = 0; i < splitted.length; i++) {
        /** @type {?} */
        var value = splitted[i].trim();
        while (value[value.length - 1] === '\\') {
            i++;
            value = value.replace('\\', ',') + splitted[i];
        }
        args.push(value);
    }
    return args;
}
var FunctionalTranspiler = /** @class */ (function (_super) {
    tslib_1.__extends(FunctionalTranspiler, _super);
    function FunctionalTranspiler(injector) {
        var _this = _super.call(this) || this;
        _this.injector = injector;
        return _this;
    }
    /**
     * @param {?} value
     * @param {?=} params
     * @param {?=} translation
     * @return {?}
     */
    FunctionalTranspiler.prototype.transpile = /**
     * @param {?} value
     * @param {?=} params
     * @param {?=} translation
     * @return {?}
     */
    function (value, params, translation) {
        var _this = this;
        if (params === void 0) { params = {}; }
        if (isString(value)) {
            /** @type {?} */
            var transpiled = value.replace(/\[\[\s*(\w+)\((.*)\)\s*]]/g, (/**
             * @param {?} match
             * @param {?} functionName
             * @param {?} args
             * @return {?}
             */
            function (match, functionName, args) {
                try {
                    /** @type {?} */
                    var func = _this.injector.get(functionName);
                    return func.transpile.apply(func, tslib_1.__spread(getFunctionArgs(args)));
                }
                catch (e) {
                    /** @type {?} */
                    var message = "There is an error in: '" + value + "'. \n                          Check that the you used the right syntax in your translation and that the implementation of " + functionName + " is correct.";
                    if (e.message.includes('NullInjectorError')) {
                        message = "You are using the '" + functionName + "' function in your translation but no provider was found!";
                    }
                    throw new Error(message);
                }
            }));
            return _super.prototype.transpile.call(this, transpiled, params, translation);
        }
        if (isObject(value) && params) {
            value = this.handleObject(value, params, translation);
        }
        return value;
    };
    FunctionalTranspiler.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    FunctionalTranspiler.ctorParameters = function () { return [
        { type: Injector }
    ]; };
    return FunctionalTranspiler;
}(DefaultTranspiler));
export { FunctionalTranspiler };
if (false) {
    /**
     * @type {?}
     * @private
     */
    FunctionalTranspiler.prototype.injector;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsb2NvLnRyYW5zcGlsZXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbmduZWF0L3RyYW5zbG9jby8iLCJzb3VyY2VzIjpbImxpYi90cmFuc2xvY28udHJhbnNwaWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFckUsT0FBTyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsTUFBTSxXQUFXLENBQUM7O0FBRTlFLE1BQU0sS0FBTyxvQkFBb0IsR0FBRyxJQUFJLGNBQWMsQ0FBQyxzQkFBc0IsQ0FBQzs7OztBQUU5RSx5Q0FHQzs7Ozs7Ozs7SUFGQyxvRkFBa0U7Ozs7O0lBQ2xFLGtFQUFtQzs7QUFHckM7SUFBQTtJQTZEQSxDQUFDOzs7Ozs7O0lBNURDLHFDQUFTOzs7Ozs7SUFBVCxVQUFVLEtBQVUsRUFBRSxNQUFvQixFQUFFLFdBQXdCO1FBQXBFLGlCQWlCQztRQWpCcUIsdUJBQUEsRUFBQSxXQUFvQjtRQUN4QyxJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNuQixPQUFPLEtBQUssQ0FBQyxPQUFPLENBQUMsWUFBWTs7Ozs7WUFBRSxVQUFDLENBQUMsRUFBRSxLQUFLO2dCQUMxQyxLQUFLLEdBQUcsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNyQixJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtvQkFDNUIsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQ3RCO2dCQUVELE9BQU8sU0FBUyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsRUFBRSxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxD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QkFDakQ7Z0JBQUMsT0FBTyxDQUFDLEVBQUU7O3dCQUNOLE9BQU8sR0FBRyw0QkFBMEIsS0FBSyxtSUFDK0QsWUFBWSxpQkFBYztvQkFDdEksSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFO3dCQUMzQyxPQUFPLEdBQUcsd0JBQXNCLFlBQVksOERBQTJELENBQUM7cUJBQ3pHO29CQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7aUJBQzFCO1lBQ0gsQ0FBQyxFQUNGO1lBRUQsT0FBTyxpQkFBTSxTQUFTLFlBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSxXQUFXLENBQUMsQ0FBQztTQUN6RDtRQUVELElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLE1BQU0sRUFBRTtZQUM3QixLQUFLLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLFdBQVcsQ0FBQyxDQUFDO1NBQ3ZEO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDOztnQkFsQ0YsVUFBVTs7OztnQkE3RjBCLFFBQVE7O0lBZ0k3QywyQkFBQztDQUFBLEFBbkNELENBQzBDLGlCQUFpQixHQWtDMUQ7U0FsQ1ksb0JBQW9COzs7Ozs7SUFDbkIsd0NBQTBCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIYXNoTWFwLCBUcmFuc2xhdGlvbiB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZ2V0VmFsdWUsIGlzU3RyaW5nLCBpc09iamVjdCwgc2V0VmFsdWUsIGlzRGVmaW5lZCB9IGZyb20gJy4vaGVscGVycyc7XG5cbmV4cG9ydCBjb25zdCBUUkFOU0xPQ09fVFJBTlNQSUxFUiA9IG5ldyBJbmplY3Rpb25Ub2tlbignVFJBTlNMT0NPX1RSQU5TUElMRVInKTtcblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2xvY29UcmFuc3BpbGVyIHtcbiAgdHJhbnNwaWxlKHZhbHVlOiBhbnksIHBhcmFtczogSGFzaE1hcCwgdHJhbnNsYXRpb246IEhhc2hNYXApOiBhbnk7XG4gIG9uTGFuZ0NoYW5nZWQ/KGxhbmc6IHN0cmluZyk6IHZvaWQ7XG59XG5cbmV4cG9ydCBjbGFzcyBEZWZhdWx0VHJhbnNwaWxlciBpbXBsZW1lbnRzIFRyYW5zbG9jb1RyYW5zcGlsZXIge1xuICB0cmFuc3BpbGUodmFsdWU6IGFueSwgcGFyYW1zOiBIYXNoTWFwID0ge30sIHRyYW5zbGF0aW9uOiBUcmFuc2xhdGlvbik6IGFueSB7XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL3t7KC4qPyl9fS9nLCAoXywgbWF0Y2gpID0+IHtcbiAgICAgICAgbWF0Y2ggPSBtYXRjaC50cmltKCk7XG4gICAgICAgIGlmIChpc0RlZmluZWQocGFyYW1zW21hdGNoXSkpIHtcbiAgICAgICAgICByZXR1cm4gcGFyYW1zW21hdGNoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpc0RlZmluZWQodHJhbnNsYXRpb25bbWF0Y2hdKSA/IHRoaXMudHJhbnNwaWxlKHRyYW5zbGF0aW9uW21hdGNoXSwgcGFyYW1zLCB0cmFuc2xhdGlvbikgOiAnJztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgcGFyYW1zKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlLCBwYXJhbXMsIHRyYW5zbGF0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogY29uc3QgZW4gPSB7XG4gICAqICBhOiB7XG4gICAqICAgIGI6IHtcbiAgICogICAgICBjOiBcIkhlbGxvIHt7IHZhbHVlIH19XCJcbiAgICogICAgfVxuICAgKiAgfVxuICAgKiB9XG4gICAqXG4gICAqIGNvbnN0IHBhcmFtcyA9ICB7XG4gICAqICBcImIuY1wiOiB7IHZhbHVlOiBcIlRyYW5zbG9jbyBcIn1cbiAgICogfVxuICAgKlxuICAgKiBzZXJ2aWNlLnNlbGVjdFRyYW5zbGF0ZSgnYScsIHBhcmFtcyk7XG4gICAqXG4gICAqIC8vIHRoZSBmaXJzdCBwYXJhbSB3aWxsIGJlIHRoZSByZXN1bHQgb2YgYGVuLmFgLlxuICAgKiAvLyB0aGUgc2Vjb25kIHBhcmFtIHdpbGwgYmUgYHBhcmFtc2AuXG4gICAqIHBhcnNlci50cmFuc3BpbGUodmFsdWUsIHBhcmFtcywge30pO1xuICAgKlxuICAgKlxuICAgKi9cbiAgcHJvdGVjdGVkIGhhbmRsZU9iamVjdCh2YWx1ZTogYW55LCBwYXJhbXM6IEhhc2hNYXAgPSB7fSwgdHJhbnNsYXRpb246IFRyYW5zbGF0aW9uKSB7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlO1xuICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaChwID0+IHtcbiAgICAgIC8vIGdldCB0aGUgdmFsdWUgb2YgXCJiLmNcIiBpbnNpZGUgXCJhXCIgPT4gXCJIZWxsbyB7eyB2YWx1ZSB9fVwiXG4gICAgICBjb25zdCB2ID0gZ2V0VmFsdWUocmVzdWx0LCBwKTtcbiAgICAgIC8vIGdldCB0aGUgcGFyYW1zIG9mIFwiYi5jXCIgPT4geyB2YWx1ZTogXCJUcmFuc2xvY29cIiB9XG4gICAgICBjb25zdCBnZXRQYXJhbXMgPSBnZXRWYWx1ZShwYXJhbXMsIHApO1xuXG4gICAgICAvLyB0cmFuc3BpbGUgdGhlIHZhbHVlID0+IFwiSGVsbG8gVHJhbnNsb2NvXCJcbiAgICAgIGNvbnN0IHRyYW5zcGlsZWQgPSB0aGlzLnRyYW5zcGlsZSh2LCBnZXRQYXJhbXMsIHRyYW5zbGF0aW9uKTtcblxuICAgICAgLy8gc2V0IFwiYi5jXCIgdG8gYHRyYW5zcGlsZWRgXG4gICAgICByZXN1bHQgPSBzZXRWYWx1ZShyZXN1bHQsIHAsIHRyYW5zcGlsZWQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbG9jb1RyYW5zcGlsZXJGdW5jdGlvbiB7XG4gIHRyYW5zcGlsZSguLi5hcmdzOiBzdHJpbmdbXSk6IGFueTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZ1bmN0aW9uQXJncyhhcmdzU3RyaW5nOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHNwbGl0dGVkID0gYXJnc1N0cmluZyA/IGFyZ3NTdHJpbmcuc3BsaXQoJywnKSA6IFtdO1xuICBjb25zdCBhcmdzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3BsaXR0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgdmFsdWUgPSBzcGxpdHRlZFtpXS50cmltKCk7XG4gICAgd2hpbGUgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSAnXFxcXCcpIHtcbiAgICAgIGkrKztcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgnXFxcXCcsICcsJykgKyBzcGxpdHRlZFtpXTtcbiAgICB9XG4gICAgYXJncy5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBhcmdzO1xufVxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25hbFRyYW5zcGlsZXIgZXh0ZW5kcyBEZWZhdWx0VHJhbnNwaWxlciBpbXBsZW1lbnRzIFRyYW5zbG9jb1RyYW5zcGlsZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICB0cmFuc3BpbGUodmFsdWU6IGFueSwgcGFyYW1zOiBIYXNoTWFwID0ge30sIHRyYW5zbGF0aW9uOiBUcmFuc2xhdGlvbik6IGFueSB7XG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgY29uc3QgdHJhbnNwaWxlZCA9IHZhbHVlLnJlcGxhY2UoXG4gICAgICAgIC9cXFtcXFtcXHMqKFxcdyspXFwoKC4qKVxcKVxccypdXS9nLFxuICAgICAgICAobWF0Y2g6IHN0cmluZywgZnVuY3Rpb25OYW1lOiBzdHJpbmcsIGFyZ3M6IHN0cmluZykgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmdW5jOiBUcmFuc2xvY29UcmFuc3BpbGVyRnVuY3Rpb24gPSB0aGlzLmluamVjdG9yLmdldChmdW5jdGlvbk5hbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gZnVuYy50cmFuc3BpbGUoLi4uZ2V0RnVuY3Rpb25BcmdzKGFyZ3MpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGBUaGVyZSBpcyBhbiBlcnJvciBpbjogJyR7dmFsdWV9Jy4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgIENoZWNrIHRoYXQgdGhlIHlvdSB1c2VkIHRoZSByaWdodCBzeW50YXggaW4geW91ciB0cmFuc2xhdGlvbiBhbmQgdGhhdCB0aGUgaW1wbGVtZW50YXRpb24gb2YgJHtmdW5jdGlvbk5hbWV9IGlzIGNvcnJlY3QuYDtcbiAgICAgICAgICAgIGlmIChlLm1lc3NhZ2UuaW5jbHVkZXMoJ051bGxJbmplY3RvckVycm9yJykpIHtcbiAgICAgICAgICAgICAgbWVzc2FnZSA9IGBZb3UgYXJlIHVzaW5nIHRoZSAnJHtmdW5jdGlvbk5hbWV9JyBmdW5jdGlvbiBpbiB5b3VyIHRyYW5zbGF0aW9uIGJ1dCBubyBwcm92aWRlciB3YXMgZm91bmQhYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBzdXBlci50cmFuc3BpbGUodHJhbnNwaWxlZCwgcGFyYW1zLCB0cmFuc2xhdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KHZhbHVlKSAmJiBwYXJhbXMpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5oYW5kbGVPYmplY3QodmFsdWUsIHBhcmFtcywgdHJhbnNsYXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuIl19