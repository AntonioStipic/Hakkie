/**
 * @fileoverview added by tsickle
 * Generated from: lib/transloco.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Inject, Injectable, Optional } from '@angular/core';
import { BehaviorSubject, combineLatest, EMPTY, forkJoin, from, of, Subject } from 'rxjs';
import { catchError, map, retry, shareReplay, switchMap, tap } from 'rxjs/operators';
import { DefaultLoader, TRANSLOCO_LOADER } from './transloco.loader';
import { TRANSLOCO_TRANSPILER } from './transloco.transpiler';
import { flatten, isEmpty, isNil, isScopeObject, isString, size, toCamelCase, unflatten } from './helpers';
import { defaultConfig, TRANSLOCO_CONFIG } from './transloco.config';
import { TRANSLOCO_MISSING_HANDLER } from './transloco-missing-handler';
import { TRANSLOCO_INTERCEPTOR } from './transloco.interceptor';
import { TRANSLOCO_FALLBACK_STRATEGY } from './transloco-fallback-strategy';
import { mergeConfig } from './merge-config';
import { getEventPayload, getLangFromScope, getScopeFromLang, resolveInlineLoader } from './shared';
import { getFallbacksLoaders } from './get-fallbacks-loaders';
import { resolveLoader } from './resolve-loader';
import * as i0 from "@angular/core";
import * as i1 from "./transloco.loader";
import * as i2 from "./transloco.transpiler";
import * as i3 from "./transloco-missing-handler";
import * as i4 from "./transloco.interceptor";
import * as i5 from "./transloco.config";
import * as i6 from "./transloco-fallback-strategy";
/** @type {?} */
var service;
/**
 * @template T
 * @param {?} key
 * @param {?=} params
 * @param {?=} lang
 * @return {?}
 */
export function translate(key, params, lang) {
    if (params === void 0) { params = {}; }
    return service.translate(key, params, lang);
}
var TranslocoService = /** @class */ (function () {
    function TranslocoService(loader, parser, missingHandler, interceptor, userConfig, fallbackStrategy) {
        var _this = this;
        this.loader = loader;
        this.parser = parser;
        this.missingHandler = missingHandler;
        this.interceptor = interceptor;
        this.userConfig = userConfig;
        this.fallbackStrategy = fallbackStrategy;
        this.translations = new Map();
        this.cache = new Map();
        this.firstFallbackLang = null;
        this.availableLangs = [];
        this.isResolvedMissingOnce = false;
        this.events = new Subject();
        this.events$ = this.events.asObservable();
        this.failedCounter = 0;
        this.failedLangs = new Set();
        if (!this.loader) {
            this.loader = new DefaultLoader(this.translations);
        }
        service = this;
        this.mergedConfig = mergeConfig(defaultConfig, userConfig);
        this.setAvailableLangs(this.mergedConfig.availableLangs);
        this.setFallbackLangForMissingTranslation(this.mergedConfig);
        this.setDefaultLang(this.mergedConfig.defaultLang);
        this.lang = new BehaviorSubject(this.getDefaultLang());
        // Don't use distinctUntilChanged as we need the ability to update
        // the value when using setTranslation or setTranslationKeys
        this.langChanges$ = this.lang.asObservable();
        /**
         * When we have a failure, we want to define the next language that succeeded as the active
         */
        this.subscription = this.events$.subscribe((/**
         * @param {?} e
         * @return {?}
         */
        function (e) {
            if (e.type === 'translationLoadSuccess' && e.wasFailure) {
                // Handle scoped lang
                /** @type {?} */
                var lang = getLangFromScope(e.payload.lang);
                _this.setActiveLang(lang);
            }
        }));
    }
    Object.defineProperty(TranslocoService.prototype, "config", {
        get: /**
         * @return {?}
         */
        function () {
            return this.mergedConfig;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TranslocoService.prototype.getDefaultLang = /**
     * @return {?}
     */
    function () {
        return this.defaultLang;
    };
    /**
     * @param {?} lang
     * @return {?}
     */
    TranslocoService.prototype.setDefaultLang = /**
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        this.defaultLang = lang;
    };
    /**
     * @return {?}
     */
    TranslocoService.prototype.getActiveLang = /**
     * @return {?}
     */
    function () {
        return this.lang.getValue();
    };
    /**
     * @template THIS
     * @this {THIS}
     * @param {?} lang
     * @return {THIS}
     */
    TranslocoService.prototype.setActiveLang = /**
     * @template THIS
     * @this {THIS}
     * @param {?} lang
     * @return {THIS}
     */
    function (lang) {
        (/** @type {?} */ (this)).lang.next(lang);
        (/** @type {?} */ (this)).parser.onLangChanged && (/** @type {?} */ (this)).parser.onLangChanged(lang);
        return (/** @type {?} */ (this));
    };
    /**
     * @param {?} langs
     * @return {?}
     */
    TranslocoService.prototype.setAvailableLangs = /**
     * @param {?} langs
     * @return {?}
     */
    function (langs) {
        this.availableLangs = langs;
    };
    /**
     * Gets the available languages.
     *
     * @returns
     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`
     * depending on how the available languages are set in your module.
     */
    /**
     * Gets the available languages.
     *
     * @return {?}
     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`
     * depending on how the available languages are set in your module.
     */
    TranslocoService.prototype.getAvailableLangs = /**
     * Gets the available languages.
     *
     * @return {?}
     * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`
     * depending on how the available languages are set in your module.
     */
    function () {
        return this.availableLangs;
    };
    /**
     * @param {?} path
     * @param {?=} options
     * @return {?}
     */
    TranslocoService.prototype.load = /**
     * @param {?} path
     * @param {?=} options
     * @return {?}
     */
    function (path, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (this.cache.has(path) === false) {
            /** @type {?} */
            var loadTranslation = void 0;
            /** @type {?} */
            var isScope = this._isLangScoped(path);
            /** @type {?} */
            var scope = isScope ? getScopeFromLang(path) : null;
            if (this.useFallbackTranslation(path)) {
                // if the path is scope the fallback should be `scope/fallbackLang`;
                /** @type {?} */
                var fallback = isScope ? scope + "/" + this.firstFallbackLang : this.firstFallbackLang;
                /** @type {?} */
                var loaders = getFallbacksLoaders(path, fallback, this.loader, options.inlineLoader, { scope: scope });
                loadTranslation = forkJoin(loaders);
            }
            else {
                /** @type {?} */
                var loader = resolveLoader(path, this.loader, options.inlineLoader, { scope: scope });
                loadTranslation = from(loader);
            }
            /** @type {?} */
            var load$ = loadTranslation.pipe(retry(this.config.failedRetries), tap((/**
             * @param {?} translation
             * @return {?}
             */
            function (translation) {
                if (Array.isArray(translation)) {
                    translation.forEach((/**
                     * @param {?} t
                     * @return {?}
                     */
                    function (t) {
                        _this.handleSuccess(t.lang, t.translation);
                        // Save the fallback in cache so we'll not create a redundant request
                        if (t.lang !== path) {
                            _this.cache.set(t.lang, of({}));
                        }
                    }));
                    return;
                }
                _this.handleSuccess(path, translation);
            })), catchError((/**
             * @return {?}
             */
            function () { return _this.handleFailure(path, options); })), shareReplay(1));
            this.cache.set(path, load$);
        }
        return this.cache.get(path);
    };
    /**
     * Gets the instant translated value of a key
     *
     * @example
     *
     * translate<string>('hello')
     * translate('hello', { value: 'value' })
     * translate<string[]>(['hello', 'key'])
     * translate('hello', { }, 'en')
     * translate('scope.someKey', { }, 'en')
     */
    /**
     * Gets the instant translated value of a key
     *
     * \@example
     *
     * translate<string>('hello')
     * translate('hello', { value: 'value' })
     * translate<string[]>(['hello', 'key'])
     * translate('hello', { }, 'en')
     * translate('scope.someKey', { }, 'en')
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    TranslocoService.prototype.translate = /**
     * Gets the instant translated value of a key
     *
     * \@example
     *
     * translate<string>('hello')
     * translate('hello', { value: 'value' })
     * translate<string[]>(['hello', 'key'])
     * translate('hello', { }, 'en')
     * translate('scope.someKey', { }, 'en')
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    function (key, params, lang) {
        var _this = this;
        if (params === void 0) { params = {}; }
        if (lang === void 0) { lang = this.getActiveLang(); }
        if (!key)
            return (/** @type {?} */ (key));
        var _a = this.resolveLangAndScope(lang), scope = _a.scope, resolveLang = _a.resolveLang;
        if (Array.isArray(key)) {
            return (/** @type {?} */ (key.map((/**
             * @param {?} k
             * @return {?}
             */
            function (k) { return _this.translate(scope ? scope + "." + k : k, params, resolveLang); }))));
        }
        key = scope ? scope + "." + key : key;
        /** @type {?} */
        var translation = this.getTranslation(resolveLang);
        /** @type {?} */
        var value = translation[key];
        if (!value) {
            return this._handleMissingKey(key, value, params);
        }
        return this.parser.transpile(value, params, translation);
    };
    /**
     * Gets the translated value of a key as observable
     *
     * @example
     *
     * selectTranslate<string>('hello').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)
     *
     */
    /**
     * Gets the translated value of a key as observable
     *
     * \@example
     *
     * selectTranslate<string>('hello').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)
     *
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @param {?=} _isObject
     * @return {?}
     */
    TranslocoService.prototype.selectTranslate = /**
     * Gets the translated value of a key as observable
     *
     * \@example
     *
     * selectTranslate<string>('hello').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)
     * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)
     *
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @param {?=} _isObject
     * @return {?}
     */
    function (key, params, lang, _isObject) {
        var _this = this;
        if (_isObject === void 0) { _isObject = false; }
        /** @type {?} */
        var inlineLoader = null;
        /** @type {?} */
        var load = (/**
         * @param {?} lang
         * @param {?=} options
         * @return {?}
         */
        function (lang, options) {
            return _this.load(lang, options).pipe(map((/**
             * @return {?}
             */
            function () { return (_isObject ? _this.translateObject(key, params, lang) : _this.translate(key, params, lang)); })));
        });
        if (isNil(lang)) {
            return this.langChanges$.pipe(switchMap((/**
             * @param {?} lang
             * @return {?}
             */
            function (lang) { return load(lang); })));
        }
        if (isScopeObject(lang)) {
            // it's a scope object.
            /** @type {?} */
            var providerScope = (/** @type {?} */ (lang));
            lang = providerScope.scope;
            inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);
        }
        lang = (/** @type {?} */ (lang));
        if (this.isLang(lang) || this.isScopeWithLang(lang)) {
            return load(lang);
        }
        // it's a scope
        /** @type {?} */
        var scope = lang;
        return this.langChanges$.pipe(switchMap((/**
         * @param {?} lang
         * @return {?}
         */
        function (lang) { return load(scope + "/" + lang, { inlineLoader: inlineLoader }); })));
    };
    /**
     * Whether the scope with lang
     *
     * @example
     *
     * todos/en => true
     * todos => false
     */
    /**
     * Whether the scope with lang
     *
     * \@example
     *
     * todos/en => true
     * todos => false
     * @private
     * @param {?} lang
     * @return {?}
     */
    TranslocoService.prototype.isScopeWithLang = /**
     * Whether the scope with lang
     *
     * \@example
     *
     * todos/en => true
     * todos => false
     * @private
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        return this.isLang(getLangFromScope(lang));
    };
    /**
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    TranslocoService.prototype.translateObject = /**
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    function (key, params, lang) {
        var _this = this;
        if (lang === void 0) { lang = this.getActiveLang(); }
        var e_1, _a;
        if (isString(key) || Array.isArray(key)) {
            if (Array.isArray(key)) {
                return (/** @type {?} */ (key.map((/**
                 * @param {?} k
                 * @return {?}
                 */
                function (k) { return _this.translateObject(scope_1 ? scope_1 + "." + k : k, params, resolveLang_1); }))));
            }
            var _b = this.resolveLangAndScope(lang), resolveLang_1 = _b.resolveLang, scope_1 = _b.scope;
            /** @type {?} */
            var translation = this.getTranslation(resolveLang_1);
            key = scope_1 ? scope_1 + "." + key : key;
            /** @type {?} */
            var value = unflatten(this.getObjectByKey(translation, key));
            /* If an empty object was returned we want to try and translate the key as a string and not an object */
            return isEmpty(value) ? this.translate(key, params, lang) : this.parser.transpile(value, params, translation);
        }
        /** @type {?} */
        var translations = [];
        try {
            for (var _c = tslib_1.__values(this.getEntries(key)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var _e = tslib_1.__read(_d.value, 2), _key = _e[0], _params = _e[1];
                translations.push(this.translateObject(_key, _params, lang));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return translations;
    };
    /**
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    TranslocoService.prototype.selectTranslateObject = /**
     * @template T
     * @param {?} key
     * @param {?=} params
     * @param {?=} lang
     * @return {?}
     */
    function (key, params, lang) {
        var _this = this;
        if (isString(key) || Array.isArray(key)) {
            return this.selectTranslate(key, params, lang, true);
        }
        var _a = tslib_1.__read(this.getEntries(key)), _b = tslib_1.__read(_a[0], 2), firstKey = _b[0], firstParams = _b[1], rest = _a.slice(1);
        /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,
         * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */
        return this.selectTranslateObject(firstKey, firstParams, lang).pipe(map((/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var e_2, _a;
            /** @type {?} */
            var translations = [value];
            try {
                for (var rest_1 = tslib_1.__values(rest), rest_1_1 = rest_1.next(); !rest_1_1.done; rest_1_1 = rest_1.next()) {
                    var _b = tslib_1.__read(rest_1_1.value, 2), _key = _b[0], _params = _b[1];
                    translations.push(_this.translateObject(_key, _params, lang));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (rest_1_1 && !rest_1_1.done && (_a = rest_1.return)) _a.call(rest_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return translations;
        })));
    };
    /**
     * @param {?=} lang
     * @return {?}
     */
    TranslocoService.prototype.getTranslation = /**
     * @param {?=} lang
     * @return {?}
     */
    function (lang) {
        return lang ? this.translations.get(lang) || {} : this.translations;
    };
    /**
     * Gets an object of translations for a given language
     *
     * @example
     *
     * selectTranslation().subscribe()
     * selectTranslation('es').subscribe()
     */
    /**
     * Gets an object of translations for a given language
     *
     * \@example
     *
     * selectTranslation().subscribe()
     * selectTranslation('es').subscribe()
     * @param {?=} lang
     * @return {?}
     */
    TranslocoService.prototype.selectTranslation = /**
     * Gets an object of translations for a given language
     *
     * \@example
     *
     * selectTranslation().subscribe()
     * selectTranslation('es').subscribe()
     * @param {?=} lang
     * @return {?}
     */
    function (lang) {
        var _this = this;
        /** @type {?} */
        var language = lang || this.getActiveLang();
        return this.load(language).pipe(map((/**
         * @return {?}
         */
        function () { return _this.getTranslation(language); })));
    };
    /**
     * Sets or merge a given translation object to current lang
     *
     * @example
     *
     * setTranslation({ ... })
     * setTranslation({ ... }, 'en')
     * setTranslation({ ... }, 'es', { merge: false } )
     * setTranslation({ ... }, 'todos/en', { merge: false } )
     */
    /**
     * Sets or merge a given translation object to current lang
     *
     * \@example
     *
     * setTranslation({ ... })
     * setTranslation({ ... }, 'en')
     * setTranslation({ ... }, 'es', { merge: false } )
     * setTranslation({ ... }, 'todos/en', { merge: false } )
     * @param {?} translation
     * @param {?=} lang
     * @param {?=} options
     * @return {?}
     */
    TranslocoService.prototype.setTranslation = /**
     * Sets or merge a given translation object to current lang
     *
     * \@example
     *
     * setTranslation({ ... })
     * setTranslation({ ... }, 'en')
     * setTranslation({ ... }, 'es', { merge: false } )
     * setTranslation({ ... }, 'todos/en', { merge: false } )
     * @param {?} translation
     * @param {?=} lang
     * @param {?=} options
     * @return {?}
     */
    function (translation, lang, options) {
        if (lang === void 0) { lang = this.getActiveLang(); }
        if (options === void 0) { options = {}; }
        var _a;
        /** @type {?} */
        var defaults = { merge: true, emitChange: true };
        /** @type {?} */
        var mergedOptions = tslib_1.__assign({}, defaults, options);
        /** @type {?} */
        var scope = getScopeFromLang(lang);
        /**
         * If this isn't a scope we use the whole translation as is
         * otherwise we need to flat the scope and use it
         * @type {?}
         */
        var flattenScopeOrTranslation = translation;
        // Merged the scoped language into the active language
        if (scope) {
            /** @type {?} */
            var key = this.getMappedScope(scope);
            flattenScopeOrTranslation = flatten((_a = {}, _a[key] = translation, _a));
        }
        /** @type {?} */
        var currentLang = scope ? getLangFromScope(lang) : lang;
        /** @type {?} */
        var mergedTranslation = tslib_1.__assign({}, (mergedOptions.merge && this.getTranslation(currentLang)), flattenScopeOrTranslation);
        /** @type {?} */
        var flattenTranslation = this.mergedConfig.flatten.aot ? mergedTranslation : flatten(mergedTranslation);
        /** @type {?} */
        var withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);
        this.translations.set(currentLang, withHook);
        mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());
    };
    /**
     * Sets translation key with given value
     *
     * @example
     *
     * setTranslationKey('key', 'value')
     * setTranslationKey('key.nested', 'value')
     * setTranslationKey('key.nested', 'value', 'en')
     */
    /**
     * Sets translation key with given value
     *
     * \@example
     *
     * setTranslationKey('key', 'value')
     * setTranslationKey('key.nested', 'value')
     * setTranslationKey('key.nested', 'value', 'en')
     * @param {?} key
     * @param {?} value
     * @param {?=} lang
     * @return {?}
     */
    TranslocoService.prototype.setTranslationKey = /**
     * Sets translation key with given value
     *
     * \@example
     *
     * setTranslationKey('key', 'value')
     * setTranslationKey('key.nested', 'value')
     * setTranslationKey('key.nested', 'value', 'en')
     * @param {?} key
     * @param {?} value
     * @param {?=} lang
     * @return {?}
     */
    function (key, value, lang) {
        if (lang === void 0) { lang = this.getActiveLang(); }
        var _a;
        /** @type {?} */
        var withHook = this.interceptor.preSaveTranslationKey(key, value, lang);
        /** @type {?} */
        var newValue = tslib_1.__assign({}, this.getTranslation(lang), (_a = {}, _a[key] = withHook, _a));
        this.setTranslation(newValue, lang);
    };
    /**
     * Sets the fallback lang for the currently active language
     * @param fallbackLang
     */
    /**
     * Sets the fallback lang for the currently active language
     * @param {?} __0
     * @return {?}
     */
    TranslocoService.prototype.setFallbackLangForMissingTranslation = /**
     * Sets the fallback lang for the currently active language
     * @param {?} __0
     * @return {?}
     */
    function (_a) {
        var fallbackLang = _a.fallbackLang;
        /** @type {?} */
        var lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;
        if (this.useFallbackTranslation(lang) && fallbackLang) {
            this.firstFallbackLang = lang;
        }
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} key
     * @param {?} value
     * @param {?=} params
     * @return {?}
     */
    TranslocoService.prototype._handleMissingKey = /**
     * \@internal
     * @param {?} key
     * @param {?} value
     * @param {?=} params
     * @return {?}
     */
    function (key, value, params) {
        if (this.config.missingHandler.allowEmpty && value === '') {
            return '';
        }
        if (this.useFallbackTranslation() && !this.isResolvedMissingOnce) {
            // We need to set it to true to prevent a loop
            this.isResolvedMissingOnce = true;
            /** @type {?} */
            var fallbackValue = this.translate(key, params, this.firstFallbackLang);
            this.isResolvedMissingOnce = false;
            return fallbackValue;
        }
        return this.missingHandler.handle(key, this.getMissingHandlerData(), params);
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} lang
     * @return {?}
     */
    TranslocoService.prototype._isLangScoped = /**
     * \@internal
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        return this.getAvailableLangsIds().indexOf(lang) === -1;
    };
    /**
     * Checks if a given string is one of the specified available languages.
     * @returns
     * True if the given string is an available language.
     * False if the given string is not an available language.
     */
    /**
     * Checks if a given string is one of the specified available languages.
     * @param {?} lang
     * @return {?}
     * True if the given string is an available language.
     * False if the given string is not an available language.
     */
    TranslocoService.prototype.isLang = /**
     * Checks if a given string is one of the specified available languages.
     * @param {?} lang
     * @return {?}
     * True if the given string is an available language.
     * False if the given string is not an available language.
     */
    function (lang) {
        return this.getAvailableLangsIds().indexOf(lang) !== -1;
    };
    /**
     * @internal
     *
     * We always want to make sure the global lang is loaded
     * before loading the scope since you can access both via the pipe/directive.
     */
    /**
     * \@internal
     *
     * We always want to make sure the global lang is loaded
     * before loading the scope since you can access both via the pipe/directive.
     * @param {?} path
     * @param {?=} inlineLoader
     * @return {?}
     */
    TranslocoService.prototype._loadDependencies = /**
     * \@internal
     *
     * We always want to make sure the global lang is loaded
     * before loading the scope since you can access both via the pipe/directive.
     * @param {?} path
     * @param {?=} inlineLoader
     * @return {?}
     */
    function (path, inlineLoader) {
        /** @type {?} */
        var mainLang = getLangFromScope(path);
        if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {
            return combineLatest(this.load(mainLang), this.load(path, { inlineLoader: inlineLoader }));
        }
        return this.load(path, { inlineLoader: inlineLoader });
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} langOrScope
     * @return {?}
     */
    TranslocoService.prototype._completeScopeWithLang = /**
     * \@internal
     * @param {?} langOrScope
     * @return {?}
     */
    function (langOrScope) {
        if (this._isLangScoped(langOrScope) && !this.isLang(getLangFromScope(langOrScope))) {
            return langOrScope + "/" + this.getActiveLang();
        }
        return langOrScope;
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} scope
     * @param {?} alias
     * @return {?}
     */
    TranslocoService.prototype._setScopeAlias = /**
     * \@internal
     * @param {?} scope
     * @param {?} alias
     * @return {?}
     */
    function (scope, alias) {
        if (!this.mergedConfig.scopeMapping) {
            this.mergedConfig.scopeMapping = {};
        }
        this.mergedConfig.scopeMapping[scope] = alias;
    };
    /**
     * @return {?}
     */
    TranslocoService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscription.unsubscribe();
    };
    /**
     * @private
     * @param {?} lang
     * @return {?}
     */
    TranslocoService.prototype.isLoadedTranslation = /**
     * @private
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        return size(this.getTranslation(lang));
    };
    /**
     * @private
     * @return {?}
     */
    TranslocoService.prototype.getAvailableLangsIds = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var first = this.getAvailableLangs()[0];
        if (isString(first)) {
            return (/** @type {?} */ (this.getAvailableLangs()));
        }
        return ((/** @type {?} */ (this.getAvailableLangs()))).map((/**
         * @param {?} l
         * @return {?}
         */
        function (l) { return l.id; }));
    };
    /**
     * @private
     * @return {?}
     */
    TranslocoService.prototype.getMissingHandlerData = /**
     * @private
     * @return {?}
     */
    function () {
        return tslib_1.__assign({}, this.config, { activeLang: this.getActiveLang(), availableLangs: this.availableLangs, defaultLang: this.defaultLang });
    };
    /**
     * Use a fallback translation set for missing keys of the primary language
     * This is unrelated to the fallback language (which changes the active language)
     */
    /**
     * Use a fallback translation set for missing keys of the primary language
     * This is unrelated to the fallback language (which changes the active language)
     * @private
     * @param {?=} lang
     * @return {?}
     */
    TranslocoService.prototype.useFallbackTranslation = /**
     * Use a fallback translation set for missing keys of the primary language
     * This is unrelated to the fallback language (which changes the active language)
     * @private
     * @param {?=} lang
     * @return {?}
     */
    function (lang) {
        return this.config.missingHandler.useFallbackTranslation && lang !== this.firstFallbackLang;
    };
    /**
     * @private
     * @param {?} lang
     * @param {?} translation
     * @return {?}
     */
    TranslocoService.prototype.handleSuccess = /**
     * @private
     * @param {?} lang
     * @param {?} translation
     * @return {?}
     */
    function (lang, translation) {
        var _this = this;
        this.setTranslation(translation, lang, { emitChange: false });
        this.failedCounter = 0;
        this.events.next({
            wasFailure: !!this.failedLangs.size,
            type: 'translationLoadSuccess',
            payload: getEventPayload(lang)
        });
        this.failedLangs.forEach((/**
         * @param {?} l
         * @return {?}
         */
        function (l) { return _this.cache.delete(l); }));
        this.failedLangs.clear();
    };
    /**
     * @private
     * @param {?} lang
     * @param {?} mergedOptions
     * @return {?}
     */
    TranslocoService.prototype.handleFailure = /**
     * @private
     * @param {?} lang
     * @param {?} mergedOptions
     * @return {?}
     */
    function (lang, mergedOptions) {
        /** @type {?} */
        var splitted = lang.split('/');
        /** @type {?} */
        var fallbacks = mergedOptions.fallbackLangs || this.fallbackStrategy.getNextLangs(lang);
        /** @type {?} */
        var nextLang = fallbacks[this.failedCounter];
        this.failedLangs.add(lang);
        // This handles the case where a loaded fallback language is requested again
        if (this.cache.has(nextLang)) {
            this.handleSuccess(nextLang, this.getTranslation(nextLang));
            return EMPTY;
        }
        /** @type {?} */
        var isFallbackLang = nextLang === splitted[splitted.length - 1];
        if (!nextLang || isFallbackLang) {
            /** @type {?} */
            var msg = "Unable to load translation and all the fallback languages";
            if (splitted.length > 1) {
                msg += ", did you misspelled the scope name?";
            }
            throw new Error(msg);
        }
        /** @type {?} */
        var resolveLang = nextLang;
        // if it's scoped lang
        if (splitted.length > 1) {
            // We need to resolve it to:
            // todos/langNotExists => todos/nextLang
            splitted[splitted.length - 1] = nextLang;
            resolveLang = splitted.join('/');
        }
        this.failedCounter++;
        this.events.next({
            type: 'translationLoadFailure',
            payload: getEventPayload(lang)
        });
        return this.load(resolveLang);
    };
    /**
     * @private
     * @param {?} scope
     * @return {?}
     */
    TranslocoService.prototype.getMappedScope = /**
     * @private
     * @param {?} scope
     * @return {?}
     */
    function (scope) {
        var _a = this.config.scopeMapping, scopeMapping = _a === void 0 ? {} : _a;
        return scopeMapping[scope] || toCamelCase(scope);
    };
    /**
     * If lang is scope we need to check the following cases:
     * todos/es => in this case we should take `es` as lang
     * todos => in this case we should set the active lang as lang
     */
    /**
     * If lang is scope we need to check the following cases:
     * todos/es => in this case we should take `es` as lang
     * todos => in this case we should set the active lang as lang
     * @private
     * @param {?} lang
     * @return {?}
     */
    TranslocoService.prototype.resolveLangAndScope = /**
     * If lang is scope we need to check the following cases:
     * todos/es => in this case we should take `es` as lang
     * todos => in this case we should set the active lang as lang
     * @private
     * @param {?} lang
     * @return {?}
     */
    function (lang) {
        /** @type {?} */
        var resolveLang = lang;
        /** @type {?} */
        var scope;
        if (this._isLangScoped(lang)) {
            // en for example
            /** @type {?} */
            var langFromScope = getLangFromScope(lang);
            // en is lang
            /** @type {?} */
            var hasLang = this.isLang(langFromScope);
            // take en
            resolveLang = hasLang ? langFromScope : this.getActiveLang();
            // find the scope
            scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);
        }
        return { scope: scope, resolveLang: resolveLang };
    };
    /**
     * @private
     * @param {?} translation
     * @param {?} key
     * @return {?}
     */
    TranslocoService.prototype.getObjectByKey = /**
     * @private
     * @param {?} translation
     * @param {?} key
     * @return {?}
     */
    function (translation, key) {
        /** @type {?} */
        var result = {};
        /** @type {?} */
        var prefix = key + ".";
        for (var currentKey in translation) {
            if (currentKey.startsWith(prefix)) {
                result[currentKey.replace(prefix, '')] = translation[currentKey];
            }
        }
        return result;
    };
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    TranslocoService.prototype.getEntries = /**
     * @private
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return key instanceof Map ? key.entries() : Object.entries(key);
    };
    TranslocoService.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    TranslocoService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLOCO_LOADER,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_TRANSPILER,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_MISSING_HANDLER,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_INTERCEPTOR,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_CONFIG,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLOCO_FALLBACK_STRATEGY,] }] }
    ]; };
    /** @nocollapse */ TranslocoService.ngInjectableDef = i0.defineInjectable({ factory: function TranslocoService_Factory() { return new TranslocoService(i0.inject(i1.TRANSLOCO_LOADER, 8), i0.inject(i2.TRANSLOCO_TRANSPILER), i0.inject(i3.TRANSLOCO_MISSING_HANDLER), i0.inject(i4.TRANSLOCO_INTERCEPTOR), i0.inject(i5.TRANSLOCO_CONFIG), i0.inject(i6.TRANSLOCO_FALLBACK_STRATEGY)); }, token: TranslocoService, providedIn: "root" });
    return TranslocoService;
}());
export { TranslocoService };
if (false) {
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.subscription;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.translations;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.cache;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.firstFallbackLang;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.defaultLang;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.mergedConfig;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.availableLangs;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.isResolvedMissingOnce;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.lang;
    /** @type {?} */
    TranslocoService.prototype.langChanges$;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.events;
    /** @type {?} */
    TranslocoService.prototype.events$;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.failedCounter;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.failedLangs;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.loader;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.parser;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.missingHandler;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.interceptor;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.userConfig;
    /**
     * @type {?}
     * @private
     */
    TranslocoService.prototype.fallbackStrategy;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsb2NvLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbmduZWF0L3RyYW5zbG9jby8iLCJzb3VyY2VzIjpbImxpYi90cmFuc2xvY28uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBYSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDeEUsT0FBTyxFQUFFLGVBQWUsRUFBRSxhQUFhLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQWMsRUFBRSxFQUFFLE9BQU8sRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDcEgsT0FBTyxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDckYsT0FBTyxFQUFFLGFBQWEsRUFBRSxnQkFBZ0IsRUFBbUIsTUFBTSxvQkFBb0IsQ0FBQztBQUN0RixPQUFPLEVBQUUsb0JBQW9CLEVBQXVCLE1BQU0sd0JBQXdCLENBQUM7QUFjbkYsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLGFBQWEsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUsTUFBTSxXQUFXLENBQUM7QUFDM0csT0FBTyxFQUFFLGFBQWEsRUFBRSxnQkFBZ0IsRUFBbUIsTUFBTSxvQkFBb0IsQ0FBQztBQUN0RixPQUFPLEVBQ0wseUJBQXlCLEVBRzFCLE1BQU0sNkJBQTZCLENBQUM7QUFDckMsT0FBTyxFQUFFLHFCQUFxQixFQUF3QixNQUFNLHlCQUF5QixDQUFDO0FBQ3RGLE9BQU8sRUFBRSwyQkFBMkIsRUFBNkIsTUFBTSwrQkFBK0IsQ0FBQztBQUN2RyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDN0MsT0FBTyxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxnQkFBZ0Is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Z0RBQ2hDLE1BQU0sU0FBQyxxQkFBcUI7Z0RBQzVCLE1BQU0sU0FBQyxnQkFBZ0I7Z0RBQ3ZCLE1BQU0sU0FBQywyQkFBMkI7OzsyQkEvRHZDO0NBMG1CQyxBQXBrQkQsSUFva0JDO1NBbmtCWSxnQkFBZ0I7Ozs7OztJQUMzQix3Q0FBbUM7Ozs7O0lBQ25DLHdDQUFzRDs7Ozs7SUFDdEQsaUNBQTJEOzs7OztJQUMzRCw2Q0FBZ0Q7Ozs7O0lBQ2hELHVDQUE0Qjs7Ozs7SUFDNUIsd0NBQXNDOzs7OztJQUN0QywwQ0FBNEM7Ozs7O0lBQzVDLGlEQUFzQzs7Ozs7SUFDdEMsZ0NBQXNDOztJQUN0Qyx3Q0FBaUM7Ozs7O0lBRWpDLGtDQUFnRDs7SUFDaEQsbUNBQXFDOzs7OztJQUVyQyx5Q0FBMEI7Ozs7O0lBQzFCLHVDQUF3Qzs7Ozs7SUFHdEMsa0NBQXFFOzs7OztJQUNyRSxrQ0FBaUU7Ozs7O0lBQ2pFLDBDQUFrRjs7Ozs7SUFDbEYsdUNBQXdFOzs7OztJQUN4RSxzQ0FBNkQ7Ozs7O0lBQzdELDRDQUF3RiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgT25EZXN0cm95LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBjb21iaW5lTGF0ZXN0LCBFTVBUWSwgZm9ya0pvaW4sIGZyb20sIE9ic2VydmFibGUsIG9mLCBTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNhdGNoRXJyb3IsIG1hcCwgcmV0cnksIHNoYXJlUmVwbGF5LCBzd2l0Y2hNYXAsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IERlZmF1bHRMb2FkZXIsIFRSQU5TTE9DT19MT0FERVIsIFRyYW5zbG9jb0xvYWRlciB9IGZyb20gJy4vdHJhbnNsb2NvLmxvYWRlcic7XG5pbXBvcnQgeyBUUkFOU0xPQ09fVFJBTlNQSUxFUiwgVHJhbnNsb2NvVHJhbnNwaWxlciB9IGZyb20gJy4vdHJhbnNsb2NvLnRyYW5zcGlsZXInO1xuaW1wb3J0IHtcbiAgQXZhaWxhYmxlTGFuZ3MsXG4gIEhhc2hNYXAsXG4gIElubGluZUxvYWRlcixcbiAgTG9hZE9wdGlvbnMsXG4gIFByb3ZpZGVyU2NvcGUsXG4gIFNldFRyYW5zbGF0aW9uT3B0aW9ucyxcbiAgVHJhbnNsYXRlT2JqZWN0UGFyYW1zLFxuICBUcmFuc2xhdGVQYXJhbXMsXG4gIFRyYW5zbGF0aW9uLFxuICBUcmFuc2xvY29FdmVudHMsXG4gIFRyYW5zbG9jb1Njb3BlXG59IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZmxhdHRlbiwgaXNFbXB0eSwgaXNOaWwsIGlzU2NvcGVPYmplY3QsIGlzU3RyaW5nLCBzaXplLCB0b0NhbWVsQ2FzZSwgdW5mbGF0dGVuIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IGRlZmF1bHRDb25maWcsIFRSQU5TTE9DT19DT05GSUcsIFRyYW5zbG9jb0NvbmZpZyB9IGZyb20gJy4vdHJhbnNsb2NvLmNvbmZpZyc7XG5pbXBvcnQge1xuICBUUkFOU0xPQ09fTUlTU0lOR19IQU5ETEVSLFxuICBUcmFuc2xvY29NaXNzaW5nSGFuZGxlcixcbiAgVHJhbnNsb2NvTWlzc2luZ0hhbmRsZXJEYXRhXG59IGZyb20gJy4vdHJhbnNsb2NvLW1pc3NpbmctaGFuZGxlcic7XG5pbXBvcnQgeyBUUkFOU0xPQ09fSU5URVJDRVBUT1IsIFRyYW5zbG9jb0ludGVyY2VwdG9yIH0gZnJvbSAnLi90cmFuc2xvY28uaW50ZXJjZXB0b3InO1xuaW1wb3J0IHsgVFJBTlNMT0NPX0ZBTExCQUNLX1NUUkFURUdZLCBUcmFuc2xvY29GYWxsYmFja1N0cmF0ZWd5IH0gZnJvbSAnLi90cmFuc2xvY28tZmFsbGJhY2stc3RyYXRlZ3knO1xuaW1wb3J0IHsgbWVyZ2VDb25maWcgfSBmcm9tICcuL21lcmdlLWNvbmZpZyc7XG5pbXBvcnQgeyBnZXRFdmVudFBheWxvYWQsIGdldExhbmdGcm9tU2NvcGUsIGdldFNjb3BlRnJvbUxhbmcsIHJlc29sdmVJbmxpbmVMb2FkZXIgfSBmcm9tICcuL3NoYXJlZCc7XG5pbXBvcnQgeyBnZXRGYWxsYmFja3NMb2FkZXJzIH0gZnJvbSAnLi9nZXQtZmFsbGJhY2tzLWxvYWRlcnMnO1xuaW1wb3J0IHsgcmVzb2x2ZUxvYWRlciB9IGZyb20gJy4vcmVzb2x2ZS1sb2FkZXInO1xuXG5sZXQgc2VydmljZTogVHJhbnNsb2NvU2VydmljZTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZTxUID0gYW55PihrZXk6IFRyYW5zbGF0ZVBhcmFtcywgcGFyYW1zOiBIYXNoTWFwID0ge30sIGxhbmc/OiBzdHJpbmcpOiBUIHtcbiAgcmV0dXJuIHNlcnZpY2UudHJhbnNsYXRlKGtleSwgcGFyYW1zLCBsYW5nKTtcbn1cblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBUcmFuc2xvY29TZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgcHJpdmF0ZSB0cmFuc2xhdGlvbnMgPSBuZXcgTWFwPHN0cmluZywgVHJhbnNsYXRpb24+KCk7XG4gIHByaXZhdGUgY2FjaGUgPSBuZXcgTWFwPHN0cmluZywgT2JzZXJ2YWJsZTxUcmFuc2xhdGlvbj4+KCk7XG4gIHByaXZhdGUgZmlyc3RGYWxsYmFja0xhbmc6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGRlZmF1bHRMYW5nOiBzdHJpbmc7XG4gIHByaXZhdGUgbWVyZ2VkQ29uZmlnOiBUcmFuc2xvY29Db25maWc7XG4gIHByaXZhdGUgYXZhaWxhYmxlTGFuZ3M6IEF2YWlsYWJsZUxhbmdzID0gW107XG4gIHByaXZhdGUgaXNSZXNvbHZlZE1pc3NpbmdPbmNlID0gZmFsc2U7XG4gIHByaXZhdGUgbGFuZzogQmVoYXZpb3JTdWJqZWN0PHN0cmluZz47XG4gIGxhbmdDaGFuZ2VzJDogT2JzZXJ2YWJsZTxzdHJpbmc+O1xuXG4gIHByaXZhdGUgZXZlbnRzID0gbmV3IFN1YmplY3Q8VHJhbnNsb2NvRXZlbnRzPigpO1xuICBldmVudHMkID0gdGhpcy5ldmVudHMuYXNPYnNlcnZhYmxlKCk7XG5cbiAgcHJpdmF0ZSBmYWlsZWRDb3VudGVyID0gMDtcbiAgcHJpdmF0ZSBmYWlsZWRMYW5ncyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoVFJBTlNMT0NPX0xPQURFUikgcHJpdmF0ZSBsb2FkZXI6IFRyYW5zbG9jb0xvYWRlcixcbiAgICBASW5qZWN0KFRSQU5TTE9DT19UUkFOU1BJTEVSKSBwcml2YXRlIHBhcnNlcjogVHJhbnNsb2NvVHJhbnNwaWxlcixcbiAgICBASW5qZWN0KFRSQU5TTE9DT19NSVNTSU5HX0hBTkRMRVIpIHByaXZhdGUgbWlzc2luZ0hhbmRsZXI6IFRyYW5zbG9jb01pc3NpbmdIYW5kbGVyLFxuICAgIEBJbmplY3QoVFJBTlNMT0NPX0lOVEVSQ0VQVE9SKSBwcml2YXRlIGludGVyY2VwdG9yOiBUcmFuc2xvY29JbnRlcmNlcHRvcixcbiAgICBASW5qZWN0KFRSQU5TTE9DT19DT05GSUcpIHByaXZhdGUgdXNlckNvbmZpZzogVHJhbnNsb2NvQ29uZmlnLFxuICAgIEBJbmplY3QoVFJBTlNMT0NPX0ZBTExCQUNLX1NUUkFURUdZKSBwcml2YXRlIGZhbGxiYWNrU3RyYXRlZ3k6IFRyYW5zbG9jb0ZhbGxiYWNrU3RyYXRlZ3lcbiAgKSB7XG4gICAgaWYgKCF0aGlzLmxvYWRlcikge1xuICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgRGVmYXVsdExvYWRlcih0aGlzLnRyYW5zbGF0aW9ucyk7XG4gICAgfVxuICAgIHNlcnZpY2UgPSB0aGlzO1xuICAgIHRoaXMubWVyZ2VkQ29uZmlnID0gbWVyZ2VDb25maWcoZGVmYXVsdENvbmZpZywgdXNlckNvbmZpZyk7XG5cbiAgICB0aGlzLnNldEF2YWlsYWJsZUxhbmdzKHRoaXMubWVyZ2VkQ29uZmlnLmF2YWlsYWJsZUxhbmdzKTtcbiAgICB0aGlzLnNldEZhbGxiYWNrTGFuZ0Zvck1pc3NpbmdUcmFuc2xhdGlvbih0aGlzLm1lcmdlZENvbmZpZyk7XG4gICAgdGhpcy5zZXREZWZhdWx0TGFuZyh0aGlzLm1lcmdlZENvbmZpZy5kZWZhdWx0TGFuZyk7XG4gICAgdGhpcy5sYW5nID0gbmV3IEJlaGF2aW9yU3ViamVjdDxzdHJpbmc+KHRoaXMuZ2V0RGVmYXVsdExhbmcoKSk7XG4gICAgLy8gRG9uJ3QgdXNlIGRpc3RpbmN0VW50aWxDaGFuZ2VkIGFzIHdlIG5lZWQgdGhlIGFiaWxpdHkgdG8gdXBkYXRlXG4gICAgLy8gdGhlIHZhbHVlIHdoZW4gdXNpbmcgc2V0VHJhbnNsYXRpb24gb3Igc2V0VHJhbnNsYXRpb25LZXlzXG4gICAgdGhpcy5sYW5nQ2hhbmdlcyQgPSB0aGlzLmxhbmcuYXNPYnNlcnZhYmxlKCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIGhhdmUgYSBmYWlsdXJlLCB3ZSB3YW50IHRvIGRlZmluZSB0aGUgbmV4dCBsYW5ndWFnZSB0aGF0IHN1Y2NlZWRlZCBhcyB0aGUgYWN0aXZlXG4gICAgICovXG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLmV2ZW50cyQuc3Vic2NyaWJlKGUgPT4ge1xuICAgICAgaWYgKGUudHlwZSA9PT0gJ3RyYW5zbGF0aW9uTG9hZFN1Y2Nlc3MnICYmIGUud2FzRmFpbHVyZSkge1xuICAgICAgICAvLyBIYW5kbGUgc2NvcGVkIGxhbmdcbiAgICAgICAgY29uc3QgbGFuZyA9IGdldExhbmdGcm9tU2NvcGUoZS5wYXlsb2FkLmxhbmcpO1xuICAgICAgICB0aGlzLnNldEFjdGl2ZUxhbmcobGFuZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXQgY29uZmlnKCk6IFRyYW5zbG9jb0NvbmZpZyB7XG4gICAgcmV0dXJuIHRoaXMubWVyZ2VkQ29uZmlnO1xuICB9XG5cbiAgZ2V0RGVmYXVsdExhbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdExhbmc7XG4gIH1cblxuICBzZXREZWZhdWx0TGFuZyhsYW5nOiBzdHJpbmcpIHtcbiAgICB0aGlzLmRlZmF1bHRMYW5nID0gbGFuZztcbiAgfVxuXG4gIGdldEFjdGl2ZUxhbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubGFuZy5nZXRWYWx1ZSgpO1xuICB9XG5cbiAgc2V0QWN0aXZlTGFuZyhsYW5nOiBzdHJpbmcpIHtcbiAgICB0aGlzLmxhbmcubmV4dChsYW5nKTtcbiAgICB0aGlzLnBhcnNlci5vbkxhbmdDaGFuZ2VkICYmIHRoaXMucGFyc2VyLm9uTGFuZ0NoYW5nZWQobGFuZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRBdmFpbGFibGVMYW5ncyhsYW5nczogQXZhaWxhYmxlTGFuZ3MpIHtcbiAgICB0aGlzLmF2YWlsYWJsZUxhbmdzID0gbGFuZ3M7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgYXZhaWxhYmxlIGxhbmd1YWdlcy5cbiAgICpcbiAgICogQHJldHVybnNcbiAgICogQW4gYXJyYXkgb2YgdGhlIGF2YWlsYWJsZSBsYW5ndWFnZXMuIENhbiBiZSBlaXRoZXIgYSBgc3RyaW5nW11gIG9yIGEgYHsgaWQ6IHN0cmluZzsgbGFiZWw6IHN0cmluZyB9W11gXG4gICAqIGRlcGVuZGluZyBvbiBob3cgdGhlIGF2YWlsYWJsZSBsYW5ndWFnZXMgYXJlIHNldCBpbiB5b3VyIG1vZHVsZS5cbiAgICovXG4gIGdldEF2YWlsYWJsZUxhbmdzKCkge1xuICAgIHJldHVybiB0aGlzLmF2YWlsYWJsZUxhbmdzO1xuICB9XG5cbiAgbG9hZChwYXRoOiBzdHJpbmcsIG9wdGlvbnM6IExvYWRPcHRpb25zID0ge30pOiBPYnNlcnZhYmxlPFRyYW5zbGF0aW9uPiB7XG4gICAgaWYgKHRoaXMuY2FjaGUuaGFzKHBhdGgpID09PSBmYWxzZSkge1xuICAgICAgbGV0IGxvYWRUcmFuc2xhdGlvbjogT2JzZXJ2YWJsZTxUcmFuc2xhdGlvbiB8IHsgdHJhbnNsYXRpb246IFRyYW5zbGF0aW9uOyBsYW5nOiBzdHJpbmcgfVtdPjtcbiAgICAgIGNvbnN0IGlzU2NvcGUgPSB0aGlzLl9pc0xhbmdTY29wZWQocGF0aCk7XG4gICAgICBjb25zdCBzY29wZSA9IGlzU2NvcGUgPyBnZXRTY29wZUZyb21MYW5nKHBhdGgpIDogbnVsbDtcbiAgICAgIGlmICh0aGlzLnVzZUZhbGxiYWNrVHJhbnNsYXRpb24ocGF0aCkpIHtcbiAgICAgICAgLy8gaWYgdGhlIHBhdGggaXMgc2NvcGUgdGhlIGZhbGxiYWNrIHNob3VsZCBiZSBgc2NvcGUvZmFsbGJhY2tMYW5nYDtcbiAgICAgICAgY29uc3QgZmFsbGJhY2sgPSBpc1Njb3BlID8gYCR7c2NvcGV9LyR7dGhpcy5maXJzdEZhbGxiYWNrTGFuZ31gIDogdGhpcy5maXJzdEZhbGxiYWNrTGFuZztcblxuICAgICAgICBjb25zdCBsb2FkZXJzID0gZ2V0RmFsbGJhY2tzTG9hZGVycyhwYXRoLCBmYWxsYmFjaywgdGhpcy5sb2FkZXIsIG9wdGlvbnMuaW5saW5lTG9hZGVyLCB7IHNjb3BlIH0pO1xuICAgICAgICBsb2FkVHJhbnNsYXRpb24gPSBmb3JrSm9pbihsb2FkZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGxvYWRlciA9IHJlc29sdmVMb2FkZXIocGF0aCwgdGhpcy5sb2FkZXIsIG9wdGlvbnMuaW5saW5lTG9hZGVyLCB7IHNjb3BlIH0pO1xuICAgICAgICBsb2FkVHJhbnNsYXRpb24gPSBmcm9tKGxvYWRlcik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvYWQkID0gbG9hZFRyYW5zbGF0aW9uLnBpcGUoXG4gICAgICAgIHJldHJ5KHRoaXMuY29uZmlnLmZhaWxlZFJldHJpZXMpLFxuICAgICAgICB0YXAodHJhbnNsYXRpb24gPT4ge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zbGF0aW9uKSkge1xuICAgICAgICAgICAgdHJhbnNsYXRpb24uZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTdWNjZXNzKHQubGFuZywgdC50cmFuc2xhdGlvbik7XG4gICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGZhbGxiYWNrIGluIGNhY2hlIHNvIHdlJ2xsIG5vdCBjcmVhdGUgYSByZWR1bmRhbnQgcmVxdWVzdFxuICAgICAgICAgICAgICBpZiAodC5sYW5nICE9PSBwYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQodC5sYW5nLCBvZih7fSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYW5kbGVTdWNjZXNzKHBhdGgsIHRyYW5zbGF0aW9uKTtcbiAgICAgICAgfSksXG4gICAgICAgIGNhdGNoRXJyb3IoKCkgPT4gdGhpcy5oYW5kbGVGYWlsdXJlKHBhdGgsIG9wdGlvbnMpKSxcbiAgICAgICAgc2hhcmVSZXBsYXkoMSlcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuY2FjaGUuc2V0KHBhdGgsIGxvYWQkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jYWNoZS5nZXQocGF0aCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgaW5zdGFudCB0cmFuc2xhdGVkIHZhbHVlIG9mIGEga2V5XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHRyYW5zbGF0ZTxzdHJpbmc+KCdoZWxsbycpXG4gICAqIHRyYW5zbGF0ZSgnaGVsbG8nLCB7IHZhbHVlOiAndmFsdWUnIH0pXG4gICAqIHRyYW5zbGF0ZTxzdHJpbmdbXT4oWydoZWxsbycsICdrZXknXSlcbiAgICogdHJhbnNsYXRlKCdoZWxsbycsIHsgfSwgJ2VuJylcbiAgICogdHJhbnNsYXRlKCdzY29wZS5zb21lS2V5JywgeyB9LCAnZW4nKVxuICAgKi9cbiAgdHJhbnNsYXRlPFQgPSBhbnk+KGtleTogVHJhbnNsYXRlUGFyYW1zLCBwYXJhbXM6IEhhc2hNYXAgPSB7fSwgbGFuZyA9IHRoaXMuZ2V0QWN0aXZlTGFuZygpKTogVCB7XG4gICAgaWYgKCFrZXkpIHJldHVybiBrZXkgYXMgYW55O1xuXG4gICAgY29uc3QgeyBzY29wZSwgcmVzb2x2ZUxhbmcgfSA9IHRoaXMucmVzb2x2ZUxhbmdBbmRTY29wZShsYW5nKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICAgIHJldHVybiBrZXkubWFwKGsgPT4gdGhpcy50cmFuc2xhdGUoc2NvcGUgPyBgJHtzY29wZX0uJHtrfWAgOiBrLCBwYXJhbXMsIHJlc29sdmVMYW5nKSkgYXMgYW55O1xuICAgIH1cblxuICAgIGtleSA9IHNjb3BlID8gYCR7c2NvcGV9LiR7a2V5fWAgOiBrZXk7XG5cbiAgICBjb25zdCB0cmFuc2xhdGlvbiA9IHRoaXMuZ2V0VHJhbnNsYXRpb24ocmVzb2x2ZUxhbmcpO1xuICAgIGNvbnN0IHZhbHVlID0gdHJhbnNsYXRpb25ba2V5XTtcblxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVNaXNzaW5nS2V5KGtleSwgdmFsdWUsIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGFyc2VyLnRyYW5zcGlsZSh2YWx1ZSwgcGFyYW1zLCB0cmFuc2xhdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdHJhbnNsYXRlZCB2YWx1ZSBvZiBhIGtleSBhcyBvYnNlcnZhYmxlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHNlbGVjdFRyYW5zbGF0ZTxzdHJpbmc+KCdoZWxsbycpLnN1YnNjcmliZSh2YWx1ZSA9PiAuLi4pXG4gICAqIHNlbGVjdFRyYW5zbGF0ZTxzdHJpbmc+KCdoZWxsbycsIHt9LCAnZXMnKS5zdWJzY3JpYmUodmFsdWUgPT4gLi4uKVxuICAgKiBzZWxlY3RUcmFuc2xhdGU8c3RyaW5nPignaGVsbG8nLCB7fSwgJ3RvZG9zJykuc3Vic2NyaWJlKHZhbHVlID0+IC4uLilcbiAgICogc2VsZWN0VHJhbnNsYXRlPHN0cmluZz4oJ2hlbGxvJywge30sIHsgc2NvcGU6ICd0b2RvcycgfSkuc3Vic2NyaWJlKHZhbHVlID0+IC4uLilcbiAgICpcbiAgICovXG4gIHNlbGVjdFRyYW5zbGF0ZTxUID0gYW55PihcbiAgICBrZXk6IFRyYW5zbGF0ZVBhcmFtcyxcbiAgICBwYXJhbXM/OiBIYXNoTWFwLFxuICAgIGxhbmc/OiBzdHJpbmcgfCBUcmFuc2xvY29TY29wZSxcbiAgICBfaXNPYmplY3QgPSBmYWxzZVxuICApOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICBsZXQgaW5saW5lTG9hZGVyID0gbnVsbDtcbiAgICBjb25zdCBsb2FkID0gKGxhbmcsIG9wdGlvbnM/OiBMb2FkT3B0aW9ucykgPT5cbiAgICAgIHRoaXMubG9hZChsYW5nLCBvcHRpb25zKS5waXBlKFxuICAgICAgICBtYXAoKCkgPT4gKF9pc09iamVjdCA/IHRoaXMudHJhbnNsYXRlT2JqZWN0KGtleSwgcGFyYW1zLCBsYW5nKSA6IHRoaXMudHJhbnNsYXRlKGtleSwgcGFyYW1zLCBsYW5nKSkpXG4gICAgICApO1xuICAgIGlmIChpc05pbChsYW5nKSkge1xuICAgICAgcmV0dXJuIHRoaXMubGFuZ0NoYW5nZXMkLnBpcGUoc3dpdGNoTWFwKGxhbmcgPT4gbG9hZChsYW5nKSkpO1xuICAgIH1cblxuICAgIGlmIChpc1Njb3BlT2JqZWN0KGxhbmcpKSB7XG4gICAgICAvLyBpdCdzIGEgc2NvcGUgb2JqZWN0LlxuICAgICAgY29uc3QgcHJvdmlkZXJTY29wZSA9IGxhbmcgYXMgUHJvdmlkZXJTY29wZTtcbiAgICAgIGxhbmcgPSBwcm92aWRlclNjb3BlLnNjb3BlO1xuICAgICAgaW5saW5lTG9hZGVyID0gcmVzb2x2ZUlubGluZUxvYWRlcihwcm92aWRlclNjb3BlLCBwcm92aWRlclNjb3BlLnNjb3BlKTtcbiAgICB9XG5cbiAgICBsYW5nID0gbGFuZyBhcyBzdHJpbmc7XG4gICAgaWYgKHRoaXMuaXNMYW5nKGxhbmcpIHx8IHRoaXMuaXNTY29wZVdpdGhMYW5nKGxhbmcpKSB7XG4gICAgICByZXR1cm4gbG9hZChsYW5nKTtcbiAgICB9XG4gICAgLy8gaXQncyBhIHNjb3BlXG4gICAgY29uc3Qgc2NvcGUgPSBsYW5nO1xuICAgIHJldHVybiB0aGlzLmxhbmdDaGFuZ2VzJC5waXBlKHN3aXRjaE1hcChsYW5nID0+IGxvYWQoYCR7c2NvcGV9LyR7bGFuZ31gLCB7IGlubGluZUxvYWRlciB9KSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHNjb3BlIHdpdGggbGFuZ1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB0b2Rvcy9lbiA9PiB0cnVlXG4gICAqIHRvZG9zID0+IGZhbHNlXG4gICAqL1xuICBwcml2YXRlIGlzU2NvcGVXaXRoTGFuZyhsYW5nOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xhbmcoZ2V0TGFuZ0Zyb21TY29wZShsYW5nKSk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNsYXRlIHRoZSBnaXZlbiBwYXRoIHRoYXQgcmV0dXJucyBhbiBvYmplY3RcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogc2VydmljZS50cmFuc2xhdGVPYmplY3QoJ3BhdGgudG8ub2JqZWN0JywgeydzdWJwYXRoJzogeyB2YWx1ZTogJ3NvbWVWYWx1ZSd9fSkgPT4gcmV0dXJucyB0cmFuc2xhdGVkIG9iamVjdFxuICAgKlxuICAgKi9cbiAgdHJhbnNsYXRlT2JqZWN0PFQgPSBhbnk+KGtleTogc3RyaW5nLCBwYXJhbXM/OiBIYXNoTWFwLCBsYW5nPzogc3RyaW5nKTogVDtcbiAgdHJhbnNsYXRlT2JqZWN0PFQgPSBhbnk+KGtleTogc3RyaW5nW10sIHBhcmFtcz86IEhhc2hNYXAsIGxhbmc/OiBzdHJpbmcpOiBUW107XG4gIHRyYW5zbGF0ZU9iamVjdDxUID0gYW55PihrZXk6IFRyYW5zbGF0ZVBhcmFtcywgcGFyYW1zPzogSGFzaE1hcCwgbGFuZz86IHN0cmluZyk6IFQgfCBUW107XG4gIHRyYW5zbGF0ZU9iamVjdDxUID0gYW55PihrZXk6IEhhc2hNYXAgfCBNYXA8c3RyaW5nLCBIYXNoTWFwPiwgcGFyYW1zPzogbnVsbCwgbGFuZz86IHN0cmluZyk6IFRbXTtcbiAgdHJhbnNsYXRlT2JqZWN0PFQgPSBhbnk+KGtleTogVHJhbnNsYXRlT2JqZWN0UGFyYW1zLCBwYXJhbXM/OiBIYXNoTWFwLCBsYW5nID0gdGhpcy5nZXRBY3RpdmVMYW5nKCkpOiBUIHwgVFtdIHtcbiAgICBpZiAoaXNTdHJpbmcoa2V5KSB8fCBBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGtleS5tYXAoayA9PiB0aGlzLnRyYW5zbGF0ZU9iamVjdChzY29wZSA/IGAke3Njb3BlfS4ke2t9YCA6IGssIHBhcmFtcywgcmVzb2x2ZUxhbmcpKSBhcyBhbnk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHJlc29sdmVMYW5nLCBzY29wZSB9ID0gdGhpcy5yZXNvbHZlTGFuZ0FuZFNjb3BlKGxhbmcpO1xuXG4gICAgICBjb25zdCB0cmFuc2xhdGlvbiA9IHRoaXMuZ2V0VHJhbnNsYXRpb24ocmVzb2x2ZUxhbmcpO1xuICAgICAga2V5ID0gc2NvcGUgPyBgJHtzY29wZX0uJHtrZXl9YCA6IGtleTtcblxuICAgICAgY29uc3QgdmFsdWUgPSB1bmZsYXR0ZW4odGhpcy5nZXRPYmplY3RCeUtleSh0cmFuc2xhdGlvbiwga2V5KSk7XG4gICAgICAvKiBJZiBhbiBlbXB0eSBvYmplY3Qgd2FzIHJldHVybmVkIHdlIHdhbnQgdG8gdHJ5IGFuZCB0cmFuc2xhdGUgdGhlIGtleSBhcyBhIHN0cmluZyBhbmQgbm90IGFuIG9iamVjdCAqL1xuICAgICAgcmV0dXJuIGlzRW1wdHkodmFsdWUpID8gdGhpcy50cmFuc2xhdGUoa2V5LCBwYXJhbXMsIGxhbmcpIDogdGhpcy5wYXJzZXIudHJhbnNwaWxlKHZhbHVlLCBwYXJhbXMsIHRyYW5zbGF0aW9uKTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2xhdGlvbnM6IFRbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgW19rZXksIF9wYXJhbXNdIG9mIHRoaXMuZ2V0RW50cmllcyhrZXkpKSB7XG4gICAgICB0cmFuc2xhdGlvbnMucHVzaCh0aGlzLnRyYW5zbGF0ZU9iamVjdChfa2V5LCBfcGFyYW1zLCBsYW5nKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYW5zbGF0aW9ucztcbiAgfVxuXG4gIHNlbGVjdFRyYW5zbGF0ZU9iamVjdDxUID0gYW55PihrZXk6IHN0cmluZywgcGFyYW1zPzogSGFzaE1hcCwgbGFuZz86IHN0cmluZyk6IE9ic2VydmFibGU8VD47XG4gIHNlbGVjdFRyYW5zbGF0ZU9iamVjdDxUID0gYW55PihrZXk6IHN0cmluZ1tdLCBwYXJhbXM/OiBIYXNoTWFwLCBsYW5nPzogc3RyaW5nKTogT2JzZXJ2YWJsZTxUW10+O1xuICBzZWxlY3RUcmFuc2xhdGVPYmplY3Q8VCA9IGFueT4oa2V5OiBIYXNoTWFwIHwgTWFwPHN0cmluZywgSGFzaE1hcD4sIHBhcmFtcz86IG51bGwsIGxhbmc/OiBzdHJpbmcpOiBPYnNlcnZhYmxlPFRbXT47XG4gIHNlbGVjdFRyYW5zbGF0ZU9iamVjdDxUID0gYW55PihcbiAgICBrZXk6IFRyYW5zbGF0ZU9iamVjdFBhcmFtcyxcbiAgICBwYXJhbXM/OiBIYXNoTWFwLFxuICAgIGxhbmc/OiBzdHJpbmdcbiAgKTogT2JzZXJ2YWJsZTxUPiB8IE9ic2VydmFibGU8VFtdPiB7XG4gICAgaWYgKGlzU3RyaW5nKGtleSkgfHwgQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RUcmFuc2xhdGU8VD4oa2V5LCBwYXJhbXMsIGxhbmcsIHRydWUpO1xuICAgIH1cblxuICAgIGNvbnN0IFtbZmlyc3RLZXksIGZpcnN0UGFyYW1zXSwgLi4ucmVzdF0gPSB0aGlzLmdldEVudHJpZXMoa2V5KTtcblxuICAgIC8qIEluIG9yZGVyIHRvIGF2b2lkIHN1YnNjcmliaW5nIG11bHRpcGxlIHRpbWVzIHRvIHRoZSBsb2FkIGxhbmd1YWdlIGV2ZW50IGJ5IGNhbGxpbmcgc2VsZWN0VHJhbnNsYXRlT2JqZWN0IGZvciBlYWNoIHBhaXIsXG4gICAgICogd2UgbGlzdGVuIHRvIHdoZW4gdGhlIGZpcnN0IGtleSBoYXMgYmVlbiB0cmFuc2xhdGVkICh0aGUgbGFuZ3VhZ2UgaXMgbG9hZGVkKSBhbmQgdHJhbnNsYXRlIHRoZSByZXN0IHN5bmNocm9ub3VzbHkgKi9cbiAgICByZXR1cm4gdGhpcy5zZWxlY3RUcmFuc2xhdGVPYmplY3Q8VD4oZmlyc3RLZXksIGZpcnN0UGFyYW1zLCBsYW5nKS5waXBlKFxuICAgICAgbWFwKHZhbHVlID0+IHtcbiAgICAgICAgY29uc3QgdHJhbnNsYXRpb25zID0gW3ZhbHVlXTtcbiAgICAgICAgZm9yIChjb25zdCBbX2tleSwgX3BhcmFtc10gb2YgcmVzdCkge1xuICAgICAgICAgIHRyYW5zbGF0aW9ucy5wdXNoKHRoaXMudHJhbnNsYXRlT2JqZWN0PFQ+KF9rZXksIF9wYXJhbXMsIGxhbmcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cmFuc2xhdGlvbnM7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBvYmplY3Qgb2YgdHJhbnNsYXRpb25zIGZvciBhIGdpdmVuIGxhbmd1YWdlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGdldFRyYW5zbGF0aW9uKClcbiAgICogZ2V0VHJhbnNsYXRpb24oJ2VuJylcbiAgICogZ2V0VHJhbnNsYXRpb24oJ2FkbWluLXBhZ2UvZW4nKVxuICAgKi9cbiAgZ2V0VHJhbnNsYXRpb24oKTogTWFwPHN0cmluZywgVHJhbnNsYXRpb24+O1xuICBnZXRUcmFuc2xhdGlvbihsYW5nOiBzdHJpbmcpOiBUcmFuc2xhdGlvbjtcbiAgZ2V0VHJhbnNsYXRpb24obGFuZz86IHN0cmluZyk6IE1hcDxzdHJpbmcsIFRyYW5zbGF0aW9uPiB8IFRyYW5zbGF0aW9uIHtcbiAgICByZXR1cm4gbGFuZyA/IHRoaXMudHJhbnNsYXRpb25zLmdldChsYW5nKSB8fCB7fSA6IHRoaXMudHJhbnNsYXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYW4gb2JqZWN0IG9mIHRyYW5zbGF0aW9ucyBmb3IgYSBnaXZlbiBsYW5ndWFnZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBzZWxlY3RUcmFuc2xhdGlvbigpLnN1YnNjcmliZSgpXG4gICAqIHNlbGVjdFRyYW5zbGF0aW9uKCdlcycpLnN1YnNjcmliZSgpXG4gICAqL1xuICBzZWxlY3RUcmFuc2xhdGlvbihsYW5nPzogc3RyaW5nKTogT2JzZXJ2YWJsZTxUcmFuc2xhdGlvbj4ge1xuICAgIGNvbnN0IGxhbmd1YWdlID0gbGFuZyB8fCB0aGlzLmdldEFjdGl2ZUxhbmcoKTtcbiAgICByZXR1cm4gdGhpcy5sb2FkKGxhbmd1YWdlKS5waXBlKG1hcCgoKSA9PiB0aGlzLmdldFRyYW5zbGF0aW9uKGxhbmd1YWdlKSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgb3IgbWVyZ2UgYSBnaXZlbiB0cmFuc2xhdGlvbiBvYmplY3QgdG8gY3VycmVudCBsYW5nXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHNldFRyYW5zbGF0aW9uKHsgLi4uIH0pXG4gICAqIHNldFRyYW5zbGF0aW9uKHsgLi4uIH0sICdlbicpXG4gICAqIHNldFRyYW5zbGF0aW9uKHsgLi4uIH0sICdlcycsIHsgbWVyZ2U6IGZhbHNlIH0gKVxuICAgKiBzZXRUcmFuc2xhdGlvbih7IC4uLiB9LCAndG9kb3MvZW4nLCB7IG1lcmdlOiBmYWxzZSB9IClcbiAgICovXG4gIHNldFRyYW5zbGF0aW9uKHRyYW5zbGF0aW9uOiBUcmFuc2xhdGlvbiwgbGFuZyA9IHRoaXMuZ2V0QWN0aXZlTGFuZygpLCBvcHRpb25zOiBTZXRUcmFuc2xhdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGRlZmF1bHRzID0geyBtZXJnZTogdHJ1ZSwgZW1pdENoYW5nZTogdHJ1ZSB9O1xuICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSB7IC4uLmRlZmF1bHRzLCAuLi5vcHRpb25zIH07XG4gICAgY29uc3Qgc2NvcGUgPSBnZXRTY29wZUZyb21MYW5nKGxhbmcpO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBpc24ndCBhIHNjb3BlIHdlIHVzZSB0aGUgd2hvbGUgdHJhbnNsYXRpb24gYXMgaXNcbiAgICAgKiBvdGhlcndpc2Ugd2UgbmVlZCB0byBmbGF0IHRoZSBzY29wZSBhbmQgdXNlIGl0XG4gICAgICovXG4gICAgbGV0IGZsYXR0ZW5TY29wZU9yVHJhbnNsYXRpb24gPSB0cmFuc2xhdGlvbjtcblxuICAgIC8vIE1lcmdlZCB0aGUgc2NvcGVkIGxhbmd1YWdlIGludG8gdGhlIGFjdGl2ZSBsYW5ndWFnZVxuICAgIGlmIChzY29wZSkge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRNYXBwZWRTY29wZShzY29wZSk7XG4gICAgICBmbGF0dGVuU2NvcGVPclRyYW5zbGF0aW9uID0gZmxhdHRlbih7IFtrZXldOiB0cmFuc2xhdGlvbiB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50TGFuZyA9IHNjb3BlID8gZ2V0TGFuZ0Zyb21TY29wZShsYW5nKSA6IGxhbmc7XG5cbiAgICBjb25zdCBtZXJnZWRUcmFuc2xhdGlvbiA9IHtcbiAgICAgIC4uLihtZXJnZWRPcHRpb25zLm1lcmdlICYmIHRoaXMuZ2V0VHJhbnNsYXRpb24oY3VycmVudExhbmcpKSxcbiAgICAgIC4uLmZsYXR0ZW5TY29wZU9yVHJhbnNsYXRpb25cbiAgICB9O1xuXG4gICAgY29uc3QgZmxhdHRlblRyYW5zbGF0aW9uID0gdGhpcy5tZXJnZWRDb25maWcuZmxhdHRlbi5hb3QgPyBtZXJnZWRUcmFuc2xhdGlvbiA6IGZsYXR0ZW4obWVyZ2VkVHJhbnNsYXRpb24pO1xuICAgIGNvbnN0IHdpdGhIb29rID0gdGhpcy5pbnRlcmNlcHRvci5wcmVTYXZlVHJhbnNsYXRpb24oZmxhdHRlblRyYW5zbGF0aW9uLCBjdXJyZW50TGFuZyk7XG4gICAgdGhpcy50cmFuc2xhdGlvbnMuc2V0KGN1cnJlbnRMYW5nLCB3aXRoSG9vayk7XG4gICAgbWVyZ2VkT3B0aW9ucy5lbWl0Q2hhbmdlICYmIHRoaXMuc2V0QWN0aXZlTGFuZyh0aGlzLmdldEFjdGl2ZUxhbmcoKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0cmFuc2xhdGlvbiBrZXkgd2l0aCBnaXZlbiB2YWx1ZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBzZXRUcmFuc2xhdGlvbktleSgna2V5JywgJ3ZhbHVlJylcbiAgICogc2V0VHJhbnNsYXRpb25LZXkoJ2tleS5uZXN0ZWQnLCAndmFsdWUnKVxuICAgKiBzZXRUcmFuc2xhdGlvbktleSgna2V5Lm5lc3RlZCcsICd2YWx1ZScsICdlbicpXG4gICAqL1xuICBzZXRUcmFuc2xhdGlvbktleShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZywgbGFuZyA9IHRoaXMuZ2V0QWN0aXZlTGFuZygpKSB7XG4gICAgY29uc3Qgd2l0aEhvb2sgPSB0aGlzLmludGVyY2VwdG9yLnByZVNhdmVUcmFuc2xhdGlvbktleShrZXksIHZhbHVlLCBsYW5nKTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHtcbiAgICAgIC4uLnRoaXMuZ2V0VHJhbnNsYXRpb24obGFuZyksXG4gICAgICBba2V5XTogd2l0aEhvb2tcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRUcmFuc2xhdGlvbihuZXdWYWx1ZSwgbGFuZyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZmFsbGJhY2sgbGFuZyBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgbGFuZ3VhZ2VcbiAgICogQHBhcmFtIGZhbGxiYWNrTGFuZ1xuICAgKi9cbiAgc2V0RmFsbGJhY2tMYW5nRm9yTWlzc2luZ1RyYW5zbGF0aW9uKHsgZmFsbGJhY2tMYW5nIH06IFBpY2s8VHJhbnNsb2NvQ29uZmlnLCAnZmFsbGJhY2tMYW5nJz4pOiB2b2lkIHtcbiAgICBjb25zdCBsYW5nID0gQXJyYXkuaXNBcnJheShmYWxsYmFja0xhbmcpID8gZmFsbGJhY2tMYW5nWzBdIDogZmFsbGJhY2tMYW5nO1xuICAgIGlmICh0aGlzLnVzZUZhbGxiYWNrVHJhbnNsYXRpb24obGFuZykgJiYgZmFsbGJhY2tMYW5nKSB7XG4gICAgICB0aGlzLmZpcnN0RmFsbGJhY2tMYW5nID0gbGFuZztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfaGFuZGxlTWlzc2luZ0tleShrZXk6IHN0cmluZywgdmFsdWU6IGFueSwgcGFyYW1zPzogSGFzaE1hcCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5taXNzaW5nSGFuZGxlci5hbGxvd0VtcHR5ICYmIHZhbHVlID09PSAnJykge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnVzZUZhbGxiYWNrVHJhbnNsYXRpb24oKSAmJiAhdGhpcy5pc1Jlc29sdmVkTWlzc2luZ09uY2UpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gc2V0IGl0IHRvIHRydWUgdG8gcHJldmVudCBhIGxvb3BcbiAgICAgIHRoaXMuaXNSZXNvbHZlZE1pc3NpbmdPbmNlID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrVmFsdWUgPSB0aGlzLnRyYW5zbGF0ZShrZXksIHBhcmFtcywgdGhpcy5maXJzdEZhbGxiYWNrTGFuZyk7XG4gICAgICB0aGlzLmlzUmVzb2x2ZWRNaXNzaW5nT25jZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbGxiYWNrVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubWlzc2luZ0hhbmRsZXIuaGFuZGxlKGtleSwgdGhpcy5nZXRNaXNzaW5nSGFuZGxlckRhdGEoKSwgcGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9pc0xhbmdTY29wZWQobGFuZzogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXZhaWxhYmxlTGFuZ3NJZHMoKS5pbmRleE9mKGxhbmcpID09PSAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBnaXZlbiBzdHJpbmcgaXMgb25lIG9mIHRoZSBzcGVjaWZpZWQgYXZhaWxhYmxlIGxhbmd1YWdlcy5cbiAgICogQHJldHVybnNcbiAgICogVHJ1ZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGFuIGF2YWlsYWJsZSBsYW5ndWFnZS5cbiAgICogRmFsc2UgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBub3QgYW4gYXZhaWxhYmxlIGxhbmd1YWdlLlxuICAgKi9cbiAgaXNMYW5nKGxhbmc6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmdldEF2YWlsYWJsZUxhbmdzSWRzKCkuaW5kZXhPZihsYW5nKSAhPT0gLTE7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIFdlIGFsd2F5cyB3YW50IHRvIG1ha2Ugc3VyZSB0aGUgZ2xvYmFsIGxhbmcgaXMgbG9hZGVkXG4gICAqIGJlZm9yZSBsb2FkaW5nIHRoZSBzY29wZSBzaW5jZSB5b3UgY2FuIGFjY2VzcyBib3RoIHZpYSB0aGUgcGlwZS9kaXJlY3RpdmUuXG4gICAqL1xuICBfbG9hZERlcGVuZGVuY2llcyhwYXRoOiBzdHJpbmcsIGlubGluZUxvYWRlcj86IElubGluZUxvYWRlcik6IE9ic2VydmFibGU8VHJhbnNsYXRpb24gfCBUcmFuc2xhdGlvbltdPiB7XG4gICAgY29uc3QgbWFpbkxhbmcgPSBnZXRMYW5nRnJvbVNjb3BlKHBhdGgpO1xuXG4gICAgaWYgKHRoaXMuX2lzTGFuZ1Njb3BlZChwYXRoKSAmJiAhdGhpcy5pc0xvYWRlZFRyYW5zbGF0aW9uKG1haW5MYW5nKSkge1xuICAgICAgcmV0dXJuIGNvbWJpbmVMYXRlc3QodGhpcy5sb2FkKG1haW5MYW5nKSwgdGhpcy5sb2FkKHBhdGgsIHsgaW5saW5lTG9hZGVyIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG9hZChwYXRoLCB7IGlubGluZUxvYWRlciB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9jb21wbGV0ZVNjb3BlV2l0aExhbmcobGFuZ09yU2NvcGU6IHN0cmluZykge1xuICAgIGlmICh0aGlzLl9pc0xhbmdTY29wZWQobGFuZ09yU2NvcGUpICYmICF0aGlzLmlzTGFuZyhnZXRMYW5nRnJvbVNjb3BlKGxhbmdPclNjb3BlKSkpIHtcbiAgICAgIHJldHVybiBgJHtsYW5nT3JTY29wZX0vJHt0aGlzLmdldEFjdGl2ZUxhbmcoKX1gO1xuICAgIH1cbiAgICByZXR1cm4gbGFuZ09yU2NvcGU7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2V0U2NvcGVBbGlhcyhzY29wZTogc3RyaW5nLCBhbGlhczogc3RyaW5nKSB7XG4gICAgaWYgKCF0aGlzLm1lcmdlZENvbmZpZy5zY29wZU1hcHBpbmcpIHtcbiAgICAgIHRoaXMubWVyZ2VkQ29uZmlnLnNjb3BlTWFwcGluZyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLm1lcmdlZENvbmZpZy5zY29wZU1hcHBpbmdbc2NvcGVdID0gYWxpYXM7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBpc0xvYWRlZFRyYW5zbGF0aW9uKGxhbmc6IHN0cmluZykge1xuICAgIHJldHVybiBzaXplKHRoaXMuZ2V0VHJhbnNsYXRpb24obGFuZykpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRBdmFpbGFibGVMYW5nc0lkcygpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLmdldEF2YWlsYWJsZUxhbmdzKClbMF07XG5cbiAgICBpZiAoaXNTdHJpbmcoZmlyc3QpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBdmFpbGFibGVMYW5ncygpIGFzIHN0cmluZ1tdO1xuICAgIH1cblxuICAgIHJldHVybiAodGhpcy5nZXRBdmFpbGFibGVMYW5ncygpIGFzIHsgaWQ6IHN0cmluZyB9W10pLm1hcChsID0+IGwuaWQpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRNaXNzaW5nSGFuZGxlckRhdGEoKTogVHJhbnNsb2NvTWlzc2luZ0hhbmRsZXJEYXRhIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICBhY3RpdmVMYW5nOiB0aGlzLmdldEFjdGl2ZUxhbmcoKSxcbiAgICAgIGF2YWlsYWJsZUxhbmdzOiB0aGlzLmF2YWlsYWJsZUxhbmdzLFxuICAgICAgZGVmYXVsdExhbmc6IHRoaXMuZGVmYXVsdExhbmdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSBhIGZhbGxiYWNrIHRyYW5zbGF0aW9uIHNldCBmb3IgbWlzc2luZyBrZXlzIG9mIHRoZSBwcmltYXJ5IGxhbmd1YWdlXG4gICAqIFRoaXMgaXMgdW5yZWxhdGVkIHRvIHRoZSBmYWxsYmFjayBsYW5ndWFnZSAod2hpY2ggY2hhbmdlcyB0aGUgYWN0aXZlIGxhbmd1YWdlKVxuICAgKi9cbiAgcHJpdmF0ZSB1c2VGYWxsYmFja1RyYW5zbGF0aW9uKGxhbmc/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcubWlzc2luZ0hhbmRsZXIudXNlRmFsbGJhY2tUcmFuc2xhdGlvbiAmJiBsYW5nICE9PSB0aGlzLmZpcnN0RmFsbGJhY2tMYW5nO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVTdWNjZXNzKGxhbmc6IHN0cmluZywgdHJhbnNsYXRpb246IFRyYW5zbGF0aW9uKSB7XG4gICAgdGhpcy5zZXRUcmFuc2xhdGlvbih0cmFuc2xhdGlvbiwgbGFuZywgeyBlbWl0Q2hhbmdlOiBmYWxzZSB9KTtcbiAgICB0aGlzLmZhaWxlZENvdW50ZXIgPSAwO1xuICAgIHRoaXMuZXZlbnRzLm5leHQoe1xuICAgICAgd2FzRmFpbHVyZTogISF0aGlzLmZhaWxlZExhbmdzLnNpemUsXG4gICAgICB0eXBlOiAndHJhbnNsYXRpb25Mb2FkU3VjY2VzcycsXG4gICAgICBwYXlsb2FkOiBnZXRFdmVudFBheWxvYWQobGFuZylcbiAgICB9KTtcbiAgICB0aGlzLmZhaWxlZExhbmdzLmZvckVhY2gobCA9PiB0aGlzLmNhY2hlLmRlbGV0ZShsKSk7XG4gICAgdGhpcy5mYWlsZWRMYW5ncy5jbGVhcigpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVGYWlsdXJlKGxhbmc6IHN0cmluZywgbWVyZ2VkT3B0aW9ucykge1xuICAgIGNvbnN0IHNwbGl0dGVkID0gbGFuZy5zcGxpdCgnLycpO1xuICAgIGNvbnN0IGZhbGxiYWNrcyA9IG1lcmdlZE9wdGlvbnMuZmFsbGJhY2tMYW5ncyB8fCB0aGlzLmZhbGxiYWNrU3RyYXRlZ3kuZ2V0TmV4dExhbmdzKGxhbmcpO1xuICAgIGNvbnN0IG5leHRMYW5nID0gZmFsbGJhY2tzW3RoaXMuZmFpbGVkQ291bnRlcl07XG4gICAgdGhpcy5mYWlsZWRMYW5ncy5hZGQobGFuZyk7XG5cbiAgICAvLyBUaGlzIGhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgYSBsb2FkZWQgZmFsbGJhY2sgbGFuZ3VhZ2UgaXMgcmVxdWVzdGVkIGFnYWluXG4gICAgaWYgKHRoaXMuY2FjaGUuaGFzKG5leHRMYW5nKSkge1xuICAgICAgdGhpcy5oYW5kbGVTdWNjZXNzKG5leHRMYW5nLCB0aGlzLmdldFRyYW5zbGF0aW9uKG5leHRMYW5nKSk7XG4gICAgICByZXR1cm4gRU1QVFk7XG4gICAgfVxuXG4gICAgY29uc3QgaXNGYWxsYmFja0xhbmcgPSBuZXh0TGFuZyA9PT0gc3BsaXR0ZWRbc3BsaXR0ZWQubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoIW5leHRMYW5nIHx8IGlzRmFsbGJhY2tMYW5nKSB7XG4gICAgICBsZXQgbXNnID0gYFVuYWJsZSB0byBsb2FkIHRyYW5zbGF0aW9uIGFuZCBhbGwgdGhlIGZhbGxiYWNrIGxhbmd1YWdlc2A7XG4gICAgICBpZiAoc3BsaXR0ZWQubGVuZ3RoID4gMSkge1xuICAgICAgICBtc2cgKz0gYCwgZGlkIHlvdSBtaXNzcGVsbGVkIHRoZSBzY29wZSBuYW1lP2A7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cblxuICAgIGxldCByZXNvbHZlTGFuZyA9IG5leHRMYW5nO1xuICAgIC8vIGlmIGl0J3Mgc2NvcGVkIGxhbmdcbiAgICBpZiAoc3BsaXR0ZWQubGVuZ3RoID4gMSkge1xuICAgICAgLy8gV2UgbmVlZCB0byByZXNvbHZlIGl0IHRvOlxuICAgICAgLy8gdG9kb3MvbGFuZ05vdEV4aXN0cyA9PiB0b2Rvcy9uZXh0TGFuZ1xuICAgICAgc3BsaXR0ZWRbc3BsaXR0ZWQubGVuZ3RoIC0gMV0gPSBuZXh0TGFuZztcbiAgICAgIHJlc29sdmVMYW5nID0gc3BsaXR0ZWQuam9pbignLycpO1xuICAgIH1cblxuICAgIHRoaXMuZmFpbGVkQ291bnRlcisrO1xuICAgIHRoaXMuZXZlbnRzLm5leHQoe1xuICAgICAgdHlwZTogJ3RyYW5zbGF0aW9uTG9hZEZhaWx1cmUnLFxuICAgICAgcGF5bG9hZDogZ2V0RXZlbnRQYXlsb2FkKGxhbmcpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5sb2FkKHJlc29sdmVMYW5nKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0TWFwcGVkU2NvcGUoc2NvcGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgeyBzY29wZU1hcHBpbmcgPSB7fSB9ID0gdGhpcy5jb25maWc7XG4gICAgcmV0dXJuIHNjb3BlTWFwcGluZ1tzY29wZV0gfHwgdG9DYW1lbENhc2Uoc2NvcGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIGxhbmcgaXMgc2NvcGUgd2UgbmVlZCB0byBjaGVjayB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICAgKiB0b2Rvcy9lcyA9PiBpbiB0aGlzIGNhc2Ugd2Ugc2hvdWxkIHRha2UgYGVzYCBhcyBsYW5nXG4gICAqIHRvZG9zID0+IGluIHRoaXMgY2FzZSB3ZSBzaG91bGQgc2V0IHRoZSBhY3RpdmUgbGFuZyBhcyBsYW5nXG4gICAqL1xuICBwcml2YXRlIHJlc29sdmVMYW5nQW5kU2NvcGUobGFuZzogc3RyaW5nKSB7XG4gICAgbGV0IHJlc29sdmVMYW5nID0gbGFuZztcbiAgICBsZXQgc2NvcGU7XG5cbiAgICBpZiAodGhpcy5faXNMYW5nU2NvcGVkKGxhbmcpKSB7XG4gICAgICAvLyBlbiBmb3IgZXhhbXBsZVxuICAgICAgY29uc3QgbGFuZ0Zyb21TY29wZSA9IGdldExhbmdGcm9tU2NvcGUobGFuZyk7XG4gICAgICAvLyBlbiBpcyBsYW5nXG4gICAgICBjb25zdCBoYXNMYW5nID0gdGhpcy5pc0xhbmcobGFuZ0Zyb21TY29wZSk7XG4gICAgICAvLyB0YWtlIGVuXG4gICAgICByZXNvbHZlTGFuZyA9IGhhc0xhbmcgPyBsYW5nRnJvbVNjb3BlIDogdGhpcy5nZXRBY3RpdmVMYW5nKCk7XG4gICAgICAvLyBmaW5kIHRoZSBzY29wZVxuICAgICAgc2NvcGUgPSB0aGlzLmdldE1hcHBlZFNjb3BlKGhhc0xhbmcgPyBnZXRTY29wZUZyb21MYW5nKGxhbmcpIDogbGFuZyk7XG4gICAgfVxuICAgIHJldHVybiB7IHNjb3BlLCByZXNvbHZlTGFuZyB9O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRPYmplY3RCeUtleSh0cmFuc2xhdGlvbjogVHJhbnNsYXRpb24sIGtleTogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgY29uc3QgcHJlZml4ID0gYCR7a2V5fS5gO1xuXG4gICAgZm9yIChjb25zdCBjdXJyZW50S2V5IGluIHRyYW5zbGF0aW9uKSB7XG4gICAgICBpZiAoY3VycmVudEtleS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgICAgcmVzdWx0W2N1cnJlbnRLZXkucmVwbGFjZShwcmVmaXgsICcnKV0gPSB0cmFuc2xhdGlvbltjdXJyZW50S2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRFbnRyaWVzKGtleTogSGFzaE1hcCB8IE1hcDxzdHJpbmcsIEhhc2hNYXA+KSB7XG4gICAgcmV0dXJuIGtleSBpbnN0YW5jZW9mIE1hcCA/IGtleS5lbnRyaWVzKCkgOiBPYmplY3QuZW50cmllcyhrZXkpO1xuICB9XG59XG4iXX0=