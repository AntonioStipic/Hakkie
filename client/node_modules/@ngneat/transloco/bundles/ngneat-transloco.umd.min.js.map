{"version":3,"sources":["node_modules/tslib/tslib.es6.js","ng://@ngneat/transloco/lib/transloco.loader.ts","ng://@ngneat/transloco/lib/helpers.ts","ng://@ngneat/transloco/lib/transloco.transpiler.ts","ng://@ngneat/transloco/lib/transloco.config.ts","ng://@ngneat/transloco/lib/transloco-missing-handler.ts","ng://@ngneat/transloco/lib/transloco.interceptor.ts","ng://@ngneat/transloco/lib/transloco-fallback-strategy.ts","ng://@ngneat/transloco/lib/transloco.service.ts","ng://@ngneat/transloco/lib/shared.ts","ng://@ngneat/transloco/lib/resolve-loader.ts","ng://@ngneat/transloco/lib/get-fallbacks-loaders.ts","ng://@ngneat/transloco/lib/merge-config.ts","ng://@ngneat/transloco/lib/loader-component.component.ts","ng://@ngneat/transloco/lib/template-handler.ts","ng://@ngneat/transloco/lib/transloco-lang.ts","ng://@ngneat/transloco/lib/transloco-loading-template.ts","ng://@ngneat/transloco/lib/transloco-scope.ts","ng://@ngneat/transloco/lib/lang-resolver.ts","ng://@ngneat/transloco/lib/scope-resolver.ts","ng://@ngneat/transloco/lib/transloco.directive.ts","ng://@ngneat/transloco/lib/transloco.pipe.ts","ng://@ngneat/transloco/lib/transloco.module.ts","ng://@ngneat/transloco/lib/transloco-testing.module.ts","ng://@ngneat/transloco/lib/browser-lang.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { InjectionToken } from '@angular/core';\nimport { Observable, of } from 'rxjs';\nimport { Translation } from './types';\n\nexport interface TranslocoLoader {\n  getTranslation(lang: string, data?: TranslocoLoaderData): Observable<Translation> | Promise<Translation>;\n}\n\nexport type TranslocoLoaderData = {\n  scope: string;\n};\n\nexport class DefaultLoader implements TranslocoLoader {\n  constructor(private translations: Map<string, Translation>) {}\n\n  getTranslation(lang: string): Observable<Translation> {\n    return of(this.translations.get(lang) || {});\n  }\n}\n\nexport const TRANSLOCO_LOADER = new InjectionToken<Translation>('TRANSLOCO_LOADER');\n","import { ProviderScope, Translation } from './types';\nimport flat from 'flat';\n\nexport function getValue(obj: object, path: string) {\n  /* For cases where the key is like: 'general.something.thing' */\n  if (obj && obj.hasOwnProperty(path)) {\n    return obj[path];\n  }\n  return path.split('.').reduce((p, c) => p && p[c], obj);\n}\n\nexport function setValue(obj: any, prop: string, val: any) {\n  obj = { ...obj };\n\n  const split = prop.split('.');\n  const lastIndex = split.length - 1;\n\n  split.reduce((acc, part, index) => {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : { ...acc[part] };\n    }\n\n    return acc && acc[part];\n  }, obj);\n\n  return obj;\n}\n\nexport function size(collection) {\n  if (!collection) {\n    return 0;\n  }\n\n  if (Array.isArray(collection)) {\n    return collection.length;\n  }\n\n  if (isObject(collection)) {\n    return Object.keys(collection).length;\n  }\n\n  return !!collection ? collection.length : 0;\n}\n\nexport function isEmpty(collection) {\n  return size(collection) === 0;\n}\n\nexport function isFunction(val: any): val is Function {\n  return typeof val === 'function';\n}\n\nexport function isString(val: any): val is string {\n  return typeof val === 'string';\n}\n\nexport function isNumber(val: any): val is number {\n  return typeof val === 'number';\n}\n\nexport function isObject(item): boolean {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n\nexport function coerceArray(val) {\n  return Array.isArray(val) ? val : [val];\n}\n\n/*\n * @example\n *\n * given: path-to-happiness => pathToHappiness\n * given: path_to_happiness => pathToHappiness\n * given: path-to_happiness => pathToHappiness\n *\n */\nexport function toCamelCase(str: string): string {\n  return str\n    .replace(/(?:^\\w|[A-Z]|\\b\\w)/g, (word, index) => (index == 0 ? word.toLowerCase() : word.toUpperCase()))\n    .replace(/\\s+|_|-|\\//g, '');\n}\n\nexport function isBrowser() {\n  return typeof window !== 'undefined';\n}\n\nexport function isNil(value: any) {\n  return value === null || value === undefined;\n}\n\nexport function isDefined(value: any) {\n  return isNil(value) === false;\n}\n\nexport function toNumber(value: number | string): number | null {\n  if (isNumber(value)) return value;\n\n  if (isString(value) && !isNaN(Number(value) - parseFloat(value))) {\n    return Number(value);\n  }\n\n  return null;\n}\n\nexport function isScopeObject(item: any): item is ProviderScope {\n  return item && typeof item.scope === 'string';\n}\n\nexport function hasInlineLoader(item: any): item is ProviderScope {\n  return item && isObject(item.loader);\n}\n\nexport function unflatten(obj: Translation): Translation {\n  return flat.unflatten(obj, { safe: true });\n}\n\nexport function flatten(obj: Translation): Translation {\n  return flat(obj, { safe: true });\n}\n","import { Injectable, InjectionToken, Injector } from '@angular/core';\nimport { HashMap, Translation } from './types';\nimport { getValue, isString, isObject, setValue, isDefined } from './helpers';\n\nexport const TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');\n\nexport interface TranslocoTranspiler {\n  transpile(value: any, params: HashMap, translation: HashMap): any;\n  onLangChanged?(lang: string): void;\n}\n\nexport class DefaultTranspiler implements TranslocoTranspiler {\n  transpile(value: any, params: HashMap = {}, translation: Translation): any {\n    if (isString(value)) {\n      return value.replace(/{{(.*?)}}/g, (_, match) => {\n        match = match.trim();\n        if (isDefined(params[match])) {\n          return params[match];\n        }\n\n        return isDefined(translation[match]) ? this.transpile(translation[match], params, translation) : '';\n      });\n    }\n\n    if (isObject(value) && params) {\n      value = this.handleObject(value, params, translation);\n    }\n\n    return value;\n  }\n\n  /**\n   *\n   * @example\n   *\n   * const en = {\n   *  a: {\n   *    b: {\n   *      c: \"Hello {{ value }}\"\n   *    }\n   *  }\n   * }\n   *\n   * const params =  {\n   *  \"b.c\": { value: \"Transloco \"}\n   * }\n   *\n   * service.selectTranslate('a', params);\n   *\n   * // the first param will be the result of `en.a`.\n   * // the second param will be `params`.\n   * parser.transpile(value, params, {});\n   *\n   *\n   */\n  protected handleObject(value: any, params: HashMap = {}, translation: Translation) {\n    let result = value;\n    Object.keys(params).forEach(p => {\n      // get the value of \"b.c\" inside \"a\" => \"Hello {{ value }}\"\n      const v = getValue(result, p);\n      // get the params of \"b.c\" => { value: \"Transloco\" }\n      const getParams = getValue(params, p);\n\n      // transpile the value => \"Hello Transloco\"\n      const transpiled = this.transpile(v, getParams, translation);\n\n      // set \"b.c\" to `transpiled`\n      result = setValue(result, p, transpiled);\n    });\n\n    return result;\n  }\n}\n\nexport interface TranslocoTranspilerFunction {\n  transpile(...args: string[]): any;\n}\n\nexport function getFunctionArgs(argsString: string): string[] {\n  const splitted = argsString ? argsString.split(',') : [];\n  const args = [];\n  for (let i = 0; i < splitted.length; i++) {\n    let value = splitted[i].trim();\n    while (value[value.length - 1] === '\\\\') {\n      i++;\n      value = value.replace('\\\\', ',') + splitted[i];\n    }\n    args.push(value);\n  }\n\n  return args;\n}\n\n@Injectable()\nexport class FunctionalTranspiler extends DefaultTranspiler implements TranslocoTranspiler {\n  constructor(private injector: Injector) {\n    super();\n  }\n\n  transpile(value: any, params: HashMap = {}, translation: Translation): any {\n    if (isString(value)) {\n      const transpiled = value.replace(\n        /\\[\\[\\s*(\\w+)\\((.*)\\)\\s*]]/g,\n        (match: string, functionName: string, args: string) => {\n          try {\n            const func: TranslocoTranspilerFunction = this.injector.get(functionName);\n\n            return func.transpile(...getFunctionArgs(args));\n          } catch (e) {\n            let message = `There is an error in: '${value}'. \n                          Check that the you used the right syntax in your translation and that the implementation of ${functionName} is correct.`;\n            if (e.message.includes('NullInjectorError')) {\n              message = `You are using the '${functionName}' function in your translation but no provider was found!`;\n            }\n            throw new Error(message);\n          }\n        }\n      );\n\n      return super.transpile(transpiled, params, translation);\n    }\n\n    if (isObject(value) && params) {\n      value = this.handleObject(value, params, translation);\n    }\n\n    return value;\n  }\n}\n","import { InjectionToken, Provider } from '@angular/core';\nimport { AvailableLangs, HashMap } from './types';\n\nexport type TranslocoConfig = {\n  defaultLang: string;\n  reRenderOnLangChange?: boolean;\n  prodMode?: boolean;\n  fallbackLang?: string | string[];\n  failedRetries?: number;\n  /** @deprecated */\n  scopeMapping?: HashMap<string>;\n  availableLangs?: AvailableLangs;\n  flatten?: {\n    aot?: boolean;\n  };\n  missingHandler?: {\n    logMissingKey?: boolean;\n    useFallbackTranslation?: boolean;\n    allowEmpty?: boolean;\n  };\n};\n\nexport const TRANSLOCO_CONFIG = new InjectionToken('TRANSLOCO_CONFIG', {\n  providedIn: 'root',\n  factory: () => {\n    return {};\n  }\n});\n\nexport const defaultConfig: TranslocoConfig = {\n  defaultLang: 'en',\n  reRenderOnLangChange: false,\n  prodMode: false,\n  failedRetries: 2,\n  availableLangs: [],\n  missingHandler: {\n    logMissingKey: true,\n    useFallbackTranslation: false,\n    allowEmpty: false\n  },\n  flatten: {\n    aot: false\n  }\n};\n\n/**\n * @deprecated\n */\nexport function provideTranslocoConfig(config: Partial<TranslocoConfig> = defaultConfig): Provider {\n  return {\n    provide: TRANSLOCO_CONFIG,\n    useValue: { ...defaultConfig, ...config }\n  };\n}\n\n/**\n * Sets up TranslocoConfig object.\n *\n * @param config The partial config object to load, this is optional,\n * will be spread after defaultConfig.\n */\nexport function translocoConfig(config: Partial<TranslocoConfig> = defaultConfig): TranslocoConfig {\n  return { ...defaultConfig, ...config };\n}\n","import { InjectionToken } from '@angular/core';\n\nimport { TranslocoConfig } from './transloco.config';\nimport { HashMap } from './types';\n\nexport const TRANSLOCO_MISSING_HANDLER = new InjectionToken('TRANSLOCO_MISSING_HANDLER');\n\nexport interface TranslocoMissingHandlerData extends TranslocoConfig {\n  activeLang: string;\n}\n\nexport interface TranslocoMissingHandler {\n  handle(key: string, data: TranslocoMissingHandlerData, params?: HashMap): any;\n}\n\nexport class DefaultHandler implements TranslocoMissingHandler {\n  handle(key: string, config: TranslocoConfig) {\n    if (config.missingHandler.logMissingKey && !config.prodMode) {\n      const msg = `Missing translation for '${key}'`;\n      console.warn(`%c ${msg}`, 'font-size: 12px; color: red');\n    }\n\n    return key;\n  }\n}\n","import { InjectionToken } from '@angular/core';\nimport { Translation } from './types';\n\nexport const TRANSLOCO_INTERCEPTOR = new InjectionToken('TRANSLOCO_INTERCEPTOR');\n\nexport interface TranslocoInterceptor {\n  preSaveTranslation(translation: Translation, lang: string): Translation;\n\n  preSaveTranslationKey(key: string, value: string, lang: string): string;\n}\n\nexport class DefaultInterceptor implements TranslocoInterceptor {\n  preSaveTranslation(translation: Translation, lang: string): Translation {\n    return translation;\n  }\n\n  preSaveTranslationKey(key: string, value: string, lang: string): string {\n    return value;\n  }\n}\n","import { Inject, InjectionToken } from '@angular/core';\nimport { TRANSLOCO_CONFIG, TranslocoConfig } from './transloco.config';\n\nexport const TRANSLOCO_FALLBACK_STRATEGY = new InjectionToken<TranslocoFallbackStrategy>('TRANSLOCO_FALLBACK_STRATEGY');\n\nexport interface TranslocoFallbackStrategy {\n  getNextLangs(failedLang: string): string[];\n}\n\nexport class DefaultFallbackStrategy implements TranslocoFallbackStrategy {\n  constructor(@Inject(TRANSLOCO_CONFIG) private userConfig: TranslocoConfig) {}\n\n  getNextLangs(failedLang: string) {\n    const fallbackLang = this.userConfig.fallbackLang;\n    if (!fallbackLang) {\n      throw new Error('When using the default fallback, a fallback language must be provided in the config!');\n    }\n\n    return Array.isArray(fallbackLang) ? fallbackLang : [fallbackLang];\n  }\n}\n","import { Inject, Injectable, OnDestroy, Optional } from '@angular/core';\nimport { BehaviorSubject, combineLatest, EMPTY, forkJoin, from, Observable, of, Subject, Subscription } from 'rxjs';\nimport { catchError, map, retry, shareReplay, switchMap, tap } from 'rxjs/operators';\nimport { DefaultLoader, TRANSLOCO_LOADER, TranslocoLoader } from './transloco.loader';\nimport { TRANSLOCO_TRANSPILER, TranslocoTranspiler } from './transloco.transpiler';\nimport {\n  AvailableLangs,\n  HashMap,\n  InlineLoader,\n  LoadOptions,\n  ProviderScope,\n  SetTranslationOptions,\n  TranslateObjectParams,\n  TranslateParams,\n  Translation,\n  TranslocoEvents,\n  TranslocoScope\n} from './types';\nimport { flatten, isEmpty, isNil, isScopeObject, isString, size, toCamelCase, unflatten } from './helpers';\nimport { defaultConfig, TRANSLOCO_CONFIG, TranslocoConfig } from './transloco.config';\nimport {\n  TRANSLOCO_MISSING_HANDLER,\n  TranslocoMissingHandler,\n  TranslocoMissingHandlerData\n} from './transloco-missing-handler';\nimport { TRANSLOCO_INTERCEPTOR, TranslocoInterceptor } from './transloco.interceptor';\nimport { TRANSLOCO_FALLBACK_STRATEGY, TranslocoFallbackStrategy } from './transloco-fallback-strategy';\nimport { mergeConfig } from './merge-config';\nimport { getEventPayload, getLangFromScope, getScopeFromLang, resolveInlineLoader } from './shared';\nimport { getFallbacksLoaders } from './get-fallbacks-loaders';\nimport { resolveLoader } from './resolve-loader';\n\nlet service: TranslocoService;\n\nexport function translate<T = any>(key: TranslateParams, params: HashMap = {}, lang?: string): T {\n  return service.translate(key, params, lang);\n}\n\n@Injectable({ providedIn: 'root' })\nexport class TranslocoService implements OnDestroy {\n  private subscription: Subscription;\n  private translations = new Map<string, Translation>();\n  private cache = new Map<string, Observable<Translation>>();\n  private firstFallbackLang: string | null = null;\n  private defaultLang: string;\n  private mergedConfig: TranslocoConfig;\n  private availableLangs: AvailableLangs = [];\n  private isResolvedMissingOnce = false;\n  private lang: BehaviorSubject<string>;\n  langChanges$: Observable<string>;\n\n  private events = new Subject<TranslocoEvents>();\n  events$ = this.events.asObservable();\n\n  private failedCounter = 0;\n  private failedLangs = new Set<string>();\n\n  constructor(\n    @Optional() @Inject(TRANSLOCO_LOADER) private loader: TranslocoLoader,\n    @Inject(TRANSLOCO_TRANSPILER) private parser: TranslocoTranspiler,\n    @Inject(TRANSLOCO_MISSING_HANDLER) private missingHandler: TranslocoMissingHandler,\n    @Inject(TRANSLOCO_INTERCEPTOR) private interceptor: TranslocoInterceptor,\n    @Inject(TRANSLOCO_CONFIG) private userConfig: TranslocoConfig,\n    @Inject(TRANSLOCO_FALLBACK_STRATEGY) private fallbackStrategy: TranslocoFallbackStrategy\n  ) {\n    if (!this.loader) {\n      this.loader = new DefaultLoader(this.translations);\n    }\n    service = this;\n    this.mergedConfig = mergeConfig(defaultConfig, userConfig);\n\n    this.setAvailableLangs(this.mergedConfig.availableLangs);\n    this.setFallbackLangForMissingTranslation(this.mergedConfig);\n    this.setDefaultLang(this.mergedConfig.defaultLang);\n    this.lang = new BehaviorSubject<string>(this.getDefaultLang());\n    // Don't use distinctUntilChanged as we need the ability to update\n    // the value when using setTranslation or setTranslationKeys\n    this.langChanges$ = this.lang.asObservable();\n\n    /**\n     * When we have a failure, we want to define the next language that succeeded as the active\n     */\n    this.subscription = this.events$.subscribe(e => {\n      if (e.type === 'translationLoadSuccess' && e.wasFailure) {\n        // Handle scoped lang\n        const lang = getLangFromScope(e.payload.lang);\n        this.setActiveLang(lang);\n      }\n    });\n  }\n\n  get config(): TranslocoConfig {\n    return this.mergedConfig;\n  }\n\n  getDefaultLang() {\n    return this.defaultLang;\n  }\n\n  setDefaultLang(lang: string) {\n    this.defaultLang = lang;\n  }\n\n  getActiveLang() {\n    return this.lang.getValue();\n  }\n\n  setActiveLang(lang: string) {\n    this.lang.next(lang);\n    this.parser.onLangChanged && this.parser.onLangChanged(lang);\n    return this;\n  }\n\n  setAvailableLangs(langs: AvailableLangs) {\n    this.availableLangs = langs;\n  }\n\n  /**\n   * Gets the available languages.\n   *\n   * @returns\n   * An array of the available languages. Can be either a `string[]` or a `{ id: string; label: string }[]`\n   * depending on how the available languages are set in your module.\n   */\n  getAvailableLangs() {\n    return this.availableLangs;\n  }\n\n  load(path: string, options: LoadOptions = {}): Observable<Translation> {\n    if (this.cache.has(path) === false) {\n      let loadTranslation: Observable<Translation | { translation: Translation; lang: string }[]>;\n      const isScope = this._isLangScoped(path);\n      const scope = isScope ? getScopeFromLang(path) : null;\n      if (this.useFallbackTranslation(path)) {\n        // if the path is scope the fallback should be `scope/fallbackLang`;\n        const fallback = isScope ? `${scope}/${this.firstFallbackLang}` : this.firstFallbackLang;\n\n        const loaders = getFallbacksLoaders(path, fallback, this.loader, options.inlineLoader, { scope });\n        loadTranslation = forkJoin(loaders);\n      } else {\n        const loader = resolveLoader(path, this.loader, options.inlineLoader, { scope });\n        loadTranslation = from(loader);\n      }\n\n      const load$ = loadTranslation.pipe(\n        retry(this.config.failedRetries),\n        tap(translation => {\n          if (Array.isArray(translation)) {\n            translation.forEach(t => {\n              this.handleSuccess(t.lang, t.translation);\n              // Save the fallback in cache so we'll not create a redundant request\n              if (t.lang !== path) {\n                this.cache.set(t.lang, of({}));\n              }\n            });\n            return;\n          }\n          this.handleSuccess(path, translation);\n        }),\n        catchError(() => this.handleFailure(path, options)),\n        shareReplay(1)\n      );\n\n      this.cache.set(path, load$);\n    }\n\n    return this.cache.get(path);\n  }\n\n  /**\n   * Gets the instant translated value of a key\n   *\n   * @example\n   *\n   * translate<string>('hello')\n   * translate('hello', { value: 'value' })\n   * translate<string[]>(['hello', 'key'])\n   * translate('hello', { }, 'en')\n   * translate('scope.someKey', { }, 'en')\n   */\n  translate<T = any>(key: TranslateParams, params: HashMap = {}, lang = this.getActiveLang()): T {\n    if (!key) return key as any;\n\n    const { scope, resolveLang } = this.resolveLangAndScope(lang);\n\n    if (Array.isArray(key)) {\n      return key.map(k => this.translate(scope ? `${scope}.${k}` : k, params, resolveLang)) as any;\n    }\n\n    key = scope ? `${scope}.${key}` : key;\n\n    const translation = this.getTranslation(resolveLang);\n    const value = translation[key];\n\n    if (!value) {\n      return this._handleMissingKey(key, value, params);\n    }\n\n    return this.parser.transpile(value, params, translation);\n  }\n\n  /**\n   * Gets the translated value of a key as observable\n   *\n   * @example\n   *\n   * selectTranslate<string>('hello').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, 'es').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, 'todos').subscribe(value => ...)\n   * selectTranslate<string>('hello', {}, { scope: 'todos' }).subscribe(value => ...)\n   *\n   */\n  selectTranslate<T = any>(\n    key: TranslateParams,\n    params?: HashMap,\n    lang?: string | TranslocoScope,\n    _isObject = false\n  ): Observable<T> {\n    let inlineLoader = null;\n    const load = (lang, options?: LoadOptions) =>\n      this.load(lang, options).pipe(\n        map(() => (_isObject ? this.translateObject(key, params, lang) : this.translate(key, params, lang)))\n      );\n    if (isNil(lang)) {\n      return this.langChanges$.pipe(switchMap(lang => load(lang)));\n    }\n\n    if (isScopeObject(lang)) {\n      // it's a scope object.\n      const providerScope = lang as ProviderScope;\n      lang = providerScope.scope;\n      inlineLoader = resolveInlineLoader(providerScope, providerScope.scope);\n    }\n\n    lang = lang as string;\n    if (this.isLang(lang) || this.isScopeWithLang(lang)) {\n      return load(lang);\n    }\n    // it's a scope\n    const scope = lang;\n    return this.langChanges$.pipe(switchMap(lang => load(`${scope}/${lang}`, { inlineLoader })));\n  }\n\n  /**\n   * Whether the scope with lang\n   *\n   * @example\n   *\n   * todos/en => true\n   * todos => false\n   */\n  private isScopeWithLang(lang: string) {\n    return this.isLang(getLangFromScope(lang));\n  }\n\n  /**\n   * Translate the given path that returns an object\n   *\n   * @example\n   *\n   * service.translateObject('path.to.object', {'subpath': { value: 'someValue'}}) => returns translated object\n   *\n   */\n  translateObject<T = any>(key: string, params?: HashMap, lang?: string): T;\n  translateObject<T = any>(key: string[], params?: HashMap, lang?: string): T[];\n  translateObject<T = any>(key: TranslateParams, params?: HashMap, lang?: string): T | T[];\n  translateObject<T = any>(key: HashMap | Map<string, HashMap>, params?: null, lang?: string): T[];\n  translateObject<T = any>(key: TranslateObjectParams, params?: HashMap, lang = this.getActiveLang()): T | T[] {\n    if (isString(key) || Array.isArray(key)) {\n      if (Array.isArray(key)) {\n        return key.map(k => this.translateObject(scope ? `${scope}.${k}` : k, params, resolveLang)) as any;\n      }\n      const { resolveLang, scope } = this.resolveLangAndScope(lang);\n\n      const translation = this.getTranslation(resolveLang);\n      key = scope ? `${scope}.${key}` : key;\n\n      const value = unflatten(this.getObjectByKey(translation, key));\n      /* If an empty object was returned we want to try and translate the key as a string and not an object */\n      return isEmpty(value) ? this.translate(key, params, lang) : this.parser.transpile(value, params, translation);\n    }\n\n    const translations: T[] = [];\n    for (const [_key, _params] of this.getEntries(key)) {\n      translations.push(this.translateObject(_key, _params, lang));\n    }\n\n    return translations;\n  }\n\n  selectTranslateObject<T = any>(key: string, params?: HashMap, lang?: string): Observable<T>;\n  selectTranslateObject<T = any>(key: string[], params?: HashMap, lang?: string): Observable<T[]>;\n  selectTranslateObject<T = any>(key: HashMap | Map<string, HashMap>, params?: null, lang?: string): Observable<T[]>;\n  selectTranslateObject<T = any>(\n    key: TranslateObjectParams,\n    params?: HashMap,\n    lang?: string\n  ): Observable<T> | Observable<T[]> {\n    if (isString(key) || Array.isArray(key)) {\n      return this.selectTranslate<T>(key, params, lang, true);\n    }\n\n    const [[firstKey, firstParams], ...rest] = this.getEntries(key);\n\n    /* In order to avoid subscribing multiple times to the load language event by calling selectTranslateObject for each pair,\n     * we listen to when the first key has been translated (the language is loaded) and translate the rest synchronously */\n    return this.selectTranslateObject<T>(firstKey, firstParams, lang).pipe(\n      map(value => {\n        const translations = [value];\n        for (const [_key, _params] of rest) {\n          translations.push(this.translateObject<T>(_key, _params, lang));\n        }\n\n        return translations;\n      })\n    );\n  }\n\n  /**\n   * Gets an object of translations for a given language\n   *\n   * @example\n   *\n   * getTranslation()\n   * getTranslation('en')\n   * getTranslation('admin-page/en')\n   */\n  getTranslation(): Map<string, Translation>;\n  getTranslation(lang: string): Translation;\n  getTranslation(lang?: string): Map<string, Translation> | Translation {\n    return lang ? this.translations.get(lang) || {} : this.translations;\n  }\n\n  /**\n   * Gets an object of translations for a given language\n   *\n   * @example\n   *\n   * selectTranslation().subscribe()\n   * selectTranslation('es').subscribe()\n   */\n  selectTranslation(lang?: string): Observable<Translation> {\n    const language = lang || this.getActiveLang();\n    return this.load(language).pipe(map(() => this.getTranslation(language)));\n  }\n\n  /**\n   * Sets or merge a given translation object to current lang\n   *\n   * @example\n   *\n   * setTranslation({ ... })\n   * setTranslation({ ... }, 'en')\n   * setTranslation({ ... }, 'es', { merge: false } )\n   * setTranslation({ ... }, 'todos/en', { merge: false } )\n   */\n  setTranslation(translation: Translation, lang = this.getActiveLang(), options: SetTranslationOptions = {}) {\n    const defaults = { merge: true, emitChange: true };\n    const mergedOptions = { ...defaults, ...options };\n    const scope = getScopeFromLang(lang);\n\n    /**\n     * If this isn't a scope we use the whole translation as is\n     * otherwise we need to flat the scope and use it\n     */\n    let flattenScopeOrTranslation = translation;\n\n    // Merged the scoped language into the active language\n    if (scope) {\n      const key = this.getMappedScope(scope);\n      flattenScopeOrTranslation = flatten({ [key]: translation });\n    }\n\n    const currentLang = scope ? getLangFromScope(lang) : lang;\n\n    const mergedTranslation = {\n      ...(mergedOptions.merge && this.getTranslation(currentLang)),\n      ...flattenScopeOrTranslation\n    };\n\n    const flattenTranslation = this.mergedConfig.flatten.aot ? mergedTranslation : flatten(mergedTranslation);\n    const withHook = this.interceptor.preSaveTranslation(flattenTranslation, currentLang);\n    this.translations.set(currentLang, withHook);\n    mergedOptions.emitChange && this.setActiveLang(this.getActiveLang());\n  }\n\n  /**\n   * Sets translation key with given value\n   *\n   * @example\n   *\n   * setTranslationKey('key', 'value')\n   * setTranslationKey('key.nested', 'value')\n   * setTranslationKey('key.nested', 'value', 'en')\n   */\n  setTranslationKey(key: string, value: string, lang = this.getActiveLang()) {\n    const withHook = this.interceptor.preSaveTranslationKey(key, value, lang);\n    const newValue = {\n      ...this.getTranslation(lang),\n      [key]: withHook\n    };\n\n    this.setTranslation(newValue, lang);\n  }\n\n  /**\n   * Sets the fallback lang for the currently active language\n   * @param fallbackLang\n   */\n  setFallbackLangForMissingTranslation({ fallbackLang }: Pick<TranslocoConfig, 'fallbackLang'>): void {\n    const lang = Array.isArray(fallbackLang) ? fallbackLang[0] : fallbackLang;\n    if (this.useFallbackTranslation(lang) && fallbackLang) {\n      this.firstFallbackLang = lang;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _handleMissingKey(key: string, value: any, params?: HashMap) {\n    if (this.config.missingHandler.allowEmpty && value === '') {\n      return '';\n    }\n\n    if (this.useFallbackTranslation() && !this.isResolvedMissingOnce) {\n      // We need to set it to true to prevent a loop\n      this.isResolvedMissingOnce = true;\n      const fallbackValue = this.translate(key, params, this.firstFallbackLang);\n      this.isResolvedMissingOnce = false;\n      return fallbackValue;\n    }\n\n    return this.missingHandler.handle(key, this.getMissingHandlerData(), params);\n  }\n\n  /**\n   * @internal\n   */\n  _isLangScoped(lang: string) {\n    return this.getAvailableLangsIds().indexOf(lang) === -1;\n  }\n\n  /**\n   * Checks if a given string is one of the specified available languages.\n   * @returns\n   * True if the given string is an available language.\n   * False if the given string is not an available language.\n   */\n  isLang(lang: string): boolean {\n    return this.getAvailableLangsIds().indexOf(lang) !== -1;\n  }\n\n  /**\n   * @internal\n   *\n   * We always want to make sure the global lang is loaded\n   * before loading the scope since you can access both via the pipe/directive.\n   */\n  _loadDependencies(path: string, inlineLoader?: InlineLoader): Observable<Translation | Translation[]> {\n    const mainLang = getLangFromScope(path);\n\n    if (this._isLangScoped(path) && !this.isLoadedTranslation(mainLang)) {\n      return combineLatest(this.load(mainLang), this.load(path, { inlineLoader }));\n    }\n    return this.load(path, { inlineLoader });\n  }\n\n  /**\n   * @internal\n   */\n  _completeScopeWithLang(langOrScope: string) {\n    if (this._isLangScoped(langOrScope) && !this.isLang(getLangFromScope(langOrScope))) {\n      return `${langOrScope}/${this.getActiveLang()}`;\n    }\n    return langOrScope;\n  }\n\n  /**\n   * @internal\n   */\n  _setScopeAlias(scope: string, alias: string) {\n    if (!this.mergedConfig.scopeMapping) {\n      this.mergedConfig.scopeMapping = {};\n    }\n    this.mergedConfig.scopeMapping[scope] = alias;\n  }\n\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n\n  private isLoadedTranslation(lang: string) {\n    return size(this.getTranslation(lang));\n  }\n\n  private getAvailableLangsIds(): string[] {\n    const first = this.getAvailableLangs()[0];\n\n    if (isString(first)) {\n      return this.getAvailableLangs() as string[];\n    }\n\n    return (this.getAvailableLangs() as { id: string }[]).map(l => l.id);\n  }\n\n  private getMissingHandlerData(): TranslocoMissingHandlerData {\n    return {\n      ...this.config,\n      activeLang: this.getActiveLang(),\n      availableLangs: this.availableLangs,\n      defaultLang: this.defaultLang\n    };\n  }\n\n  /**\n   * Use a fallback translation set for missing keys of the primary language\n   * This is unrelated to the fallback language (which changes the active language)\n   */\n  private useFallbackTranslation(lang?: string) {\n    return this.config.missingHandler.useFallbackTranslation && lang !== this.firstFallbackLang;\n  }\n\n  private handleSuccess(lang: string, translation: Translation) {\n    this.setTranslation(translation, lang, { emitChange: false });\n    this.failedCounter = 0;\n    this.events.next({\n      wasFailure: !!this.failedLangs.size,\n      type: 'translationLoadSuccess',\n      payload: getEventPayload(lang)\n    });\n    this.failedLangs.forEach(l => this.cache.delete(l));\n    this.failedLangs.clear();\n  }\n\n  private handleFailure(lang: string, mergedOptions) {\n    const splitted = lang.split('/');\n    const fallbacks = mergedOptions.fallbackLangs || this.fallbackStrategy.getNextLangs(lang);\n    const nextLang = fallbacks[this.failedCounter];\n    this.failedLangs.add(lang);\n\n    // This handles the case where a loaded fallback language is requested again\n    if (this.cache.has(nextLang)) {\n      this.handleSuccess(nextLang, this.getTranslation(nextLang));\n      return EMPTY;\n    }\n\n    const isFallbackLang = nextLang === splitted[splitted.length - 1];\n\n    if (!nextLang || isFallbackLang) {\n      let msg = `Unable to load translation and all the fallback languages`;\n      if (splitted.length > 1) {\n        msg += `, did you misspelled the scope name?`;\n      }\n\n      throw new Error(msg);\n    }\n\n    let resolveLang = nextLang;\n    // if it's scoped lang\n    if (splitted.length > 1) {\n      // We need to resolve it to:\n      // todos/langNotExists => todos/nextLang\n      splitted[splitted.length - 1] = nextLang;\n      resolveLang = splitted.join('/');\n    }\n\n    this.failedCounter++;\n    this.events.next({\n      type: 'translationLoadFailure',\n      payload: getEventPayload(lang)\n    });\n\n    return this.load(resolveLang);\n  }\n\n  private getMappedScope(scope: string): string {\n    const { scopeMapping = {} } = this.config;\n    return scopeMapping[scope] || toCamelCase(scope);\n  }\n\n  /**\n   * If lang is scope we need to check the following cases:\n   * todos/es => in this case we should take `es` as lang\n   * todos => in this case we should set the active lang as lang\n   */\n  private resolveLangAndScope(lang: string) {\n    let resolveLang = lang;\n    let scope;\n\n    if (this._isLangScoped(lang)) {\n      // en for example\n      const langFromScope = getLangFromScope(lang);\n      // en is lang\n      const hasLang = this.isLang(langFromScope);\n      // take en\n      resolveLang = hasLang ? langFromScope : this.getActiveLang();\n      // find the scope\n      scope = this.getMappedScope(hasLang ? getScopeFromLang(lang) : lang);\n    }\n    return { scope, resolveLang };\n  }\n\n  private getObjectByKey(translation: Translation, key: string) {\n    const result = {};\n    const prefix = `${key}.`;\n\n    for (const currentKey in translation) {\n      if (currentKey.startsWith(prefix)) {\n        result[currentKey.replace(prefix, '')] = translation[currentKey];\n      }\n    }\n\n    return result;\n  }\n\n  private getEntries(key: HashMap | Map<string, HashMap>) {\n    return key instanceof Map ? key.entries() : Object.entries(key);\n  }\n}\n","import { TranslocoService } from './transloco.service';\nimport { hasInlineLoader, isString } from './helpers';\nimport { take } from 'rxjs/operators';\nimport { InlineLoader, TranslocoScope } from './types';\n\n/*\n * @example\n *\n * given: lazy-page/en => lazy-page\n *\n */\nexport function getScopeFromLang(lang: string): string {\n  if (!lang) {\n    return '';\n  }\n  const split = lang.split('/');\n  split.pop();\n  return split.join('/');\n}\n\n/*\n * @example\n *\n * given: lazy-page/en => en\n *\n */\nexport function getLangFromScope(lang: string): string {\n  if (!lang) {\n    return '';\n  }\n  const split = lang.split('/');\n  return split.pop();\n}\n\n/**\n * @example\n *\n * getPipeValue('todos|scoped', 'scoped') [true, 'todos']\n * getPipeValue('en|static', 'static') [true, 'en']\n * getPipeValue('en', 'static') [false, 'en']\n */\nexport function getPipeValue(str: string, value: string, char = '|'): [boolean, string] {\n  if (isString(str)) {\n    const splitted = str.split(char);\n    const lastItem = splitted.pop();\n    return lastItem === value ? [true, splitted.toString()] : [false, lastItem];\n  }\n\n  return [false, ''];\n}\n\nexport function shouldListenToLangChanges(service: TranslocoService, lang: string) {\n  const [hasStatic] = getPipeValue(lang, 'static');\n  if (hasStatic === false) {\n    // If we didn't get 'lang|static' check if it's set in the global level\n    return service.config.reRenderOnLangChange;\n  }\n\n  // We have 'lang|static' so don't listen to lang changes\n  return false;\n}\n\nexport function listenOrNotOperator(listenToLangChange: boolean) {\n  return listenToLangChange ? source => source : take(1);\n}\n\nfunction prependScope(inlineLoader, scope) {\n  return Object.keys(inlineLoader).reduce((acc, lang) => {\n    acc[`${scope}/${lang}`] = inlineLoader[lang];\n    return acc;\n  }, {});\n}\n\nexport function resolveInlineLoader(providerScope: TranslocoScope | null, scope: string): InlineLoader | null {\n  return hasInlineLoader(providerScope) ? prependScope(providerScope.loader, scope) : null;\n}\n\nexport function getEventPayload(lang: string) {\n  return {\n    scope: getScopeFromLang(lang) || null,\n    langName: getLangFromScope(lang),\n    lang\n  };\n}\n","import { TranslocoLoader, TranslocoLoaderData } from './transloco.loader';\nimport { InlineLoader } from './types';\nimport { isFunction } from './helpers';\n\nexport function resolveLoader(\n  path: string,\n  mainLoader: TranslocoLoader,\n  inlineLoader: InlineLoader,\n  data: TranslocoLoaderData\n) {\n  if (inlineLoader) {\n    const pathLoader = inlineLoader[path];\n    if (isFunction(pathLoader) === false) {\n      throw `You're using an inline loader but didn't provide a loader for ${path}`;\n    }\n\n    return inlineLoader[path]().then(res => (res.default ? res.default : res));\n  }\n\n  return mainLoader.getTranslation(path, data);\n}\n","import { from } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { resolveLoader } from './resolve-loader';\nimport { TranslocoLoader, TranslocoLoaderData } from './transloco.loader';\nimport { InlineLoader } from './types';\n\nexport function getFallbacksLoaders(\n  mainPath: string,\n  fallbackPath: string,\n  mainLoader: TranslocoLoader,\n  inlineLoader: InlineLoader,\n  data: TranslocoLoaderData\n) {\n  return [mainPath, fallbackPath].map(path => {\n    const loader = resolveLoader(path, mainLoader, inlineLoader, data);\n\n    return from(loader).pipe(\n      map(translation => ({\n        translation,\n        lang: path\n      }))\n    );\n  });\n}\n","import { TranslocoConfig } from './transloco.config';\n\nexport function mergeConfig(defaultConfig: TranslocoConfig, userConfig: Partial<TranslocoConfig>) {\n  return {\n    ...defaultConfig,\n    ...userConfig,\n    missingHandler: {\n      ...defaultConfig.missingHandler,\n      ...userConfig.missingHandler\n    },\n    flatten: {\n      ...defaultConfig.flatten,\n      ...userConfig.flatten\n    }\n  };\n}\n","import { Component, Input } from '@angular/core';\r\n\r\n@Component({\r\n  template: `\r\n    <div class=\"transloco-loader-template\" [innerHTML]=\"html\"></div>\r\n  `\r\n})\r\nexport class TranslocoLoaderComponent {\r\n  @Input() html: string;\r\n}\r\n","import { ComponentRef, TemplateRef, ViewContainerRef, ComponentFactoryResolver, Injector, Type } from '@angular/core';\r\nimport { isString } from './helpers';\r\nimport { TranslocoLoaderComponent } from './loader-component.component';\r\n\r\nexport type View = string | TemplateRef<any> | Type<any>;\r\n\r\nexport class TemplateHandler {\r\n  private injector: Injector;\r\n\r\n  constructor(private view: View, private vcr: ViewContainerRef) {\r\n    this.injector = this.vcr.injector;\r\n  }\r\n\r\n  attachView() {\r\n    if (this.view instanceof TemplateRef) {\r\n      this.vcr.createEmbeddedView(this.view);\r\n    } else if (isString(this.view)) {\r\n      const componentRef = this.createComponent<TranslocoLoaderComponent>(TranslocoLoaderComponent);\r\n      componentRef.instance.html = this.view;\r\n      componentRef.hostView.detectChanges();\r\n    } else {\r\n      this.createComponent(this.view);\r\n    }\r\n  }\r\n\r\n  detachView() {\r\n    this.vcr.clear();\r\n  }\r\n\r\n  private createComponent<T>(cmp: Type<any>): ComponentRef<T> {\r\n    const cfr = this.injector.get(ComponentFactoryResolver);\r\n    const factory = cfr.resolveComponentFactory(cmp);\r\n\r\n    return this.vcr.createComponent(factory);\r\n  }\r\n}\r\n","import { InjectionToken } from '@angular/core';\n\nexport const TRANSLOCO_LANG = new InjectionToken<string>('TRANSLOCO_LANG');\n","import { InjectionToken, ComponentRef } from '@angular/core';\n\nexport const TRANSLOCO_LOADING_TEMPLATE = new InjectionToken<{ component: ComponentRef<any> | string }>(\n  'TRANSLOCO_LOADING_TEMPLATE'\n);\n","import { InjectionToken } from '@angular/core';\nimport { TranslocoScope } from './types';\n\nexport const TRANSLOCO_SCOPE = new InjectionToken<TranslocoScope>('TRANSLOCO_SCOPE');\n","import { getLangFromScope, getPipeValue, getScopeFromLang } from './shared';\n\ntype LangResolverParams = {\n  inline: string | undefined;\n  provider: string | undefined;\n  active: string | undefined;\n};\n\nexport class LangResolver {\n  initialized = false;\n\n  // inline => provider => active\n  resolve(\n    { inline, provider, active }: LangResolverParams = { inline: undefined, provider: undefined, active: undefined }\n  ) {\n    let lang = active;\n    /**\n     * When the user changes the lang we need to update\n     * the view. Otherwise, the lang will remain the inline/provided lang\n     */\n    if (this.initialized) {\n      lang = active;\n      return lang;\n    }\n\n    if (provider) {\n      const [_, extracted] = getPipeValue(provider, 'static');\n      lang = extracted;\n    }\n\n    if (inline) {\n      const [_, extracted] = getPipeValue(inline, 'static');\n      lang = extracted;\n    }\n\n    this.initialized = true;\n    return lang;\n  }\n\n  /**\n   *\n   * Resolve the lang\n   *\n   * @example\n   *\n   * resolveLangBasedOnScope('todos/en') => en\n   * resolveLangBasedOnScope('en') => en\n   *\n   */\n  resolveLangBasedOnScope(lang: string) {\n    const scope = getScopeFromLang(lang);\n    return scope ? getLangFromScope(lang) : lang;\n  }\n\n  /**\n   *\n   * Resolve the lang path for loading\n   *\n   * @example\n   *\n   * resolveLangPath('todos', 'en') => todos/en\n   * resolveLangPath('en') => en\n   *\n   */\n  resolveLangPath(lang: string, scope: string | undefined) {\n    return scope ? `${scope}/${lang}` : lang;\n  }\n}\n","import { TranslocoScope, ProviderScope, MaybeArray } from './types';\nimport { TranslocoService } from './transloco.service';\nimport { isScopeObject, toCamelCase } from './helpers';\n\ntype ScopeResolverParams = {\n  inline: string | undefined;\n  provider: MaybeArray<TranslocoScope>;\n};\n\nexport class ScopeResolver {\n  constructor(private translocoService: TranslocoService) {}\n\n  // inline => provider\n  resolve({ inline, provider }: ScopeResolverParams = { inline: undefined, provider: undefined }): string {\n    if (inline) {\n      return inline;\n    }\n\n    if (provider) {\n      if (isScopeObject(provider)) {\n        const { scope, alias = toCamelCase(scope) } = provider as ProviderScope;\n        this.translocoService._setScopeAlias(scope, alias);\n        return scope;\n      }\n\n      return provider as string;\n    }\n\n    return undefined;\n  }\n}\n","import {\n  ChangeDetectorRef,\n  Directive,\n  ElementRef,\n  EmbeddedViewRef,\n  Inject,\n  Input,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Optional,\n  TemplateRef,\n  Type,\n  ViewContainerRef\n} from '@angular/core';\nimport { forkJoin, Observable, Subscription } from 'rxjs';\nimport { switchMap } from 'rxjs/operators';\nimport { TemplateHandler, View } from './template-handler';\nimport { TRANSLOCO_LANG } from './transloco-lang';\nimport { TRANSLOCO_LOADING_TEMPLATE } from './transloco-loading-template';\nimport { TRANSLOCO_SCOPE } from './transloco-scope';\nimport { TranslocoService } from './transloco.service';\nimport { HashMap, MaybeArray, Translation, TranslocoScope } from './types';\nimport { listenOrNotOperator, resolveInlineLoader, shouldListenToLangChanges } from './shared';\nimport { LangResolver } from './lang-resolver';\nimport { ScopeResolver } from './scope-resolver';\n\n@Directive({\n  selector: '[transloco]'\n})\nexport class TranslocoDirective implements OnInit, OnDestroy, OnChanges {\n  subscription: Subscription | null;\n  view: EmbeddedViewRef<any>;\n  private translationMemo: { [key: string]: { value: any; params: HashMap } } = {};\n\n  @Input('transloco') key: string;\n  @Input('translocoParams') params: HashMap = {};\n  @Input('translocoScope') inlineScope: string | undefined;\n  @Input('translocoRead') inlineRead: string | undefined;\n  @Input('translocoLang') inlineLang: string | undefined;\n  @Input('translocoLoadingTpl') inlineTpl: TemplateRef<any> | undefined;\n\n  private currentLang: string;\n  private loaderTplHandler: TemplateHandler = null;\n  // Whether we already rendered the view once\n  private initialized = false;\n  private path: string;\n  private langResolver = new LangResolver();\n  private scopeResolver = new ScopeResolver(this.translocoService);\n\n  constructor(\n    private translocoService: TranslocoService,\n    @Optional() private tpl: TemplateRef<{ $implicit: (key: string, params?: HashMap) => any }>,\n    @Optional() @Inject(TRANSLOCO_SCOPE) private providerScope: MaybeArray<TranslocoScope>,\n    @Optional() @Inject(TRANSLOCO_LANG) private providerLang: string | null,\n    @Optional() @Inject(TRANSLOCO_LOADING_TEMPLATE) private providedLoadingTpl: Type<any> | string,\n    private vcr: ViewContainerRef,\n    private cdr: ChangeDetectorRef,\n    private host: ElementRef\n  ) {}\n\n  ngOnInit() {\n    const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || this.inlineLang);\n\n    this.subscription = this.translocoService.langChanges$\n      .pipe(\n        switchMap(activeLang => {\n          const lang = this.langResolver.resolve({\n            inline: this.inlineLang,\n            provider: this.providerLang,\n            active: activeLang\n          });\n\n          return Array.isArray(this.providerScope)\n            ? forkJoin(\n                (<TranslocoScope[]>this.providerScope).map(providerScope => this.resolveScope(lang, providerScope))\n              )\n            : this.resolveScope(lang, this.providerScope);\n        }),\n        listenOrNotOperator(listenToLangChange)\n      )\n      .subscribe(() => {\n        this.currentLang = this.langResolver.resolveLangBasedOnScope(this.path);\n        this.tpl === null ? this.simpleStrategy() : this.structuralStrategy(this.currentLang, this.inlineRead);\n        this.cdr.markForCheck();\n        this.initialized = true;\n      });\n\n    const loadingTpl = this.getLoadingTpl();\n    if (!this.initialized && loadingTpl) {\n      this.loaderTplHandler = new TemplateHandler(loadingTpl, this.vcr);\n      this.loaderTplHandler.attachView();\n    }\n  }\n\n  ngOnChanges(changes) {\n    // We need to support dynamic keys/params, so if this is not the first change CD cycle\n    // we need to run the function again in order to update the value\n    const notInit = Object.keys(changes).some(v => changes[v].firstChange === false);\n    notInit && this.simpleStrategy();\n  }\n\n  private simpleStrategy() {\n    this.detachLoader();\n    this.host.nativeElement.innerText = this.translocoService.translate(this.key, this.params, this.currentLang);\n  }\n\n  private structuralStrategy(lang: string, read: string | undefined) {\n    this.translationMemo = {};\n\n    if (this.view) {\n      // when the lang changes we need to change the reference so Angular will update the view\n      this.view.context['$implicit'] = this.getTranslateFn(lang, read);\n    } else {\n      this.detachLoader();\n      this.view = this.vcr.createEmbeddedView(this.tpl, {\n        $implicit: this.getTranslateFn(lang, read)\n      });\n    }\n  }\n\n  private getTranslateFn(lang: string, read: string | undefined): (key: string, params?: HashMap) => any {\n    return (key: string, params: HashMap) => {\n      const withRead = read ? `${read}.${key}` : key;\n      const withParams = params ? `${withRead}${JSON.stringify(params)}` : withRead;\n      if (this.translationMemo.hasOwnProperty(withParams)) {\n        return this.translationMemo[withParams].value;\n      }\n      this.translationMemo[withParams] = {\n        params,\n        value: this.translocoService.translate(withRead, params, lang)\n      };\n\n      return this.translationMemo[withParams].value;\n    };\n  }\n\n  private getLoadingTpl(): View {\n    return this.inlineTpl || this.providedLoadingTpl;\n  }\n\n  ngOnDestroy() {\n    this.subscription && this.subscription.unsubscribe();\n  }\n\n  private detachLoader() {\n    this.loaderTplHandler && this.loaderTplHandler.detachView();\n  }\n\n  private resolveScope(lang: string, providerScope: TranslocoScope): Observable<Translation | Translation[]> {\n    let resolvedScope = this.scopeResolver.resolve({ inline: this.inlineScope, provider: providerScope });\n    this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n    const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n    return this.translocoService._loadDependencies(this.path, inlineLoader);\n  }\n}\n","import { ChangeDetectorRef, Inject, OnDestroy, Optional, Pipe, PipeTransform } from '@angular/core';\nimport { TranslocoService } from './transloco.service';\nimport { HashMap, MaybeArray, Translation, TranslocoScope } from './types';\nimport { switchMap } from 'rxjs/operators';\nimport { forkJoin, Observable, Subscription } from 'rxjs';\nimport { TRANSLOCO_SCOPE } from './transloco-scope';\nimport { TRANSLOCO_LANG } from './transloco-lang';\nimport { listenOrNotOperator, resolveInlineLoader, shouldListenToLangChanges } from './shared';\nimport { LangResolver } from './lang-resolver';\nimport { ScopeResolver } from './scope-resolver';\n\n@Pipe({\n  name: 'transloco',\n  pure: false\n})\nexport class TranslocoPipe implements PipeTransform, OnDestroy {\n  private subscription: Subscription | null = null;\n  private lastValue: string = '';\n  private lastKey: string | undefined;\n  private listenToLangChange: boolean;\n  private path: string;\n  private langResolver = new LangResolver();\n  private scopeResolver = new ScopeResolver(this.translocoService);\n\n  constructor(\n    private translocoService: TranslocoService,\n    @Optional() @Inject(TRANSLOCO_SCOPE) private providerScope: MaybeArray<TranslocoScope>,\n    @Optional() @Inject(TRANSLOCO_LANG) private providerLang: string | null,\n    private cdr: ChangeDetectorRef\n  ) {\n    this.listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang);\n  }\n\n  transform(key: string, params?: HashMap | undefined, inlineLang?: string | undefined): string {\n    if (!key) {\n      return key;\n    }\n\n    const keyName = params ? `${key}${JSON.stringify(params)}` : key;\n\n    if (keyName === this.lastKey) {\n      return this.lastValue;\n    }\n\n    this.lastKey = keyName;\n    this.subscription && this.subscription.unsubscribe();\n\n    this.subscription = this.translocoService.langChanges$\n      .pipe(\n        switchMap(activeLang => {\n          const lang = this.langResolver.resolve({\n            inline: inlineLang,\n            provider: this.providerLang,\n            active: activeLang\n          });\n\n          return Array.isArray(this.providerScope)\n            ? forkJoin(\n                (<TranslocoScope[]>this.providerScope).map(providerScope => this.resolveScope(lang, providerScope))\n              )\n            : this.resolveScope(lang, this.providerScope);\n        }),\n        listenOrNotOperator(this.listenToLangChange)\n      )\n      .subscribe(() => this.updateValue(key, params));\n\n    return this.lastValue;\n  }\n\n  ngOnDestroy() {\n    this.subscription && this.subscription.unsubscribe();\n  }\n\n  private updateValue(key: string, params?: HashMap | undefined) {\n    const lang = this.langResolver.resolveLangBasedOnScope(this.path);\n    this.lastValue = this.translocoService.translate(key, params, lang);\n    this.cdr.markForCheck();\n  }\n\n  private resolveScope(lang: string, providerScope: TranslocoScope): Observable<Translation | Translation[]> {\n    let resolvedScope = this.scopeResolver.resolve({ inline: undefined, provider: providerScope });\n    this.path = this.langResolver.resolveLangPath(lang, resolvedScope);\n    const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);\n    return this.translocoService._loadDependencies(this.path, inlineLoader);\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { TranslocoLoaderComponent } from './loader-component.component';\nimport { TranslocoDirective } from './transloco.directive';\nimport { DefaultTranspiler, TRANSLOCO_TRANSPILER } from './transloco.transpiler';\nimport { TranslocoPipe } from './transloco.pipe';\nimport { DefaultHandler, TRANSLOCO_MISSING_HANDLER } from './transloco-missing-handler';\nimport { DefaultInterceptor, TRANSLOCO_INTERCEPTOR } from './transloco.interceptor';\nimport { DefaultFallbackStrategy, TRANSLOCO_FALLBACK_STRATEGY } from './transloco-fallback-strategy';\nimport { TRANSLOCO_CONFIG } from './transloco.config';\n\nexport const defaultProviders = [\n  {\n    provide: TRANSLOCO_TRANSPILER,\n    useClass: DefaultTranspiler\n  },\n  {\n    provide: TRANSLOCO_MISSING_HANDLER,\n    useClass: DefaultHandler\n  },\n  {\n    provide: TRANSLOCO_INTERCEPTOR,\n    useClass: DefaultInterceptor\n  },\n  {\n    provide: TRANSLOCO_FALLBACK_STRATEGY,\n    useClass: DefaultFallbackStrategy,\n    deps: [TRANSLOCO_CONFIG]\n  }\n];\n\n@NgModule({\n  declarations: [TranslocoDirective, TranslocoPipe, TranslocoLoaderComponent],\n  providers: [defaultProviders],\n  exports: [TranslocoDirective, TranslocoPipe],\n  entryComponents: [TranslocoLoaderComponent]\n})\nexport class TranslocoModule {}\n","import { Inject, Injectable, ModuleWithProviders, NgModule } from '@angular/core';\nimport { TRANSLOCO_LOADER, TranslocoLoader } from './transloco.loader';\nimport { HashMap, Translation } from './types';\nimport { Observable, of } from 'rxjs';\nimport { defaultProviders, TranslocoModule } from './transloco.module';\nimport { TranslocoConfig, TRANSLOCO_CONFIG, translocoConfig } from './transloco.config';\n\n@Injectable()\nexport class TestingLoader implements TranslocoLoader {\n  constructor(@Inject('translocoLangs') private langs: HashMap<Translation>) {}\n\n  getTranslation(lang: string): Observable<Translation> | Promise<Translation> {\n    return of(this.langs[lang]);\n  }\n}\n\n@NgModule({\n  exports: [TranslocoModule]\n})\nexport class TranslocoTestingModule {\n  static withLangs(\n    langs: HashMap<Translation>,\n    config: Partial<TranslocoConfig> = {}\n  ): ModuleWithProviders<TranslocoTestingModule> {\n    return {\n      ngModule: TranslocoTestingModule,\n      providers: [\n        {\n          provide: 'translocoLangs',\n          useValue: langs\n        },\n        {\n          provide: TRANSLOCO_LOADER,\n          useClass: TestingLoader\n        },\n        defaultProviders,\n        {\n          provide: TRANSLOCO_CONFIG,\n          useValue: translocoConfig({\n            prodMode: true,\n            missingHandler: { logMissingKey: false },\n            ...config\n          })\n        }\n      ]\n    };\n  }\n}\n","import { isBrowser } from './helpers';\n\n/**\n * Returns the language code name from the browser, e.g. \"en\"\n */\nexport function getBrowserLang(): string | undefined {\n  let browserLang = getBrowserCultureLang();\n  if (isBrowser() === false || !browserLang) {\n    return undefined;\n  }\n\n  if (browserLang.indexOf('-') !== -1) {\n    browserLang = browserLang.split('-')[0];\n  }\n\n  if (browserLang.indexOf('_') !== -1) {\n    browserLang = browserLang.split('_')[0];\n  }\n\n  return browserLang;\n}\n\n/**\n * Returns the culture language code name from the browser, e.g. \"en-US\"\n */\nexport function getBrowserCultureLang(): string {\n  if (isBrowser() === false) {\n    return undefined;\n  }\n\n  const navigator = window.navigator as any;\n  let browserCultureLang = navigator.languages ? navigator.languages[0] : null;\n  browserCultureLang = browserCultureLang || navigator.language || navigator.browserLanguage || navigator.userLanguage;\n\n  return browserCultureLang;\n}\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__assign","assign","t","s","i","n","arguments","length","prototype","call","apply","this","__values","o","Symbol","iterator","m","next","value","done","TypeError","__read","r","e","ar","push","error","DefaultLoader","getTranslation","lang","of","translations","get","TRANSLOCO_LOADER","InjectionToken","getValue","obj","path","split","reduce","c","setValue","prop","val","lastIndex","acc","part","index","isArray","slice","size","collection","isObject","keys","isEmpty","isFunction","isString","isNumber","item","toCamelCase","str","replace","word","toLowerCase","toUpperCase","isBrowser","window","isNil","undefined","isDefined","isScopeObject","scope","hasInlineLoader","loader","unflatten","flat","safe","flatten","TRANSLOCO_TRANSPILER","DefaultTranspiler","transpile","params","translation","_this","_","match","trim","handleObject","result","forEach","v","getParams","transpiled","getFunctionArgs","argsString","splitted","args","_super","FunctionalTranspiler","__extends","__","constructor","create","tslib_1.__extends","functionName","func","injector","__spread","concat","message","includes","Error","Injectable","Injector","TRANSLOCO_CONFIG","providedIn","factory","defaultConfig","defaultLang","reRenderOnLangChange","prodMode","failedRetries","availableLangs","missingHandler","logMissingKey","useFallbackTranslation","allowEmpty","aot","translocoConfig","config","TRANSLOCO_MISSING_HANDLER","DefaultHandler","handle","key","msg","console","warn","TRANSLOCO_INTERCEPTOR","DefaultInterceptor","preSaveTranslation","preSaveTranslationKey","service","TRANSLOCO_FALLBACK_STRATEGY","DefaultFallbackStrategy","getNextLangs","failedLang","fallbackLang","userConfig","Inject","getScopeFromLang","pop","join","getLangFromScope","getPipeValue","char","lastItem","toString","shouldListenToLangChanges","listenOrNotOperator","listenToLangChange","source","take","resolveInlineLoader","providerScope","prependScope","inlineLoader","getEventPayload","langName","resolveLoader","mainLoader","data","then","res","default","TranslocoService","defineProperty","mergedConfig","getDefaultLang","setDefaultLang","getActiveLang","setActiveLang","parser","onLangChanged","setAvailableLangs","langs","getAvailableLangs","load","options","cache","has","loadTranslation","isScope","_isLangScoped","fallback","firstFallbackLang","loaders","getFallbacksLoaders","mainPath","fallbackPath","map","from","pipe","forkJoin","load$","retry","tap","handleSuccess","set","catchError","handleFailure","shareReplay","translate","_a","resolveLangAndScope","resolveLang","k","_handleMissingKey","selectTranslate","_isObject","translateObject","langChanges$","switchMap","isLang","isScopeWithLang","scope_1","resolveLang_1","_b","getObjectByKey","_c","tslib_1.__values","getEntries","_d","_e","_key","_params","selectTranslateObject","firstKey","firstParams","rest","rest_1","rest_1_1","selectTranslation","language","setTranslation","mergedOptions","merge","emitChange","flattenScopeOrTranslation","getMappedScope","currentLang","mergedTranslation","flattenTranslation","withHook","interceptor","setTranslationKey","newValue","setFallbackLangForMissingTranslation","isResolvedMissingOnce","getMissingHandlerData","fallbackValue","getAvailableLangsIds","indexOf","_loadDependencies","mainLang","isLoadedTranslation","combineLatest","_completeScopeWithLang","langOrScope","_setScopeAlias","alias","scopeMapping","ngOnDestroy","subscription","unsubscribe","l","id","activeLang","failedCounter","events","wasFailure","failedLangs","type","payload","delete","clear","nextLang","fallbackLangs","fallbackStrategy","add","EMPTY","isFallbackLang","langFromScope","hasLang","prefix","currentKey","startsWith","Map","entries","Optional","Subject","events$","asObservable","Set","mergeConfig","BehaviorSubject","subscribe","TranslocoLoaderComponent","Component","template","Input","TemplateHandler","attachView","view","TemplateRef","vcr","createEmbeddedView","componentRef","createComponent","instance","html","hostView","detectChanges","detachView","cmp","ComponentFactoryResolver","resolveComponentFactory","TRANSLOCO_LANG","TRANSLOCO_LOADING_TEMPLATE","TRANSLOCO_SCOPE","LangResolver","resolve","inline","provider","active","initialized","resolveLangBasedOnScope","resolveLangPath","ScopeResolver","translocoService","TranslocoDirective","ngOnInit","providerLang","inlineLang","langResolver","resolveScope","tpl","simpleStrategy","structuralStrategy","inlineRead","cdr","markForCheck","loadingTpl","getLoadingTpl","loaderTplHandler","ngOnChanges","changes","some","firstChange","detachLoader","host","nativeElement","innerText","read","translationMemo","context","getTranslateFn","$implicit","withRead","withParams","JSON","stringify","inlineTpl","providedLoadingTpl","resolvedScope","scopeResolver","inlineScope","Directive","selector","decorators","ViewContainerRef","ChangeDetectorRef","ElementRef","TranslocoPipe","transform","keyName","lastKey","updateValue","lastValue","Pipe","name","pure","defaultProviders","provide","useClass","deps","TranslocoModule","NgModule","declarations","providers","exports","entryComponents","TestingLoader","TranslocoTestingModule","withLangs","ngModule","useValue","getBrowserCultureLang","navigator","browserCultureLang","languages","browserLanguage","userLanguage","provideTranslocoConfig","getBrowserLang","browserLang","coerceArray","toNumber","isNaN","Number","parseFloat"],"mappings":"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"}