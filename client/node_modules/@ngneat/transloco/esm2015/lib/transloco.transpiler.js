/**
 * @fileoverview added by tsickle
 * Generated from: lib/transloco.transpiler.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, InjectionToken, Injector } from '@angular/core';
import { getValue, isString, isObject, setValue, isDefined } from './helpers';
/** @type {?} */
export const TRANSLOCO_TRANSPILER = new InjectionToken('TRANSLOCO_TRANSPILER');
/**
 * @record
 */
export function TranslocoTranspiler() { }
if (false) {
    /**
     * @param {?} value
     * @param {?} params
     * @param {?} translation
     * @return {?}
     */
    TranslocoTranspiler.prototype.transpile = function (value, params, translation) { };
    /**
     * @param {?} lang
     * @return {?}
     */
    TranslocoTranspiler.prototype.onLangChanged = function (lang) { };
}
export class DefaultTranspiler {
    /**
     * @param {?} value
     * @param {?=} params
     * @param {?=} translation
     * @return {?}
     */
    transpile(value, params = {}, translation) {
        if (isString(value)) {
            return value.replace(/{{(.*?)}}/g, (/**
             * @param {?} _
             * @param {?} match
             * @return {?}
             */
            (_, match) => {
                match = match.trim();
                if (isDefined(params[match])) {
                    return params[match];
                }
                return isDefined(translation[match]) ? this.transpile(translation[match], params, translation) : '';
            }));
        }
        if (isObject(value) && params) {
            value = this.handleObject(value, params, translation);
        }
        return value;
    }
    /**
     *
     * \@example
     *
     * const en = {
     *  a: {
     *    b: {
     *      c: "Hello {{ value }}"
     *    }
     *  }
     * }
     *
     * const params =  {
     *  "b.c": { value: "Transloco "}
     * }
     *
     * service.selectTranslate('a', params);
     *
     * // the first param will be the result of `en.a`.
     * // the second param will be `params`.
     * parser.transpile(value, params, {});
     *
     *
     * @protected
     * @param {?} value
     * @param {?=} params
     * @param {?=} translation
     * @return {?}
     */
    handleObject(value, params = {}, translation) {
        /** @type {?} */
        let result = value;
        Object.keys(params).forEach((/**
         * @param {?} p
         * @return {?}
         */
        p => {
            // get the value of "b.c" inside "a" => "Hello {{ value }}"
            /** @type {?} */
            const v = getValue(result, p);
            // get the params of "b.c" => { value: "Transloco" }
            /** @type {?} */
            const getParams = getValue(params, p);
            // transpile the value => "Hello Transloco"
            /** @type {?} */
            const transpiled = this.transpile(v, getParams, translation);
            // set "b.c" to `transpiled`
            result = setValue(result, p, transpiled);
        }));
        return result;
    }
}
/**
 * @record
 */
export function TranslocoTranspilerFunction() { }
if (false) {
    /**
     * @param {...?} args
     * @return {?}
     */
    TranslocoTranspilerFunction.prototype.transpile = function (args) { };
}
/**
 * @param {?} argsString
 * @return {?}
 */
export function getFunctionArgs(argsString) {
    /** @type {?} */
    const splitted = argsString ? argsString.split(',') : [];
    /** @type {?} */
    const args = [];
    for (let i = 0; i < splitted.length; i++) {
        /** @type {?} */
        let value = splitted[i].trim();
        while (value[value.length - 1] === '\\') {
            i++;
            value = value.replace('\\', ',') + splitted[i];
        }
        args.push(value);
    }
    return args;
}
export class FunctionalTranspiler extends DefaultTranspiler {
    /**
     * @param {?} injector
     */
    constructor(injector) {
        super();
        this.injector = injector;
    }
    /**
     * @param {?} value
     * @param {?=} params
     * @param {?=} translation
     * @return {?}
     */
    transpile(value, params = {}, translation) {
        if (isString(value)) {
            /** @type {?} */
            const transpiled = value.replace(/\[\[\s*(\w+)\((.*)\)\s*]]/g, (/**
             * @param {?} match
             * @param {?} functionName
             * @param {?} args
             * @return {?}
             */
            (match, functionName, args) => {
                try {
                    /** @type {?} */
                    const func = this.injector.get(functionName);
                    return func.transpile(...getFunctionArgs(args));
                }
                catch (e) {
                    /** @type {?} */
                    let message = `There is an error in: '${value}'. 
                          Check that the you used the right syntax in your translation and that the implementation of ${functionName} is correct.`;
                    if (e.message.includes('NullInjectorError')) {
                        message = `You are using the '${functionName}' function in your translation but no provider was found!`;
                    }
                    throw new Error(message);
                }
            }));
            return super.transpile(transpiled, params, translation);
        }
        if (isObject(value) && params) {
            value = this.handleObject(value, params, translation);
        }
        return value;
    }
}
FunctionalTranspiler.decorators = [
    { type: Injectable }
];
/** @nocollapse */
FunctionalTranspiler.ctorParameters = () => [
    { type: Injector }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    FunctionalTranspiler.prototype.injector;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsb2NvLnRyYW5zcGlsZXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AbmduZWF0L3RyYW5zbG9jby8iLCJzb3VyY2VzIjpbImxpYi90cmFuc2xvY28udHJhbnNwaWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVyRSxPQUFPLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxNQUFNLFdBQVcsQ0FBQzs7QUFFOUUsTUFBTSxPQUFPLG9CQUFvQixHQUFHLElBQUksY0FBYyxDQUFDLHNCQUFzQixDQUFDOzs7O0FBRTlFLHlDQUdDOzs7Ozs7OztJQUZDLG9GQUFrRTs7Ozs7SUFDbEUsa0VBQW1DOztBQUdyQyxNQUFNLE9BQU8saUJBQWlCOzs7Ozs7O0lBQzVCLFNBQVMsQ0FBQyxLQUFVLEVBQUUsU0FBa0IsRUFBRSxFQUFFLFdBQXdCO1FBQ2xFLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ25CLE9BQU8sS0FBSyxDQUFDLE9BQU8sQ0FBQyxZQUFZOzs7OztZQUFFLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxFQUFFO2dCQUM5QyxLQUFLLEdBQUcsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNyQixJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtvQkFDNUIsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQ3RCO2dCQUVELE9BQU8sU0FBUyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsRUFBRSxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUN0RyxDQUFDLEVBQUMsQ0FB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Q3pHO29CQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7aUJBQzFCO1lBQ0gsQ0FBQyxFQUNGO1lBRUQsT0FBTyxLQUFLLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUM7U0FDekQ7UUFFRCxJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxNQUFNLEVBQUU7WUFDN0IsS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxXQUFXLENBQUMsQ0FBQztTQUN2RDtRQUVELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQzs7O1lBbENGLFVBQVU7Ozs7WUE3RjBCLFFBQVE7Ozs7Ozs7SUErRi9CLHdDQUEwQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdGlvblRva2VuLCBJbmplY3RvciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSGFzaE1hcCwgVHJhbnNsYXRpb24gfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGdldFZhbHVlLCBpc1N0cmluZywgaXNPYmplY3QsIHNldFZhbHVlLCBpc0RlZmluZWQgfSBmcm9tICcuL2hlbHBlcnMnO1xuXG5leHBvcnQgY29uc3QgVFJBTlNMT0NPX1RSQU5TUElMRVIgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ1RSQU5TTE9DT19UUkFOU1BJTEVSJyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNsb2NvVHJhbnNwaWxlciB7XG4gIHRyYW5zcGlsZSh2YWx1ZTogYW55LCBwYXJhbXM6IEhhc2hNYXAsIHRyYW5zbGF0aW9uOiBIYXNoTWFwKTogYW55O1xuICBvbkxhbmdDaGFuZ2VkPyhsYW5nOiBzdHJpbmcpOiB2b2lkO1xufVxuXG5leHBvcnQgY2xhc3MgRGVmYXVsdFRyYW5zcGlsZXIgaW1wbGVtZW50cyBUcmFuc2xvY29UcmFuc3BpbGVyIHtcbiAgdHJhbnNwaWxlKHZhbHVlOiBhbnksIHBhcmFtczogSGFzaE1hcCA9IHt9LCB0cmFuc2xhdGlvbjogVHJhbnNsYXRpb24pOiBhbnkge1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC97eyguKj8pfX0vZywgKF8sIG1hdGNoKSA9PiB7XG4gICAgICAgIG1hdGNoID0gbWF0Y2gudHJpbSgpO1xuICAgICAgICBpZiAoaXNEZWZpbmVkKHBhcmFtc1ttYXRjaF0pKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmFtc1ttYXRjaF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNEZWZpbmVkKHRyYW5zbGF0aW9uW21hdGNoXSkgPyB0aGlzLnRyYW5zcGlsZSh0cmFuc2xhdGlvblttYXRjaF0sIHBhcmFtcywgdHJhbnNsYXRpb24pIDogJyc7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNPYmplY3QodmFsdWUpICYmIHBhcmFtcykge1xuICAgICAgdmFsdWUgPSB0aGlzLmhhbmRsZU9iamVjdCh2YWx1ZSwgcGFyYW1zLCB0cmFuc2xhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIGNvbnN0IGVuID0ge1xuICAgKiAgYToge1xuICAgKiAgICBiOiB7XG4gICAqICAgICAgYzogXCJIZWxsbyB7eyB2YWx1ZSB9fVwiXG4gICAqICAgIH1cbiAgICogIH1cbiAgICogfVxuICAgKlxuICAgKiBjb25zdCBwYXJhbXMgPSAge1xuICAgKiAgXCJiLmNcIjogeyB2YWx1ZTogXCJUcmFuc2xvY28gXCJ9XG4gICAqIH1cbiAgICpcbiAgICogc2VydmljZS5zZWxlY3RUcmFuc2xhdGUoJ2EnLCBwYXJhbXMpO1xuICAgKlxuICAgKiAvLyB0aGUgZmlyc3QgcGFyYW0gd2lsbCBiZSB0aGUgcmVzdWx0IG9mIGBlbi5hYC5cbiAgICogLy8gdGhlIHNlY29uZCBwYXJhbSB3aWxsIGJlIGBwYXJhbXNgLlxuICAgKiBwYXJzZXIudHJhbnNwaWxlKHZhbHVlLCBwYXJhbXMsIHt9KTtcbiAgICpcbiAgICpcbiAgICovXG4gIHByb3RlY3RlZCBoYW5kbGVPYmplY3QodmFsdWU6IGFueSwgcGFyYW1zOiBIYXNoTWFwID0ge30sIHRyYW5zbGF0aW9uOiBUcmFuc2xhdGlvbikge1xuICAgIGxldCByZXN1bHQgPSB2YWx1ZTtcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2gocCA9PiB7XG4gICAgICAvLyBnZXQgdGhlIHZhbHVlIG9mIFwiYi5jXCIgaW5zaWRlIFwiYVwiID0+IFwiSGVsbG8ge3sgdmFsdWUgfX1cIlxuICAgICAgY29uc3QgdiA9IGdldFZhbHVlKHJlc3VsdCwgcCk7XG4gICAgICAvLyBnZXQgdGhlIHBhcmFtcyBvZiBcImIuY1wiID0+IHsgdmFsdWU6IFwiVHJhbnNsb2NvXCIgfVxuICAgICAgY29uc3QgZ2V0UGFyYW1zID0gZ2V0VmFsdWUocGFyYW1zLCBwKTtcblxuICAgICAgLy8gdHJhbnNwaWxlIHRoZSB2YWx1ZSA9PiBcIkhlbGxvIFRyYW5zbG9jb1wiXG4gICAgICBjb25zdCB0cmFuc3BpbGVkID0gdGhpcy50cmFuc3BpbGUodiwgZ2V0UGFyYW1zLCB0cmFuc2xhdGlvbik7XG5cbiAgICAgIC8vIHNldCBcImIuY1wiIHRvIGB0cmFuc3BpbGVkYFxuICAgICAgcmVzdWx0ID0gc2V0VmFsdWUocmVzdWx0LCBwLCB0cmFuc3BpbGVkKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2xvY29UcmFuc3BpbGVyRnVuY3Rpb24ge1xuICB0cmFuc3BpbGUoLi4uYXJnczogc3RyaW5nW10pOiBhbnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGdW5jdGlvbkFyZ3MoYXJnc1N0cmluZzogc3RyaW5nKTogc3RyaW5nW10ge1xuICBjb25zdCBzcGxpdHRlZCA9IGFyZ3NTdHJpbmcgPyBhcmdzU3RyaW5nLnNwbGl0KCcsJykgOiBbXTtcbiAgY29uc3QgYXJncyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNwbGl0dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHZhbHVlID0gc3BsaXR0ZWRbaV0udHJpbSgpO1xuICAgIHdoaWxlICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJ1xcXFwnKSB7XG4gICAgICBpKys7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJ1xcXFwnLCAnLCcpICsgc3BsaXR0ZWRbaV07XG4gICAgfVxuICAgIGFyZ3MucHVzaCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gYXJncztcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uYWxUcmFuc3BpbGVyIGV4dGVuZHMgRGVmYXVsdFRyYW5zcGlsZXIgaW1wbGVtZW50cyBUcmFuc2xvY29UcmFuc3BpbGVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgdHJhbnNwaWxlKHZhbHVlOiBhbnksIHBhcmFtczogSGFzaE1hcCA9IHt9LCB0cmFuc2xhdGlvbjogVHJhbnNsYXRpb24pOiBhbnkge1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IHRyYW5zcGlsZWQgPSB2YWx1ZS5yZXBsYWNlKFxuICAgICAgICAvXFxbXFxbXFxzKihcXHcrKVxcKCguKilcXClcXHMqXV0vZyxcbiAgICAgICAgKG1hdGNoOiBzdHJpbmcsIGZ1bmN0aW9uTmFtZTogc3RyaW5nLCBhcmdzOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZnVuYzogVHJhbnNsb2NvVHJhbnNwaWxlckZ1bmN0aW9uID0gdGhpcy5pbmplY3Rvci5nZXQoZnVuY3Rpb25OYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmMudHJhbnNwaWxlKC4uLmdldEZ1bmN0aW9uQXJncyhhcmdzKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBgVGhlcmUgaXMgYW4gZXJyb3IgaW46ICcke3ZhbHVlfScuIFxuICAgICAgICAgICAgICAgICAgICAgICAgICBDaGVjayB0aGF0IHRoZSB5b3UgdXNlZCB0aGUgcmlnaHQgc3ludGF4IGluIHlvdXIgdHJhbnNsYXRpb24gYW5kIHRoYXQgdGhlIGltcGxlbWVudGF0aW9uIG9mICR7ZnVuY3Rpb25OYW1lfSBpcyBjb3JyZWN0LmA7XG4gICAgICAgICAgICBpZiAoZS5tZXNzYWdlLmluY2x1ZGVzKCdOdWxsSW5qZWN0b3JFcnJvcicpKSB7XG4gICAgICAgICAgICAgIG1lc3NhZ2UgPSBgWW91IGFyZSB1c2luZyB0aGUgJyR7ZnVuY3Rpb25OYW1lfScgZnVuY3Rpb24gaW4geW91ciB0cmFuc2xhdGlvbiBidXQgbm8gcHJvdmlkZXIgd2FzIGZvdW5kIWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICByZXR1cm4gc3VwZXIudHJhbnNwaWxlKHRyYW5zcGlsZWQsIHBhcmFtcywgdHJhbnNsYXRpb24pO1xuICAgIH1cblxuICAgIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgcGFyYW1zKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuaGFuZGxlT2JqZWN0KHZhbHVlLCBwYXJhbXMsIHRyYW5zbGF0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbiJdfQ==